<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java从入门到入坟 on Mr.哈利-南山不寒</title>
    <link>https://HarryQing.github.io/tags/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/</link>
    <description>Recent content in Java从入门到入坟 on Mr.哈利-南山不寒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 18 Mar 2021 23:43:00 +0800</lastBuildDate><atom:link href="https://HarryQing.github.io/tags/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2.2VMware虚拟机安装Linux系统(详解版)</title>
      <link>https://HarryQing.github.io/linuxs/2.2vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%E7%89%88/</link>
      <pubDate>Thu, 18 Mar 2021 23:43:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/linuxs/2.2vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%E7%89%88/</guid>
      <description>许多新手连 Windows 的安装都不太熟悉，更别提 Linux 的安装了；即使安装成功了，也有可能破坏现有的 Windows 系统，比如导致硬盘数据丢失、Windows 无法开机等。所以一直以来，安装 Linux 系统都是初学者的噩梦。
　然而，通过虚拟机技术很容易冲破这种困境。由于虚拟机安装 Linux 所有的操作（例如硬盘分区、删除或修改数据）都是在虚拟硬盘中进行，因此不会对现有的数据和系统造成任何损失，即使安装失败了也无所谓。
　所谓虚拟机（virtual machine），就是通过软件技术虚拟出来的一台计算机，它在使用层面和真实的计算机并没有什么区别。
　常见的虚拟机软件有 VMware Workstation（简称 VMware）、VirtualBox、Microsoft Virtual PC 等，其中 VMware 市场占有率最高，所以本节以 VMware 为例来讲解 Linux 的安装。
　VMware 可以使你在一台计算机上同时运行多个操作系统，例如同时运行 Windows、Linux 和 Mac OS。在计算机上直接安装多个操作系统，同一个时刻只能运行一个操作系统，重启才可以切换；而 Vmware 可以同时运行多个操作系统，可以像 Windows 应用程序一样来回切换。
 站在使用者的角度讲，虚拟机系统和真实安装的系统是一样的，甚至可以在一台计算机上将几个虚拟机系统连接为一个局域网或连接到互联网。
 　在虚拟机系统中，每一台虚拟产生的计算机都被称为“虚拟机”，而用来存储所有虚拟机的计算机则被称为“宿主机”。例如，你的 Windows 系统就是宿主机，而 VMware 安装的 Linux 则为虚拟机。
VMware下载和安装 　绝大多数初学者使用的是 Windows，所以本节只讲解在 Windows 下安装 VMware 和 Linux。
　VMware 有两个版本，分别是 VMware Workstation Pro 和 VMware Workstation Player。</description>
    </item>
    
    <item>
      <title>7.1数组概述和特点</title>
      <link>https://HarryQing.github.io/posts/7.1%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9/</link>
      <pubDate>Wed, 17 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/7.1%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9/</guid>
      <description>数组的定义 　数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们。数组的三个基本特点：
 1. 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。2. 其元素必须是相同类型，不允许出现混合类型。3. 数组类型可以是任何数据类型，包括基本类型和引用类型。 老鸟建议 　数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。</description>
    </item>
    
    <item>
      <title>第七章 数组</title>
      <link>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 16 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E7%BB%84/</guid>
      <description>预告：后面很精彩，记得持续关注喔！ </description>
    </item>
    
    <item>
      <title>6.7 如何利用百度解决异常问题</title>
      <link>https://HarryQing.github.io/posts/6.7-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E8%A7%A3%E5%86%B3%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 15 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.7-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E8%A7%A3%E5%86%B3%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</guid>
      <description>正常学习和开发中，我们经常会遇到各种异常。大家在遇到异常时，需要遵循下面四步来解决：
 1. 细心查看异常信息，确定异常种类和相关Java代码行号;2. 拷贝异常信息到百度，查看相关帖子，寻找解决思路;3. 前两步无法搞定，再问同学或同事;4. 前三步无法搞定，请示领导。 　很多同学碰到异常一下就慌了，立刻开始请教别人搬救兵，殊不知这样做有两大坏处。第一、太不尊重别人，把别人当苦力。第二、失去提高自我的机会，自己解决一个异常，就意味着有能力解决一类异常。解决一类异常能大大提高自身能力。</description>
    </item>
    
    <item>
      <title>6.6 自定义异常</title>
      <link>https://HarryQing.github.io/posts/6.6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sun, 14 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/</guid>
      <description>1.在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。
　2.自定义异常类只需从Exception类或者它的子类派生一个子类即可。
　3.自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。
　4.习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。
【示例6-10】 自定义异常类
/**IllegalAgeException：非法年龄异常，继承Exception类*/ class IllegalAgeException extends Exception { //默认构造器  public IllegalAgeException() { } //带有详细信息的构造器，信息存储在message中  public IllegalAgeException(String message) { super(message); } } 【示例6-11】 自定义异常类的使用
class Person { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) throws IllegalAgeException { if (age &amp;lt; 0) { throw new IllegalAgeException(&amp;#34;人的年龄不应该为负数&amp;#34;); } this.age = age; } public String toString() { return &amp;#34;name is &amp;#34; + name + &amp;#34; and age is &amp;#34; + age; } } public class TestMyException { public static void main(String[] args) { Person p = new Person(); try { p.</description>
    </item>
    
    <item>
      <title>hugo博客在GitHub上进行部署（二）</title>
      <link>https://HarryQing.github.io/blog/hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E4%BA%8C/</link>
      <pubDate>Sun, 14 Mar 2021 00:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/blog/hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E4%BA%8C/</guid>
      <description>创建新文章 hugo new 你的文档名/你的文章名.md
创建库 1.名称一定是：你的用户名.github.io 2.选择本地存储复制
部署到云端 1.在config.toml中改参数 2.生成public: 打开文件根目录的cmd或git bash here输入
hugo 3.进入public 4.在该页面下打开git bash here 5.相继输入以下代码
git init git add -Agit commit -am&amp;quot;init&amp;quot;git branch -M maingit remote add origin https://github.com/你的用户名/你的用户名.github.io.git（假如是我：git remote add origin https://github.com/HarryQing/HarryQing.github.io.git）git push -f origin master（无响应则再次运行同一代码，最多两次）你的博客:https://你的用户名.github.io/假如是我的博客：https://harryqing.github.io/ 笔者 git initgit add -Agit commit -am&amp;quot;init&amp;quot;git branch -M maingit remote add origin https://github.com/HarryQing/HarryQing.github.io.gitgit push -f origin main </description>
    </item>
    
    <item>
      <title>6.5 异常的处理方式之二：声明异常(throws子句)</title>
      <link>https://HarryQing.github.io/posts/6.5-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BA%8C%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8throws%E5%AD%90%E5%8F%A5/</link>
      <pubDate>Sat, 13 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.5-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BA%8C%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8throws%E5%AD%90%E5%8F%A5/</guid>
      <description>当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。
　在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。
　如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。
　如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。
【示例6-9】 典型代码(先不敲!)
import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class Test9 { public static void main(String[] args) { try { readFile(&amp;#34;joke.txt&amp;#34;); } catch (FileNotFoundException e) { System.out.println(&amp;#34;所需文件不存在！&amp;#34;); } catch (IOException e) { System.out.println(&amp;#34;文件读写错误！&amp;#34;); } } public static void readFile(String fileName) throws FileNotFoundException, IOException { FileReader in = new FileReader(fileName); int tem = 0; try { tem = in.read(); while (tem != -1) { System.</description>
    </item>
    
    <item>
      <title>6.4 异常的处理方式之一：捕获异常</title>
      <link>https://HarryQing.github.io/posts/6.4-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Fri, 12 Mar 2021 19:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.4-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</guid>
      <description>捕获异常是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可有多条;finally语句最多只能有一条，根据自己的需要可有可无)。如图6-10所示。
图6-10 异常处理
上面过程详细解析： 1. try： 　try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。
　一个try语句必须带有至少一个catch语句块或一个finally语句块 。
注意事项 　当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码。
2. catch： 　n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。
　n-常用方法，这些方法均继承自Throwable类 。
 u-toString ()方法，显示异常的类名和产生异常的原因u-getMessage()方法，只显示产生异常的原因，但不显示类名。u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。 　n-catch捕获异常时的捕获顺序：
　u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。
3. finally： 　n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。
　n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。
try-catch-finally语句块的执行过程： 　try-catch-finally程序块的执行流程以及执行结果比较复杂。
　基本执行过程如下：
　程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行;如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句块执行完后程序会继续执行finally语句块。finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。
注意事项    即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。
  finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。
   【示例6-8】 典型代码(先不要敲!!)
import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class Test8 { public static void main(String[] args) { FileReader reader = null; try { reader = new FileReader(&amp;#34;d:/a.</description>
    </item>
    
    <item>
      <title>6.3.4 CheckedException已检查异常</title>
      <link>https://HarryQing.github.io/posts/6.3.4-checkedexception%E5%B7%B2%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Fri, 12 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.3.4-checkedexception%E5%B7%B2%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8/</guid>
      <description>所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。如图6-9所示。
图6-9 CheckedException异常
　如图6-9所示，异常的处理方式有两种：使用“try/catch”捕获异常、使用“throws”声明异常。</description>
    </item>
    
    <item>
      <title>6.3.3 RuntimeException运行时异常</title>
      <link>https://HarryQing.github.io/posts/6.3.3-runtimeexception%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Thu, 11 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.3.3-runtimeexception%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/</guid>
      <description>派生于RuntimeException的异常，如被 0 除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。 因此由系统自动检测并将它们交给缺省的异常处理程序(用户可不必对其处理)。
　这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,经常需要通过增加“逻辑处理来避免这些异常”。
【示例6-3】 ArithmeticException异常：试图除以0
public class Test3 { public static void main(String[] args) { int b=0; System.out.println(1/b); } } 执行结果如图6-2所示：
图6-4 ArithmeticException异常
解决如上异常需要修改代码：
public class Test3 { public static void main(String[] args) { int b=0; if(b!=0){ System.out.println(1/b); } } } 当程序访问一个空对象的成员变量或方法，或者访问一个空数组的成员时会发生空指针异常(NullPointerException)。怎么处理? 【示例6-4】 NullPointerException异常
public class Test4 { public static void main(String[] args) { String str=null; System.out.println(str.charAt(0)); } } 执行结果如图6-5所示：
图6-5 NullPointerException异常
解决空指针异常，通常是增加非空判断：
public class Test4 { public static void main(String[] args) { String str=null; if(str!</description>
    </item>
    
  </channel>
</rss>
