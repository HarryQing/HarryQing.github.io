<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java从入门到入坟 on Mr.哈利-南山不寒</title>
    <link>https://HarryQing.github.io/tags/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/</link>
    <description>Recent content in Java从入门到入坟 on Mr.哈利-南山不寒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 17 Feb 2021 16:20:00 +0800</lastBuildDate><atom:link href="https://HarryQing.github.io/tags/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3.6 递归结构</title>
      <link>https://HarryQing.github.io/posts/3.6-%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 17 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.6-%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84/</guid>
      <description>递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。
利用递归可以用简单的程序来解决一些复杂的问题。比如：斐波那契数列的计算、汉诺塔、快排等问题。
递归结构包括两个部分： 1.定义递归头。解答：什么时候不调用自身方法。如果没有头，将陷入死循环，也就是递归的结束条件。
2.递归体。解答：什么时候需要调用自身方法。
【示例3-22】 递归：计算n!　public class Test22 {public static void main(String[] args) {long d1 = System.currentTimeMillis(); System.out.printf(&amp;quot;%d阶乘的结果:%s%n&amp;quot;, 10, factorial(10));long d2 = System.currentTimeMillis();System.out.printf(&amp;quot;递归费时：%s%n&amp;quot;, d2-d1); //耗时：32ms}/** 求阶乘的方法*/static long factorial(int n){if(n==1){//递归头return 1;}else{//递归体return n*factorial(n-1);//n! = n * (n-1)!}}} 图3-27 示例3-22运行效果图
图3-28 递归原理分析图
递归的缺陷 1.简单的程序是递归的优点之一。但是递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。
2.比如上面的递归耗时558ms。但是用普通循环的话快得多，如示例3-23所示。
【示例3-23】 使用循环求n!　public class Test23 {public static void main(String[] args) {long d3 = System.</description>
    </item>
    
    <item>
      <title>3.5 方法的重载(overload)</title>
      <link>https://HarryQing.github.io/posts/3.5-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BDoverload/</link>
      <pubDate>Tue, 16 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.5-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BDoverload/</guid>
      <description>方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。
雷区  重载的方法，实际是完全不同的方法，只是名称相同而已!构成方法重载的条件：1.不同的含义：形参类型、形参个数、形参顺序不同2.只有返回值不同不构成方法的重载如：int a(String str){}与 void a(String str){}不构成方法重载3.只有形参的名称不同，不构成方法的重载如：int a(String str){}与int a(String s){}不构成方法重载 【示例3-21】 方法重载
public class Test21 {public static void main(String[] args) {System.out.println(add(3, 5));// 8System.out.println(add(3, 5, 10));// 18System.out.println(add(3.0, 5));// 8.0System.out.println(add(3, 5.0));// 8.0// 我们已经见过的方法的重载System.out.println();// 0个参数System.out.println(1);// 参数是1个intSystem.out.println(3.0);// 参数是1个double}/** 求和的方法 */public static int add(int n1, int n2) {int sum = n1 + n2;return sum;}// 方法名相同，参数个数不同，构成重载public static int add(int n1, int n2, int n3) {int sum = n1 + n2 + n3;return sum;}// 方法名相同，参数类型不同，构成重载public static double add(double n1, int n2) {double sum = n1 + n2;return sum;}// 方法名相同，参数顺序不同，构成重载public static double add(int n1, double n2) {double sum = n1 + n2;return sum;}//编译错误：只有返回值不同，不构成方法的重载public static double add(int n1, int n2) {double sum = n1 + n2;return sum;}//编译错误：只有参数名称不同，不构成方法的重载public static int add(int n2, int n1) {double sum = n1 + n2; return sum;} } </description>
    </item>
    
    <item>
      <title>3.4 方法</title>
      <link>https://HarryQing.github.io/posts/3.4-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 15 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.4-%E6%96%B9%E6%B3%95/</guid>
      <description>方法就是一段用来完成特定功能的代码片段，类似于其它语言的函数。
方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。
方法声明格式： [修饰符1 修饰符2 …] 返回值类型 方法名(形式参数列表){Java语句；… … …} 方法的调用方式：  对象名.方法名(实参列表)方法的详细说明1. 形式参数：在方法声明时用于接收外界传入的数据。2. 实参：调用方法时实际传给方法的数据。3. 返回值：方法在执行完毕后返还给调用它的环境的数据。4. 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。 【示例3-20】 方法的声明及调用
public class Test20 {/** main方法：程序的入口 */public static void main(String[] args) {int num1 = 10;int num2 = 20;//调用求和的方法：将num1与num2的值传给add方法中的n1与n2// 求完和后将结果返回，用sum接收结果int sum = add(num1, num2);System.out.println(&amp;quot;sum = &amp;quot; + sum);//输出：sum = 30//调用打印的方法：该方法没有返回值print();}/** 求和的方法 */public static int add(int n1, int n2) {int sum = n1 + n2;return sum;//使用return返回计算的结果}/** 打印的方法 */public static void print() {System.</description>
    </item>
    
    <item>
      <title>3.3 语句块</title>
      <link>https://HarryQing.github.io/posts/3.3-%E8%AF%AD%E5%8F%A5%E5%9D%97/</link>
      <pubDate>Sun, 14 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.3-%E8%AF%AD%E5%8F%A5%E5%9D%97/</guid>
      <description>语句块(有时叫做复合语句)，是用花括号扩起的任意数量的简单Java语句。块确定了局部变量的作用域。块中的程序代码，作为一个整体，是要被一起执行的。块可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中定义的变量，因为语句块中定义的变量作用域只限于语句块。
【示例3-19】 语句块　public class Test19 {public static void main(String[] args) {int n;int a;{int k;int n; //编译错误：不能重复定义变量n} //变量k的作用域到此为止}} </description>
    </item>
    
    <item>
      <title>3.2.6 带标签的break和continue</title>
      <link>https://HarryQing.github.io/posts/3.2.6-%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84break%E5%92%8Ccontinue/</link>
      <pubDate>Sat, 13 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.2.6-%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84break%E5%92%8Ccontinue/</guid>
      <description>goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在Java语言中得到正式使用;Java没有goto语句。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子&amp;mdash;带标签的break和continue。
“标签”是指后面跟一个冒号的标识符，例如：“label:”。对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。
在 “goto有害”论中，最有问题的就是标签，而非goto， 随着标签在一个程序里数量的增多，产生错误的机会也越来越多。 但Java标签不会造成这方面的问题，因为它们的活动场所已被限死，不可通过特别的方式到处传递程序的控制权。由此也引出了一个有趣的问题：通过限制语句的能力，反而能使一项语言特性更加有用。
【示例3-18】 带标签break和continue：控制嵌套循环跳转(打印101-150之间所有的质数)
public class Test18 {public static void main(String args[]) {outer: for (int i = 101; i &amp;lt; 150; i++) {for (int j = 2; j &amp;lt; i / 2; j++) {if (i % j == 0){continue outer;}}System.out.print(i + &amp;quot; &amp;quot;);}}} </description>
    </item>
    
    <item>
      <title>3.2.5 break语句和continue语句</title>
      <link>https://HarryQing.github.io/posts/3.2.5-break%E8%AF%AD%E5%8F%A5%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Fri, 12 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.2.5-break%E8%AF%AD%E5%8F%A5%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5/</guid>
      <description>在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。
【示例3-16】 break语句
public class Test16 {public static void main(String[] args) {int total = 0;//定义计数器System.out.println(&amp;quot;Begin&amp;quot;);while (true) {total++;//每循环一次计数器加1int i = (int) Math.round(100 * Math.random());//当i等于88时，退出循环if (i == 88) {break;}}//输出循环的次数System.out.println(&amp;quot;Game over， used &amp;quot; + total + &amp;quot; times.&amp;quot;);}} 　continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。
注意事项   continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。
  continue用在for循环中，跳到for循环的迭代因子部分。
  【示例3-17】 continue语句：把100~150之间不能被3整除的数输出，并且每行输出5个
public class Test17 {public static void main(String[] args) {int count = 0;//定义计数器for (int i = 100; i &amp;lt; 150; i++) {//如果是3的倍数，则跳过本次循环，继续进行下一次循环if (i % 3 == 0){continue;}//否则（不是3的倍数），输出该数System.</description>
    </item>
    
    <item>
      <title>3.2.4 嵌套循环</title>
      <link>https://HarryQing.github.io/posts/3.2.4-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Thu, 11 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.2.4-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF/</guid>
      <description>在一个循环语句内部再嵌套一个或多个循环，称为嵌套循环。while、do-while与for循环可以任意嵌套多层。
【示例3-14】 嵌套循环　public class Test14 {public static void main(String args[]) {for (int i=1; i &amp;lt;=5; i++) {for(int j=1; j&amp;lt;=5; j++){System.out.print(i+&amp;quot; &amp;quot;);}System.out.println();}}} 【示例3-15】 使用嵌套循环实现九九乘法表
public class Test15 {public static void main(String args[]) {for (int i = 1; i &amp;lt; 10; i++) { // i是一个乘数for (int j = 1; j &amp;lt;= i; j++) { // j是另一个乘数System.out.print(j + &amp;quot;*&amp;quot; + i + &amp;quot;=&amp;quot; + (i * j &amp;lt; 10 ?</description>
    </item>
    
    <item>
      <title>3.2.3 for循环</title>
      <link>https://HarryQing.github.io/posts/3.2.3-for%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Wed, 10 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.2.3-for%E5%BE%AA%E7%8E%AF/</guid>
      <description>语法结构：　 for (初始表达式; 布尔表达式; 迭代因子) {循环体;} for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。for循环在第一次反复之前要进行初始化，即执行初始表达式;随后，对布尔表达式进行判定，若判定结果为true，则执行循环体，否则，终止循环;最后在每一次反复的时候，进行某种形式的“步进”，即执行迭代因子。
 A. 初始化部分设置循环变量的初值B. 条件判断部分为任意布尔表达式C. 迭代因子控制循环变量的增减for循环在执行条件判定后，先执行的循环体部分，再执行步进。for循环结构的流程图如图3-18所示。 【示例3-10】 for循环　public class Test10 {public static void main(String args[]) {int sum = 0;//1.求1-100之间的累加和for (int i = 0; i &amp;lt;= 100; i++) {sum += i;}System.out.println(&amp;quot;Sum= &amp;quot; + sum);//2.循环输出9-1之间的数for(int i=9;i&amp;gt;0;i--){System.out.print(i+&amp;quot;、&amp;quot;);}System.out.println();//3.输出90-1之间能被3整除的数for(int i=90;i&amp;gt;0;i-=3){System.out.print(i+&amp;quot;、&amp;quot;);}System.out.println();}} Java里能用到逗号运算符的地方屈指可数，其中一处就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，我们可以使用一系列由逗号分隔的表达式，而且那些表达式均会独立执行。</description>
    </item>
    
    <item>
      <title>3.2.2 do-while循环</title>
      <link>https://HarryQing.github.io/posts/3.2.2-do-while%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Tue, 09 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.2.2-do-while%E5%BE%AA%E7%8E%AF/</guid>
      <description>语法结构： do {循环体;} while(布尔表达式) ; do-while循环结构会先执行循环体，然后再判断布尔表达式的值，若条件为真，执行循环体，当条件为假时结束循环。do-while循环的循环体至少执行一次。do-while循环结构流程图如图3.15所示。
【示例3-8】 do-while循环结构：1-100之间的累加和
public class Test8 {public static void main(String[] args) {int i = 0;int sum = 0;do {sum += i; // sum = sum + ii++;} while (i &amp;lt;= 100);//此处的；不能省略System.out.println(&amp;quot;Sum= &amp;quot; + sum);}} 　【示例3-9】 while与do-while的区别
public class Test9 {public static void main(String[] args) {//while循环：先判断再执行int a = 0;while (a &amp;lt; 0) {System.</description>
    </item>
    
    <item>
      <title>3.2.1 while循环</title>
      <link>https://HarryQing.github.io/posts/3.2.1-while%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Mon, 08 Feb 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/3.2.1-while%E5%BE%AA%E7%8E%AF/</guid>
      <description>语法结构：　 while (布尔表达式) {循环体;} 在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。
语句中应有使循环趋向于结束的语句，否则会出现无限循环–––&amp;ldquo;死&amp;quot;循环。
while循环结构流程图如图3.13所示。
【示例3-7】 while循环结构：求1到100之间的累加和
public class Test7 {public static void main(String[] args) {int i = 0;int sum = 0;// 1+2+3+…+100=?while (i &amp;lt;= 100) {sum += i;//相当于sum = sum+i;i++;}System.out.println(&amp;quot;Sum= &amp;quot; + sum);}} </description>
    </item>
    
  </channel>
</rss>
