<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java从入门到入坟 on Mr.哈利-南山不寒</title>
    <link>https://HarryQing.github.io/tags/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/</link>
    <description>Recent content in Java从入门到入坟 on Mr.哈利-南山不寒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 18 Mar 2021 23:43:00 +0800</lastBuildDate><atom:link href="https://HarryQing.github.io/tags/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2.2VMware虚拟机安装Linux系统(详解版)</title>
      <link>https://HarryQing.github.io/linuxs/2.2vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%E7%89%88/</link>
      <pubDate>Thu, 18 Mar 2021 23:43:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/linuxs/2.2vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%E7%89%88/</guid>
      <description>许多新手连 Windows 的安装都不太熟悉，更别提 Linux 的安装了；即使安装成功了，也有可能破坏现有的 Windows 系统，比如导致硬盘数据丢失、Windows 无法开机等。所以一直以来，安装 Linux 系统都是初学者的噩梦。
　然而，通过虚拟机技术很容易冲破这种困境。由于虚拟机安装 Linux 所有的操作（例如硬盘分区、删除或修改数据）都是在虚拟硬盘中进行，因此不会对现有的数据和系统造成任何损失，即使安装失败了也无所谓。
　所谓虚拟机（virtual machine），就是通过软件技术虚拟出来的一台计算机，它在使用层面和真实的计算机并没有什么区别。
　常见的虚拟机软件有 VMware Workstation（简称 VMware）、VirtualBox、Microsoft Virtual PC 等，其中 VMware 市场占有率最高，所以本节以 VMware 为例来讲解 Linux 的安装。
　VMware 可以使你在一台计算机上同时运行多个操作系统，例如同时运行 Windows、Linux 和 Mac OS。在计算机上直接安装多个操作系统，同一个时刻只能运行一个操作系统，重启才可以切换；而 Vmware 可以同时运行多个操作系统，可以像 Windows 应用程序一样来回切换。
 站在使用者的角度讲，虚拟机系统和真实安装的系统是一样的，甚至可以在一台计算机上将几个虚拟机系统连接为一个局域网或连接到互联网。
 　在虚拟机系统中，每一台虚拟产生的计算机都被称为“虚拟机”，而用来存储所有虚拟机的计算机则被称为“宿主机”。例如，你的 Windows 系统就是宿主机，而 VMware 安装的 Linux 则为虚拟机。
VMware下载和安装 　绝大多数初学者使用的是 Windows，所以本节只讲解在 Windows 下安装 VMware 和 Linux。
　VMware 有两个版本，分别是 VMware Workstation Pro 和 VMware Workstation Player。</description>
    </item>
    
    <item>
      <title>hugo博客在GitHub上进行部署（二）</title>
      <link>https://HarryQing.github.io/blog/hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E4%BA%8C/</link>
      <pubDate>Sun, 14 Mar 2021 00:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/blog/hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E4%BA%8C/</guid>
      <description>创建新文章 hugo new 你的文档名/你的文章名.md
创建库 1.名称一定是：你的用户名.github.io 2.选择本地存储复制
部署到云端 1.在config.toml中改参数 2.生成public: 打开文件根目录的cmd或git bash here输入
hugo 3.进入public 4.在该页面下打开git bash here 5.相继输入以下代码
git init git add -Agit commit -am&amp;quot;init&amp;quot;git branch -M maingit remote add origin https://github.com/你的用户名/你的用户名.github.io.git（假如是我：git remote add origin https://github.com/HarryQing/HarryQing.github.io.git）git push -f origin master（无响应则再次运行同一代码，最多两次）你的博客:https://你的用户名.github.io/假如是我的博客：https://harryqing.github.io/ 笔者 git initgit add -Agit commit -am&amp;quot;init&amp;quot;git branch -M maingit remote add origin https://github.com/HarryQing/HarryQing.github.io.gitgit push -f origin main </description>
    </item>
    
    <item>
      <title>6.3 异常分类</title>
      <link>https://HarryQing.github.io/posts/6.3-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/</link>
      <pubDate>Tue, 09 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.3-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/</guid>
      <description>JDK 中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。
　Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。Java异常类的层次结构如图6-2所示。</description>
    </item>
    
    <item>
      <title>6.2 异常(Exception)的概念</title>
      <link>https://HarryQing.github.io/posts/6.2-%E5%BC%82%E5%B8%B8exception%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 08 Mar 2021 22:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.2-%E5%BC%82%E5%B8%B8exception%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需要处理的文件不存在、数组下标越界等。
　在Java的异常处理机制中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中包含了该类异常的信息和对异常进行处理的方法。
　所谓异常处理，就是指程序在出现问题时依然可以正确的执行完。
　我们开始看我们的第一个异常对象，并分析一下异常机制是如何工作的。
【示例6-2】 异常的分析
public class Test2 { public static void main(String[] args) { int i=1/0; //除数为0  System.out.println(i); } } Java是采用面向对象的方式来处理异常的。处理过程： 　1. 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。
　2. 捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。</description>
    </item>
    
    <item>
      <title>6.1 导引问题</title>
      <link>https://HarryQing.github.io/posts/6.1-%E5%AF%BC%E5%BC%95%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 08 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/6.1-%E5%AF%BC%E5%BC%95%E9%97%AE%E9%A2%98/</guid>
      <description>　在实际工作中，我们遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求;你的程序要打开某个文件，这个文件可能不存在或者文件格式不对;你要读取数据库的数据，数据可能是空的;我们的程序再运行着，但是内存或硬盘可能满了等等。
　软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为异常，英文是：Exception，意思是例外。遇到这些例外情况，或者叫异常，我们怎么让写的程序做出合理的处理，安全的退出，而不至于程序崩溃呢?我们本章就要讲解这些问题。
　如果我们要拷贝一个文件，在没有异常机制的情况下，我们需要考虑各种异常情况，伪代码如下：
【示例6-1】 伪代码使用if处理程序中可能出现的各种情况
public class Test1 { public static void main(String[] args) { //将d:/a.txt复制到e:/a.txt  if(&amp;#34;d:/a.txt&amp;#34;这个文件存在){ if(e盘的空间大于a.txt文件长度){ if(文件复制一半IO流断掉){ 停止copy，输出：IO流出问题！ }else{ copyFile(&amp;#34;d:/a.txt&amp;#34;,&amp;#34;e:/a.txt&amp;#34;); } }else{ System.out.println(&amp;#34;e盘空间不够存放a.txt！&amp;#34;); } }else{ System.out.println(&amp;#34;a.txt不存在！&amp;#34;); } } } 这种方式，有两个坏处：  1. 逻辑代码和错误处理代码放一起!2. 程序员本身需要考虑的例外情况较复杂，对程序员本身要求较高! 　那么，我们如何解决应对异常情况呢?Java的异常机制给我们提供了方便的处理方式。如上情况，如果是用Java的异常机制来处理，示意代码如下(仅限示意，不能运行)：
try { copyFile(&amp;#34;d:/a.txt&amp;#34;,&amp;#34;e:/a.txt&amp;#34;); } catch (Exception e) { e.printStackTrace(); } 异常机制本质  就是当程序出现错误，程序安全退出的机制。 </description>
    </item>
    
    <item>
      <title>第六章 异常机制</title>
      <link>https://HarryQing.github.io/posts/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 07 Mar 2021 23:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</guid>
      <description>预告：后面很精彩，记得持续关注喔！ </description>
    </item>
    
    <item>
      <title>5.12.3 组合模式</title>
      <link>https://HarryQing.github.io/posts/5.12.3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 07 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.12.3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>组合模式是将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
【示例5-34】 对象的组合
class Cpu { public void run() { System.out.println(&amp;#34;quickly.........&amp;#34;); } } class MainBoard { public void connect() { System.out.println(&amp;#34;connect...........&amp;#34;); } } class Memory { public void store() { System.out.println(&amp;#34;store........&amp;#34;); } } public class Computer { Cpu cpu; Memory memory; MainBoard mainBoard; public void work() { cpu.run(); memory.store(); mainBoard.connect(); } public static void main(String[] args) { Computer computer = new Computer(); computer.cpu = new Cpu(); computer.mainBoard = new MainBoard(); computer.</description>
    </item>
    
    <item>
      <title>5.12.2 模板方法模式和回调机制</title>
      <link>https://HarryQing.github.io/posts/5.12.2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 06 Mar 2021 12:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.12.2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</guid>
      <description>模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。 详见抽象类部分示例。
　其实在Java开发中，还有另外一个方法可以实现同样的功能，那就是Java回调技术。回调是一种双向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口，简单点说明就是：A类中调用B类中的C方法，然后B类中的C方法中反过来调用A类中的D方法，那么D这个方法就叫回调方法。
回调的具体过程如下：  1. Class A实现接口CallBack —— 背景12. class A中包含class B的引用 ——背景23. class B有一个参数为CallBack的方法C ——背景34. 前三条是我们的准备条件，接下来A的对象调用B的方法C5. 然后class B就可以在C方法中调用A的方法D 　这样说大家可能还是不太理解，下面我们根据示例5-33来说明回调机制。该示例的生活背景为：有一天小刘遇到一个很难的问题“学习Java选哪家机构呢?”，于是就打电话问小高，小高一时也不太了解行情，就跟小刘说，我现在还有事，等忙完了给你咨询咨询，小刘也不会傻傻的拿着电话去等小高的答案，于是小刘对小高说，先挂电话吧，你知道答案后再打我电话告诉我吧，于是挂了电话。小高先去办自己的事情去了，过了几个小时，小高打电话给小刘，告诉他答案是“学Java当然去北京尚学堂”。
【示例5-33】 回调机制示例
/** * 回调接口 */ interface CallBack { /** * 小高知道答案后告诉小刘时需要调用的方法，即回调方法 * @param result 是问题的答案 */ public void answer(String result); } /** * 小刘类：实现了回调接口CallBack（背景一） */ class Liu implements CallBack { /** * 包含小高对象的引用 （背景二） */ private Gao gao; public Liu(Gao gao){ this.</description>
    </item>
    
    <item>
      <title>5.12.1 开闭原则</title>
      <link>https://HarryQing.github.io/posts/5.12.1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sat, 06 Mar 2021 10:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.12.1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>开闭原则(Open-Closed Principle)就是让设计的系统对扩展开放，对修改封闭。
· 对扩展开放： 　就是指，应对需求变化要灵活。 要增加新功能时，不需要修改已有的代码，增加新代码即可。
· 对修改关闭： 　就是指，核心部分经过精心设计后，不再因为需求变化而改变。
　在实际开发中，我们无法完全做到，但应尽量遵守开闭原则。</description>
    </item>
    
    <item>
      <title>5.11.5 字符串相等的判断</title>
      <link>https://HarryQing.github.io/posts/5.11.5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD/</link>
      <pubDate>Sat, 06 Mar 2021 08:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.11.5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD/</guid>
      <description>1. equals方法用来检测两个字符串内容是否相等。如果字符串s和t内容相等，则s.equals(t)返回true，否则返回false。
　2. 要测试两个字符串除了大小写区别外是否是相等的，需要使用equalsIgnoreCase方法。
　3. 判断字符串是否相等不要使用&amp;quot;==&amp;quot;。
【示例5-31】 忽略大小写的字符串比较
&amp;#34;Hello&amp;#34;.equalsIgnoreCase(&amp;#34;hellO&amp;#34;);//true 【示例5-32】 字符串的比较&amp;quot;==&amp;ldquo;与equals()方法
public class TestStringEquals { public static void main(String[] args) { String g1 = &amp;#34;大爱雪儿&amp;#34;; String g2 = &amp;#34;大爱雪儿&amp;#34;; String g3 = new String(&amp;#34;大爱雪儿&amp;#34;); System.out.println(g1 == g2); // true 指向同样的字符串常量对象 	System.out.println(g1 == g3); // false g3是新创建的对象 	System.out.println(g1.equals(g3)); // true g1和g3里面的字符串内容是一样的 	} } 执行结果如图5-33所示：
图5-33 示例5-32运行效果图</description>
    </item>
    
  </channel>
</rss>
