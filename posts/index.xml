<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Mr.哈利-南山不寒</title>
		<link>https://HarryQing.github.io/posts/</link>
		<description>Recent content in Posts on Mr.哈利-南山不寒</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 17 Mar 2021 16:20:00 +0800</lastBuildDate>
		<atom:link href="https://HarryQing.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>7.1数组概述和特点</title>
			<link>https://HarryQing.github.io/posts/7.1%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9/</link>
			<pubDate>Wed, 17 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/7.1%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9/</guid>
			<description>数组的定义 　数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们。数组的三个基本特点：
 1. 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。2. 其元素必须是相同类型，不允许出现混合类型。3. 数组类型可以是任何数据类型，包括基本类型和引用类型。 老鸟建议 　数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。</description>
			<content type="html"><![CDATA[<h2 id="数组的定义">数组的定义</h2>
<p>　　数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们。数组的三个基本特点：</p>
<pre><code>  1. 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。

  2. 其元素必须是相同类型，不允许出现混合类型。

  3. 数组类型可以是任何数据类型，包括基本类型和引用类型。
</code></pre>
<h2 id="老鸟建议">老鸟建议</h2>
<p>　　数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。</p>
]]></content>
		</item>
		
		<item>
			<title>第七章 数组</title>
			<link>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E7%BB%84/</link>
			<pubDate>Tue, 16 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E7%BB%84/</guid>
			<description>预告：后面很精彩，记得持续关注喔！ </description>
			<content type="html"><![CDATA[<h2 id="预告后面很精彩记得持续关注喔">预告：后面很精彩，记得持续关注喔！</h2>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTaJ9L07ilSbT07YPKG-X108O_6L9vgSyNzVA&amp;usqp=CAU" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>6.7 如何利用百度解决异常问题</title>
			<link>https://HarryQing.github.io/posts/6.7-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E8%A7%A3%E5%86%B3%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</link>
			<pubDate>Mon, 15 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.7-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E8%A7%A3%E5%86%B3%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</guid>
			<description>正常学习和开发中，我们经常会遇到各种异常。大家在遇到异常时，需要遵循下面四步来解决：
 1. 细心查看异常信息，确定异常种类和相关Java代码行号;2. 拷贝异常信息到百度，查看相关帖子，寻找解决思路;3. 前两步无法搞定，再问同学或同事;4. 前三步无法搞定，请示领导。 　很多同学碰到异常一下就慌了，立刻开始请教别人搬救兵，殊不知这样做有两大坏处。第一、太不尊重别人，把别人当苦力。第二、失去提高自我的机会，自己解决一个异常，就意味着有能力解决一类异常。解决一类异常能大大提高自身能力。</description>
			<content type="html"><![CDATA[<p>　　正常学习和开发中，我们经常会遇到各种异常。大家在遇到异常时，需要遵循下面四步来解决：</p>
<pre><code>  1. 细心查看异常信息，确定异常种类和相关Java代码行号;

  2. 拷贝异常信息到百度，查看相关帖子，寻找解决思路;

  3. 前两步无法搞定，再问同学或同事;

  4. 前三步无法搞定，请示领导。
</code></pre>
<p>　　很多同学碰到异常一下就慌了，立刻开始请教别人搬救兵，殊不知这样做有两大坏处。第一、太不尊重别人，把别人当苦力。第二、失去提高自我的机会，自己解决一个异常，就意味着有能力解决一类异常。解决一类异常能大大提高自身能力。</p>
]]></content>
		</item>
		
		<item>
			<title>6.6 自定义异常</title>
			<link>https://HarryQing.github.io/posts/6.6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/</link>
			<pubDate>Sun, 14 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/</guid>
			<description>1.在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。
　2.自定义异常类只需从Exception类或者它的子类派生一个子类即可。
　3.自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。
　4.习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。
【示例6-10】 自定义异常类
/**IllegalAgeException：非法年龄异常，继承Exception类*/ class IllegalAgeException extends Exception { //默认构造器  public IllegalAgeException() { } //带有详细信息的构造器，信息存储在message中  public IllegalAgeException(String message) { super(message); } } 【示例6-11】 自定义异常类的使用
class Person { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) throws IllegalAgeException { if (age &amp;lt; 0) { throw new IllegalAgeException(&amp;#34;人的年龄不应该为负数&amp;#34;); } this.age = age; } public String toString() { return &amp;#34;name is &amp;#34; + name + &amp;#34; and age is &amp;#34; + age; } } public class TestMyException { public static void main(String[] args) { Person p = new Person(); try { p.</description>
			<content type="html"><![CDATA[<p>　　1.在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。</p>
<p>　　2.自定义异常类只需从Exception类或者它的子类派生一个子类即可。</p>
<p>　　3.自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。</p>
<p>　　4.习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。</p>
<p><strong>【示例6-10】</strong> 自定义异常类</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**IllegalAgeException：非法年龄异常，继承Exception类*/</span>
<span class="kd">class</span> <span class="nc">IllegalAgeException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="c1">//默认构造器
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">IllegalAgeException</span><span class="o">()</span> <span class="o">{</span>
     
    <span class="o">}</span>
    <span class="c1">//带有详细信息的构造器，信息存储在message中
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">IllegalAgeException</span><span class="o">(</span><span class="n">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><strong>【示例6-11】</strong> 自定义异常类的使用</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IllegalAgeException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalAgeException</span><span class="o">(</span><span class="s">&#34;人的年龄不应该为负数&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;name is &#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#34; and age is &#34;</span> <span class="o">+</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestMyException</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Lincoln&#34;</span><span class="o">);</span>
            <span class="n">p</span><span class="o">.</span><span class="na">setAge</span><span class="o">(-</span><span class="n">1</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAgeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(-</span><span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图6-11所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495274668102315.png" alt="enter description here"></p>
<h2 id="使用异常机制的建议">使用异常机制的建议</h2>
<blockquote>
<p>1.要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。</p>
<p>2.处理异常不可以代替简单测试&mdash;只在异常情况下使用异常机制。</p>
<p>3.不要进行小粒度的异常处理&mdash;应该将整个任务包装在一个try语句块中。</p>
<p>4.异常往往在高层处理(先了解!后面做项目会说!) 。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>6.5 异常的处理方式之二：声明异常(throws子句)</title>
			<link>https://HarryQing.github.io/posts/6.5-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BA%8C%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8throws%E5%AD%90%E5%8F%A5/</link>
			<pubDate>Sat, 13 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.5-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BA%8C%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8throws%E5%AD%90%E5%8F%A5/</guid>
			<description>当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。
　在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。
　如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。
　如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。
【示例6-9】 典型代码(先不敲!)
import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class Test9 { public static void main(String[] args) { try { readFile(&amp;#34;joke.txt&amp;#34;); } catch (FileNotFoundException e) { System.out.println(&amp;#34;所需文件不存在！&amp;#34;); } catch (IOException e) { System.out.println(&amp;#34;文件读写错误！&amp;#34;); } } public static void readFile(String fileName) throws FileNotFoundException, IOException { FileReader in = new FileReader(fileName); int tem = 0; try { tem = in.read(); while (tem != -1) { System.</description>
			<content type="html"><![CDATA[<p>　　当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。</p>
<p>　　在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。</p>
<p>　　如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。</p>
<p>　　如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。</p>
<p><strong>【示例6-9】</strong> 典型代码(先不敲!)</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.io.FileNotFoundException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test9</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">readFile</span><span class="o">(</span><span class="s">&#34;joke.txt&#34;</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;所需文件不存在！&#34;</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;文件读写错误！&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">readFile</span><span class="o">(</span><span class="n">String</span> <span class="n">fileName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">FileNotFoundException</span><span class="o">,</span>          
    <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">FileReader</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileReader</span><span class="o">(</span><span class="n">fileName</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">tem</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">tem</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">tem</span><span class="o">);</span>
                <span class="n">tem</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="注意事项">注意事项</h2>
<p>　　1. 方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。</p>
]]></content>
		</item>
		
		<item>
			<title>6.4 异常的处理方式之一：捕获异常</title>
			<link>https://HarryQing.github.io/posts/6.4-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</link>
			<pubDate>Fri, 12 Mar 2021 19:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.4-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</guid>
			<description>捕获异常是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可有多条;finally语句最多只能有一条，根据自己的需要可有可无)。如图6-10所示。
图6-10 异常处理
上面过程详细解析： 1. try： 　try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。
　一个try语句必须带有至少一个catch语句块或一个finally语句块 。
注意事项 　当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码。
2. catch： 　n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。
　n-常用方法，这些方法均继承自Throwable类 。
 u-toString ()方法，显示异常的类名和产生异常的原因u-getMessage()方法，只显示产生异常的原因，但不显示类名。u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。 　n-catch捕获异常时的捕获顺序：
　u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。
3. finally： 　n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。
　n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。
try-catch-finally语句块的执行过程： 　try-catch-finally程序块的执行流程以及执行结果比较复杂。
　基本执行过程如下：
　程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行;如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句块执行完后程序会继续执行finally语句块。finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。
注意事项    即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。
  finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。
   【示例6-8】 典型代码(先不要敲!!)
import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class Test8 { public static void main(String[] args) { FileReader reader = null; try { reader = new FileReader(&amp;#34;d:/a.</description>
			<content type="html"><![CDATA[<p>　　捕获异常是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可有多条;finally语句最多只能有一条，根据自己的需要可有可无)。如图6-10所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273755315926.png" alt="enter description here"></p>
<p>图6-10 异常处理</p>
<h2 id="上面过程详细解析">上面过程详细解析：</h2>
<h3 id="1-try">1. try：</h3>
<p>　　try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。</p>
<p>　　一个try语句必须带有至少一个catch语句块或一个finally语句块 。</p>
<h3 id="注意事项">注意事项</h3>
<p>　　当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码。</p>
<h2 id="2-catch">2. catch：</h2>
<p>　　n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<p>　　n-常用方法，这些方法均继承自Throwable类 。</p>
<pre><code>      u-toString ()方法，显示异常的类名和产生异常的原因

      u-getMessage()方法，只显示产生异常的原因，但不显示类名。

      u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。
</code></pre>
<p>　　 n-catch捕获异常时的捕获顺序：</p>
<p>　　u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。</p>
<h2 id="3-finally">3. finally：</h2>
<p>　　n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。</p>
<p>　　n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。</p>
<h3 id="try-catch-finally语句块的执行过程">try-catch-finally语句块的执行过程：</h3>
<p>　　try-catch-finally程序块的执行流程以及执行结果比较复杂。</p>
<p>　　基本执行过程如下：</p>
<p>　　程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行;如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句块执行完后程序会继续执行finally语句块。finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。</p>
<h3 id="注意事项-1">注意事项</h3>
<blockquote>
<ol>
<li>
<p>即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。</p>
</li>
<li>
<p>finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。</p>
</li>
</ol>
</blockquote>
<p><strong>【示例6-8】</strong> 典型代码(先不要敲!!)</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.io.FileNotFoundException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test8</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FileReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileReader</span><span class="o">(</span><span class="s">&#34;d:/a.txt&#34;</span><span class="o">);</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="n">reader</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
            <span class="kt">char</span> <span class="n">c2</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="n">reader</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;&#34;</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">c2</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">reader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>6.3.4 CheckedException已检查异常</title>
			<link>https://HarryQing.github.io/posts/6.3.4-checkedexception%E5%B7%B2%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8/</link>
			<pubDate>Fri, 12 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.3.4-checkedexception%E5%B7%B2%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8/</guid>
			<description>所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。如图6-9所示。
图6-9 CheckedException异常
　如图6-9所示，异常的处理方式有两种：使用“try/catch”捕获异常、使用“throws”声明异常。</description>
			<content type="html"><![CDATA[<p>　　所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。如图6-9所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273524104532.png" alt="enter description here"></p>
<p>图6-9 CheckedException异常</p>
<p>　　如图6-9所示，异常的处理方式有两种：使用“try/catch”捕获异常、使用“throws”声明异常。</p>
]]></content>
		</item>
		
		<item>
			<title>6.3.3 RuntimeException运行时异常</title>
			<link>https://HarryQing.github.io/posts/6.3.3-runtimeexception%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/</link>
			<pubDate>Thu, 11 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.3.3-runtimeexception%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/</guid>
			<description>派生于RuntimeException的异常，如被 0 除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。 因此由系统自动检测并将它们交给缺省的异常处理程序(用户可不必对其处理)。
　这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,经常需要通过增加“逻辑处理来避免这些异常”。
【示例6-3】 ArithmeticException异常：试图除以0
public class Test3 { public static void main(String[] args) { int b=0; System.out.println(1/b); } } 执行结果如图6-2所示：
图6-4 ArithmeticException异常
解决如上异常需要修改代码：
public class Test3 { public static void main(String[] args) { int b=0; if(b!=0){ System.out.println(1/b); } } } 当程序访问一个空对象的成员变量或方法，或者访问一个空数组的成员时会发生空指针异常(NullPointerException)。怎么处理? 【示例6-4】 NullPointerException异常
public class Test4 { public static void main(String[] args) { String str=null; System.out.println(str.charAt(0)); } } 执行结果如图6-5所示：
图6-5 NullPointerException异常
解决空指针异常，通常是增加非空判断：
public class Test4 { public static void main(String[] args) { String str=null; if(str!</description>
			<content type="html"><![CDATA[<p>　　派生于RuntimeException的异常，如被 0 除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。 因此由系统自动检测并将它们交给缺省的异常处理程序(用户可不必对其处理)。</p>
<p>　　这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,经常需要通过增加“逻辑处理来避免这些异常”。</p>
<p><strong>【示例6-3】</strong> ArithmeticException异常：试图除以0</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test3</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">0</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">1</span><span class="o">/</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图6-2所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495272824431581.png" alt="enter description here"></p>
<p>图6-4 ArithmeticException异常</p>
<p>解决如上异常需要修改代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test3</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">!=</span><span class="n">0</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">1</span><span class="o">/</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="当程序访问一个空对象的成员变量或方法或者访问一个空数组的成员时会发生空指针异常nullpointerexception怎么处理">当程序访问一个空对象的成员变量或方法，或者访问一个空数组的成员时会发生空指针异常(NullPointerException)。怎么处理?</h2>
<p><strong>【示例6-4】</strong> NullPointerException异常</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test4</span> <span class="o">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图6-5所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495272942791321.png" alt="enter description here"></p>
<p>图6-5 NullPointerException异常</p>
<p>解决空指针异常，通常是增加非空判断：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test4</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">str</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="在引用数据类型转换时有可能发生类型转换异常classcastexception">在引用数据类型转换时，有可能发生类型转换异常(ClassCastException)。</h2>
<p><strong>【示例6-5】</strong> ClassCastException异常</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Animal</span><span class="o">{</span>
     
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">{</span>
     
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">{</span>
     
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test5</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Animal</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="n">Dog</span><span class="o">();</span>
        <span class="n">Cat</span> <span class="n">c</span><span class="o">=(</span><span class="n">Cat</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图6-6所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273027294909.png" alt="enter description here"></p>
<p>图6-6 ClassCastException异常</p>
<p>解决ClassCastException的典型方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test5</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Animal</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="k">instanceof</span> <span class="n">Cat</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Cat</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">Cat</span><span class="o">)</span> <span class="n">a</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="当程序访问一个数组的某个元素时如果这个元素的索引超出了0数组长度-1这个范围则会出现数组下标越界异常arrayindexoutofboundsexception">当程序访问一个数组的某个元素时，如果这个元素的索引超出了0~数组长度-1这个范围，则会出现数组下标越界异常(ArrayIndexOutOfBoundsException)。</h2>
<p><strong>【示例6-6】</strong> ArrayIndexOutOfBoundsException异常</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test6</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">5</span><span class="o">];</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">5</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图6-7所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273151308733.png" alt="enter description here"></p>
<p>图6-7 ArrayIndexOutOfBoundsException异常</p>
<p>解决数组索引越界异常的方式，增加关于边界的判断：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test6</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">5</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">5</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">a</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="在使用包装类将字符串转换成基本数据类型时如果字符串的格式不正确则会出现数字格式异常numberformatexception">在使用包装类将字符串转换成基本数据类型时，如果字符串的格式不正确，则会出现数字格式异常(NumberFormatException)。</h2>
<p><strong>【示例6-7】</strong> NumberFormatException异常</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;1234abcf&#34;</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图6-8所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273246414396.png" alt="enter description here"></p>
<p>图6-8 NumberFormatException异常</p>
<p>数字格式化异常的解决，可以引入正则表达式判断是否为数字：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.regex.Matcher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.regex.Pattern</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;1234abcf&#34;</span><span class="o">;</span>
        <span class="n">Pattern</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">&#34;^\\d+$&#34;</span><span class="o">);</span>
        <span class="n">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">matches</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 如果str匹配代表数字的正则表达式,才会转换
</span><span class="c1"></span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="注意事项">注意事项</h2>
<blockquote>
<ol>
<li>
<p>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器(exception handler)。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。</p>
</li>
<li>
<p>运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
</li>
</ol>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>6.3.2 Exception</title>
			<link>https://HarryQing.github.io/posts/6.3.2-exception/</link>
			<pubDate>Wed, 10 Mar 2021 19:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.3.2-exception/</guid>
			<description>　Exception是程序本身能够处理的异常，如：空指针异常(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。
　Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为：
 1. RuntimeException 运行时异常2. CheckedException 已检查异常 </description>
			<content type="html"><![CDATA[<p>　　Exception是程序本身能够处理的异常，如：空指针异常(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。</p>
<p>　　Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为：</p>
<pre><code>  1. RuntimeException 运行时异常

  2. CheckedException 已检查异常</code></pre>
]]></content>
		</item>
		
		<item>
			<title>6.3.1 Error</title>
			<link>https://HarryQing.github.io/posts/6.3.1-error/</link>
			<pubDate>Wed, 10 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.3.1-error/</guid>
			<description>Error是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM(Java 虚拟机)出现的问题。例如，Java虚拟机运行错误(Virtual MachineError)，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。
　Error表明系统JVM已经处于不可恢复的崩溃状态中。我们不需要管它。
图6-3 java.lang包中Error的类
Error与Exception的区别 　1. 我开着车走在路上，一头猪冲在路中间，我刹车。这叫一个异常。
　2. 我开着车在路上，发动机坏了，我停车，这叫错误。系统处于不可恢复的崩溃状态。发动机什么时候坏?我们普通司机能管吗?不能。发动机什么时候坏是汽车厂发动机制造商的事。</description>
			<content type="html"><![CDATA[<p>　　Error是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM(Java 虚拟机)出现的问题。例如，Java虚拟机运行错误(Virtual MachineError)，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。</p>
<p>　　 Error表明系统JVM已经处于不可恢复的崩溃状态中。我们不需要管它。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495272264904706.png" alt="enter description here"></p>
<p>图6-3 java.lang包中Error的类</p>
<h2 id="error与exception的区别">Error与Exception的区别</h2>
<p>　　1. 我开着车走在路上，一头猪冲在路中间，我刹车。这叫一个异常。</p>
<p>　　2.  我开着车在路上，发动机坏了，我停车，这叫错误。系统处于不可恢复的崩溃状态。发动机什么时候坏?我们普通司机能管吗?不能。发动机什么时候坏是汽车厂发动机制造商的事。</p>
]]></content>
		</item>
		
		<item>
			<title>6.3 异常分类</title>
			<link>https://HarryQing.github.io/posts/6.3-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/</link>
			<pubDate>Tue, 09 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.3-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/</guid>
			<description>JDK 中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。
　Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。Java异常类的层次结构如图6-2所示。</description>
			<content type="html"><![CDATA[<p>　　JDK 中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。</p>
<p>　　Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。Java异常类的层次结构如图6-2所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495272017528669.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>6.2 异常(Exception)的概念</title>
			<link>https://HarryQing.github.io/posts/6.2-%E5%BC%82%E5%B8%B8exception%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
			<pubDate>Mon, 08 Mar 2021 22:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.2-%E5%BC%82%E5%B8%B8exception%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
			<description>异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需要处理的文件不存在、数组下标越界等。
　在Java的异常处理机制中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中包含了该类异常的信息和对异常进行处理的方法。
　所谓异常处理，就是指程序在出现问题时依然可以正确的执行完。
　我们开始看我们的第一个异常对象，并分析一下异常机制是如何工作的。
【示例6-2】 异常的分析
public class Test2 { public static void main(String[] args) { int i=1/0; //除数为0  System.out.println(i); } } Java是采用面向对象的方式来处理异常的。处理过程： 　1. 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。
　2. 捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。</description>
			<content type="html"><![CDATA[<p>　　异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需要处理的文件不存在、数组下标越界等。</p>
<p>　　在Java的异常处理机制中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中包含了该类异常的信息和对异常进行处理的方法。</p>
<p>　　所谓异常处理，就是指程序在出现问题时依然可以正确的执行完。</p>
<p>　　我们开始看我们的第一个异常对象，并分析一下异常机制是如何工作的。</p>
<p><strong>【示例6-2】</strong> 异常的分析</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">1</span><span class="o">/</span><span class="n">0</span><span class="o">;</span>  <span class="c1">//除数为0
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495271746282851.png" alt="enter description here"></p>
<h2 id="java是采用面向对象的方式来处理异常的处理过程">Java是采用面向对象的方式来处理异常的。处理过程：</h2>
<p>　　<strong>1. 抛出异常</strong>：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。</p>
<p>　　<strong>2.  捕获异常</strong>：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。</p>
]]></content>
		</item>
		
		<item>
			<title>6.1 导引问题</title>
			<link>https://HarryQing.github.io/posts/6.1-%E5%AF%BC%E5%BC%95%E9%97%AE%E9%A2%98/</link>
			<pubDate>Mon, 08 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/6.1-%E5%AF%BC%E5%BC%95%E9%97%AE%E9%A2%98/</guid>
			<description>　在实际工作中，我们遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求;你的程序要打开某个文件，这个文件可能不存在或者文件格式不对;你要读取数据库的数据，数据可能是空的;我们的程序再运行着，但是内存或硬盘可能满了等等。
　软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为异常，英文是：Exception，意思是例外。遇到这些例外情况，或者叫异常，我们怎么让写的程序做出合理的处理，安全的退出，而不至于程序崩溃呢?我们本章就要讲解这些问题。
　如果我们要拷贝一个文件，在没有异常机制的情况下，我们需要考虑各种异常情况，伪代码如下：
【示例6-1】 伪代码使用if处理程序中可能出现的各种情况
public class Test1 { public static void main(String[] args) { //将d:/a.txt复制到e:/a.txt  if(&amp;#34;d:/a.txt&amp;#34;这个文件存在){ if(e盘的空间大于a.txt文件长度){ if(文件复制一半IO流断掉){ 停止copy，输出：IO流出问题！ }else{ copyFile(&amp;#34;d:/a.txt&amp;#34;,&amp;#34;e:/a.txt&amp;#34;); } }else{ System.out.println(&amp;#34;e盘空间不够存放a.txt！&amp;#34;); } }else{ System.out.println(&amp;#34;a.txt不存在！&amp;#34;); } } } 这种方式，有两个坏处：  1. 逻辑代码和错误处理代码放一起!2. 程序员本身需要考虑的例外情况较复杂，对程序员本身要求较高! 　那么，我们如何解决应对异常情况呢?Java的异常机制给我们提供了方便的处理方式。如上情况，如果是用Java的异常机制来处理，示意代码如下(仅限示意，不能运行)：
try { copyFile(&amp;#34;d:/a.txt&amp;#34;,&amp;#34;e:/a.txt&amp;#34;); } catch (Exception e) { e.printStackTrace(); } 异常机制本质  就是当程序出现错误，程序安全退出的机制。 </description>
			<content type="html"><![CDATA[<p>　　在实际工作中，我们遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求;你的程序要打开某个文件，这个文件可能不存在或者文件格式不对;你要读取数据库的数据，数据可能是空的;我们的程序再运行着，但是内存或硬盘可能满了等等。</p>
<p>　　 软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为异常，英文是：Exception，意思是例外。遇到这些例外情况，或者叫异常，我们怎么让写的程序做出合理的处理，安全的退出，而不至于程序崩溃呢?我们本章就要讲解这些问题。</p>
<p>　　如果我们要拷贝一个文件，在没有异常机制的情况下，我们需要考虑各种异常情况，伪代码如下：</p>
<p><strong>【示例6-1】</strong> 伪代码使用if处理程序中可能出现的各种情况</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//将d:/a.txt复制到e:/a.txt
</span><span class="c1"></span>        <span class="k">if</span><span class="o">(</span><span class="s">&#34;d:/a.txt&#34;</span><span class="n">这个文件存在</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">e盘的空间大于a</span><span class="o">.</span><span class="na">txt文件长度</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">文件复制一半IO流断掉</span><span class="o">){</span>
                    <span class="n">停止copy</span><span class="err">，</span><span class="n">输出</span><span class="err">：</span><span class="n">IO流出问题</span><span class="err">！</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">copyFile</span><span class="o">(</span><span class="s">&#34;d:/a.txt&#34;</span><span class="o">,</span><span class="s">&#34;e:/a.txt&#34;</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;e盘空间不够存放a.txt！&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;a.txt不存在！&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="这种方式有两个坏处">这种方式，有两个坏处：</h2>
<pre><code>  1. 逻辑代码和错误处理代码放一起!

  2. 程序员本身需要考虑的例外情况较复杂，对程序员本身要求较高!
</code></pre>
<p>　　那么，我们如何解决应对异常情况呢?Java的异常机制给我们提供了方便的处理方式。如上情况，如果是用Java的异常机制来处理，示意代码如下(仅限示意，不能运行)：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">try</span> <span class="o">{</span>
    <span class="n">copyFile</span><span class="o">(</span><span class="s">&#34;d:/a.txt&#34;</span><span class="o">,</span><span class="s">&#34;e:/a.txt&#34;</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><h2 id="异常机制本质">异常机制本质</h2>
<pre><code>  就是当程序出现错误，程序安全退出的机制。</code></pre>
]]></content>
		</item>
		
		<item>
			<title>第六章 异常机制</title>
			<link>https://HarryQing.github.io/posts/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sun, 07 Mar 2021 23:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</guid>
			<description>目录 6.1 导引问题 6.2 异常(Exception)的概念 6.3 异常分类 6.3.1 Error 6.3.2 Exception 6.3.3 RuntimeException运行时异常 6.3.4 CheckedException已检查异常 6.4 异常的处理方式之一：捕获异常 6.5 异常的处理方式之二：声明异常(throws子句) 6.6 自定义异常 6.7 如何利用百度解决异常问题 </description>
			<content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="61-导引问题">6.1 导引问题</h2>
<h2 id="62-异常exception的概念">6.2 异常(Exception)的概念</h2>
<h2 id="63-异常分类">6.3 异常分类</h2>
<h2 id="631-error">6.3.1 Error</h2>
<h2 id="632-exception">6.3.2 Exception</h2>
<h2 id="633-runtimeexception运行时异常">6.3.3 RuntimeException运行时异常</h2>
<h2 id="634-checkedexception已检查异常">6.3.4 CheckedException已检查异常</h2>
<h2 id="64-异常的处理方式之一捕获异常">6.4 异常的处理方式之一：捕获异常</h2>
<h2 id="65-异常的处理方式之二声明异常throws子句">6.5 异常的处理方式之二：声明异常(throws子句)</h2>
<h2 id="66-自定义异常">6.6 自定义异常</h2>
<h2 id="67-如何利用百度解决异常问题">6.7 如何利用百度解决异常问题</h2>
<p><img src="data:image/jpeg;base64,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" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.12.3 组合模式</title>
			<link>https://HarryQing.github.io/posts/5.12.3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
			<pubDate>Sun, 07 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.12.3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
			<description>组合模式是将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
【示例5-34】 对象的组合
class Cpu { public void run() { System.out.println(&amp;#34;quickly.........&amp;#34;); } } class MainBoard { public void connect() { System.out.println(&amp;#34;connect...........&amp;#34;); } } class Memory { public void store() { System.out.println(&amp;#34;store........&amp;#34;); } } public class Computer { Cpu cpu; Memory memory; MainBoard mainBoard; public void work() { cpu.run(); memory.store(); mainBoard.connect(); } public static void main(String[] args) { Computer computer = new Computer(); computer.cpu = new Cpu(); computer.mainBoard = new MainBoard(); computer.</description>
			<content type="html"><![CDATA[<p>　　组合模式是将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>【示例5-34】</strong> 对象的组合</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Cpu</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;quickly.........&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MainBoard</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">connect</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;connect...........&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Memory</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">store</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;store........&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Computer</span> <span class="o">{</span>
	<span class="n">Cpu</span> <span class="n">cpu</span><span class="o">;</span>
	<span class="n">Memory</span> <span class="n">memory</span><span class="o">;</span>
	<span class="n">MainBoard</span> <span class="n">mainBoard</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">cpu</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
		<span class="n">memory</span><span class="o">.</span><span class="na">store</span><span class="o">();</span>
		<span class="n">mainBoard</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Computer</span> <span class="n">computer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Computer</span><span class="o">();</span>
		<span class="n">computer</span><span class="o">.</span><span class="na">cpu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu</span><span class="o">();</span>
		<span class="n">computer</span><span class="o">.</span><span class="na">mainBoard</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MainBoard</span><span class="o">();</span>
		<span class="n">computer</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Memory</span><span class="o">();</span>
		<span class="n">computer</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-36所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495269438396479.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.12.2 模板方法模式和回调机制</title>
			<link>https://HarryQing.github.io/posts/5.12.2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 06 Mar 2021 12:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.12.2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</guid>
			<description>模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。 详见抽象类部分示例。
　其实在Java开发中，还有另外一个方法可以实现同样的功能，那就是Java回调技术。回调是一种双向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口，简单点说明就是：A类中调用B类中的C方法，然后B类中的C方法中反过来调用A类中的D方法，那么D这个方法就叫回调方法。
回调的具体过程如下：  1. Class A实现接口CallBack —— 背景12. class A中包含class B的引用 ——背景23. class B有一个参数为CallBack的方法C ——背景34. 前三条是我们的准备条件，接下来A的对象调用B的方法C5. 然后class B就可以在C方法中调用A的方法D 　这样说大家可能还是不太理解，下面我们根据示例5-33来说明回调机制。该示例的生活背景为：有一天小刘遇到一个很难的问题“学习Java选哪家机构呢?”，于是就打电话问小高，小高一时也不太了解行情，就跟小刘说，我现在还有事，等忙完了给你咨询咨询，小刘也不会傻傻的拿着电话去等小高的答案，于是小刘对小高说，先挂电话吧，你知道答案后再打我电话告诉我吧，于是挂了电话。小高先去办自己的事情去了，过了几个小时，小高打电话给小刘，告诉他答案是“学Java当然去北京尚学堂”。
【示例5-33】 回调机制示例
/** * 回调接口 */ interface CallBack { /** * 小高知道答案后告诉小刘时需要调用的方法，即回调方法 * @param result 是问题的答案 */ public void answer(String result); } /** * 小刘类：实现了回调接口CallBack（背景一） */ class Liu implements CallBack { /** * 包含小高对象的引用 （背景二） */ private Gao gao; public Liu(Gao gao){ this.</description>
			<content type="html"><![CDATA[<p>　　模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。 详见抽象类部分示例。</p>
<p>　　其实在Java开发中，还有另外一个方法可以实现同样的功能，那就是Java回调技术。回调是一种双向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口，简单点说明就是：A类中调用B类中的C方法，然后B类中的C方法中反过来调用A类中的D方法，那么D这个方法就叫回调方法。</p>
<h2 id="回调的具体过程如下">回调的具体过程如下：</h2>
<pre><code>  1. Class A实现接口CallBack —— 背景1

  2. class A中包含class B的引用 ——背景2

  3. class B有一个参数为CallBack的方法C ——背景3

  4. 前三条是我们的准备条件，接下来A的对象调用B的方法C

  5. 然后class B就可以在C方法中调用A的方法D
</code></pre>
<p>　　这样说大家可能还是不太理解，下面我们根据示例5-33来说明回调机制。该示例的生活背景为：有一天小刘遇到一个很难的问题“学习Java选哪家机构呢?”，于是就打电话问小高，小高一时也不太了解行情，就跟小刘说，我现在还有事，等忙完了给你咨询咨询，小刘也不会傻傻的拿着电话去等小高的答案，于是小刘对小高说，先挂电话吧，你知道答案后再打我电话告诉我吧，于是挂了电话。小高先去办自己的事情去了，过了几个小时，小高打电话给小刘，告诉他答案是“学Java当然去北京尚学堂”。</p>
<p><strong>【示例5-33】</strong> 回调机制示例</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/** 
</span><span class="cm"> * 回调接口  
</span><span class="cm"> */</span>
<span class="kd">interface</span> <span class="nc">CallBack</span> <span class="o">{</span>  
	<span class="cm">/** 
</span><span class="cm">	 * 小高知道答案后告诉小刘时需要调用的方法，即回调方法
</span><span class="cm">	 * @param result 是问题的答案 
</span><span class="cm">	 */</span>  
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">answer</span><span class="o">(</span><span class="n">String</span> <span class="n">result</span><span class="o">);</span>  
<span class="o">}</span>
<span class="cm">/** 
</span><span class="cm"> * 小刘类：实现了回调接口CallBack（背景一） 
</span><span class="cm"> */</span>  
<span class="kd">class</span> <span class="nc">Liu</span> <span class="kd">implements</span> <span class="n">CallBack</span> <span class="o">{</span>  
	<span class="cm">/** 
</span><span class="cm">	 * 包含小高对象的引用 （背景二） 
</span><span class="cm">	 */</span>  
	<span class="kd">private</span> <span class="n">Gao</span> <span class="n">gao</span><span class="o">;</span>   

	<span class="kd">public</span> <span class="nf">Liu</span><span class="o">(</span><span class="n">Gao</span> <span class="n">gao</span><span class="o">){</span>  
		<span class="k">this</span><span class="o">.</span><span class="na">gao</span> <span class="o">=</span> <span class="n">gao</span><span class="o">;</span>  
	<span class="o">}</span>  

	<span class="cm">/** 
</span><span class="cm">	 * 小刘通过这个方法去问小高 
</span><span class="cm">	 * @param question  小刘问的问题“学习Java选哪家机构呢？” 
</span><span class="cm">	 */</span>  
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">askQuestion</span><span class="o">(</span><span class="n">String</span> <span class="n">question</span><span class="o">){</span>  
		<span class="c1">//小刘问小高问题
</span><span class="c1"></span>		<span class="n">gao</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">Liu</span><span class="o">.</span><span class="na">this</span><span class="o">,</span> <span class="n">question</span><span class="o">);</span>          
	<span class="o">}</span>  
	<span class="cm">/** 
</span><span class="cm">	 * 小高知道答案后调用此方法告诉小刘
</span><span class="cm">	 */</span>  
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">answer</span><span class="o">(</span><span class="n">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;小高告诉小刘的答案是：&#34;</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>        
	<span class="o">}</span>  
<span class="o">}</span> 
<span class="cm">/** 
</span><span class="cm"> * 小高类 
</span><span class="cm"> */</span>  
<span class="kd">class</span> <span class="nc">Gao</span> <span class="o">{</span>
	 <span class="cm">/** 
</span><span class="cm">	 * 相当于class B有一个参数为CallBack的方法C（背景三） 
</span><span class="cm">	 */</span>  
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">CallBack</span> <span class="n">callBack</span><span class="o">,</span> <span class="n">String</span> <span class="n">question</span><span class="o">){</span>  
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;小刘问的问题是：&#34;</span> <span class="o">+</span> <span class="n">question</span><span class="o">);</span>  
		<span class="c1">//模拟小高挂点后先办自己的事情花了很长时间  
</span><span class="c1"></span>		<span class="k">try</span> <span class="o">{</span>
			<span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">10000</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="c1">//小高办完自己的事情后想到了答案 
</span><span class="c1"></span>		<span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">&#34;当然是雪儿呀！&#34;</span><span class="o">;</span>  
		<span class="c1">//小高打电话把答案告诉小刘，相当于class B 反过来调用class A 的D方法 
</span><span class="c1"></span>		<span class="n">callBack</span><span class="o">.</span><span class="na">answer</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>         
	<span class="o">}</span>  
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Gao</span>  <span class="n">gao</span><span class="o">=</span> <span class="k">new</span> <span class="n">Gao</span><span class="o">();</span>  
		<span class="n">Liu</span> <span class="n">liu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Liu</span><span class="o">(</span><span class="n">gao</span><span class="o">);</span>  
		<span class="c1">//小刘问问题
</span><span class="c1"></span>		<span class="n">liu</span><span class="o">.</span><span class="na">askQuestion</span><span class="o">(</span><span class="s">&#34;雪庆的对象谁呀？&#34;</span><span class="o">);</span> 
	<span class="o">}</span> 
<span class="o">}</span>
</code></pre></div><p>　　通过回调在接口中定义的方法，调用到具体的实现类中的方法，其本质是利用Java的动态绑定技术，在这种实现中，可以不把实现类写成单独的类，而使用内部类或匿名内部类来实现回调方法。</p>
]]></content>
		</item>
		
		<item>
			<title>5.12.1 开闭原则</title>
			<link>https://HarryQing.github.io/posts/5.12.1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
			<pubDate>Sat, 06 Mar 2021 10:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.12.1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
			<description>开闭原则(Open-Closed Principle)就是让设计的系统对扩展开放，对修改封闭。
· 对扩展开放： 　就是指，应对需求变化要灵活。 要增加新功能时，不需要修改已有的代码，增加新代码即可。
· 对修改关闭： 　就是指，核心部分经过精心设计后，不再因为需求变化而改变。
　在实际开发中，我们无法完全做到，但应尽量遵守开闭原则。</description>
			<content type="html"><![CDATA[<p>　　开闭原则(Open-Closed Principle)就是让设计的系统对扩展开放，对修改封闭。</p>
<h2 id="-对扩展开放">· 对扩展开放：</h2>
<p>　　就是指，应对需求变化要灵活。 要增加新功能时，不需要修改已有的代码，增加新代码即可。</p>
<h2 id="-对修改关闭">· 对修改关闭：</h2>
<p>　　就是指，核心部分经过精心设计后，不再因为需求变化而改变。</p>
<p>　　在实际开发中，我们无法完全做到，但应尽量遵守开闭原则。</p>
]]></content>
		</item>
		
		<item>
			<title>5.11.5 字符串相等的判断</title>
			<link>https://HarryQing.github.io/posts/5.11.5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD/</link>
			<pubDate>Sat, 06 Mar 2021 08:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.11.5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD/</guid>
			<description>1. equals方法用来检测两个字符串内容是否相等。如果字符串s和t内容相等，则s.equals(t)返回true，否则返回false。
　2. 要测试两个字符串除了大小写区别外是否是相等的，需要使用equalsIgnoreCase方法。
　3. 判断字符串是否相等不要使用&amp;quot;==&amp;quot;。
【示例5-31】 忽略大小写的字符串比较
&amp;#34;Hello&amp;#34;.equalsIgnoreCase(&amp;#34;hellO&amp;#34;);//true 【示例5-32】 字符串的比较&amp;quot;==&amp;ldquo;与equals()方法
public class TestStringEquals { public static void main(String[] args) { String g1 = &amp;#34;大爱雪儿&amp;#34;; String g2 = &amp;#34;大爱雪儿&amp;#34;; String g3 = new String(&amp;#34;大爱雪儿&amp;#34;); System.out.println(g1 == g2); // true 指向同样的字符串常量对象 	System.out.println(g1 == g3); // false g3是新创建的对象 	System.out.println(g1.equals(g3)); // true g1和g3里面的字符串内容是一样的 	} } 执行结果如图5-33所示：
图5-33 示例5-32运行效果图</description>
			<content type="html"><![CDATA[<p>　　1. equals方法用来检测两个字符串内容是否相等。如果字符串s和t内容相等，则s.equals(t)返回true，否则返回false。</p>
<p>　　2. 要测试两个字符串除了大小写区别外是否是相等的，需要使用equalsIgnoreCase方法。</p>
<p>　　3. 判断字符串是否相等不要使用&quot;==&quot;。</p>
<p><strong>【示例5-31】</strong> 忽略大小写的字符串比较</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="s">&#34;Hello&#34;</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">&#34;hellO&#34;</span><span class="o">);</span><span class="c1">//true
</span></code></pre></div><p><strong>【示例5-32】</strong> 字符串的比较&quot;==&ldquo;与equals()方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestStringEquals</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">String</span> <span class="n">g1</span> <span class="o">=</span> <span class="s">&#34;大爱雪儿&#34;</span><span class="o">;</span>
		<span class="n">String</span> <span class="n">g2</span> <span class="o">=</span> <span class="s">&#34;大爱雪儿&#34;</span><span class="o">;</span>
		<span class="n">String</span> <span class="n">g3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;大爱雪儿&#34;</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g1</span> <span class="o">==</span> <span class="n">g2</span><span class="o">);</span> <span class="c1">// true  指向同样的字符串常量对象
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g1</span> <span class="o">==</span> <span class="n">g3</span><span class="o">);</span> <span class="c1">// false  g3是新创建的对象
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">g3</span><span class="o">));</span> <span class="c1">// true  g1和g3里面的字符串内容是一样的
</span><span class="c1"></span>	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-33所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495268338419387.png" alt="enter description here"></p>
<p>图5-33 示例5-32运行效果图</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495268347551446.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.11.4 String类常用的方法</title>
			<link>https://HarryQing.github.io/posts/5.11.4-string%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</link>
			<pubDate>Fri, 05 Mar 2021 21:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.11.4-string%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
			<description>String类是我们最常使用的类。字符串类的方法我们必须非常熟悉!我们列出常用的方法，请大家熟悉。
【示例5-29】 String类常用方法一
public class StringTest1 { public static void main(String[] args) { String s1 = &amp;#34;core Java&amp;#34;; String s2 = &amp;#34;Core Java&amp;#34;; System.out.println(s1.charAt(3));//提取下标为3的字符 	System.out.println(s2.length());//字符串的长度 	System.out.println(s1.equals(s2));//比较两个字符串是否相等 	System.out.println(s1.equalsIgnoreCase(s2));//比较两个字符串（忽略大小写） 	System.out.println(s1.indexOf(&amp;#34;Java&amp;#34;));//字符串s1中是否包含Java 	System.out.println(s1.indexOf(&amp;#34;apple&amp;#34;));//字符串s1中是否包含apple 	String s = s1.replace(&amp;#39; &amp;#39;, &amp;#39;&amp;amp;&amp;#39;);//将s1中的空格替换成&amp;amp; 	System.out.println(&amp;#34;result is :&amp;#34; + s); } } 执行结果如图5-31所示：
【示例5-30】 String类常用方法二
public class StringTest2 { public static void main(String[] args) { String s = &amp;#34;&amp;#34;; String s1 = &amp;#34;How are you?</description>
			<content type="html"><![CDATA[<p>　　String类是我们最常使用的类。字符串类的方法我们必须非常熟悉!我们列出常用的方法，请大家熟悉。</p>
<p><img src="https://i.loli.net/2021/03/16/VvoiJlw8nDhZ26d.png" alt="image.png"></p>
<p><strong>【示例5-29】</strong> String类常用方法一</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringTest1</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;core Java&#34;</span><span class="o">;</span>
		<span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;Core Java&#34;</span><span class="o">;</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">3</span><span class="o">));</span><span class="c1">//提取下标为3的字符
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">());</span><span class="c1">//字符串的长度
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span><span class="c1">//比较两个字符串是否相等
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span><span class="c1">//比较两个字符串（忽略大小写）
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">&#34;Java&#34;</span><span class="o">));</span><span class="c1">//字符串s1中是否包含Java
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">&#34;apple&#34;</span><span class="o">));</span><span class="c1">//字符串s1中是否包含apple
</span><span class="c1"></span>		<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="sc">&#39;&amp;&#39;</span><span class="o">);</span><span class="c1">//将s1中的空格替换成&amp;
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;result is :&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-31所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495267731684048.png" alt="enter description here"></p>
<p><strong>【示例5-30】</strong> String类常用方法二</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringTest2</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
		<span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;How are you?&#34;</span><span class="o">;</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&#34;How&#34;</span><span class="o">));</span><span class="c1">//是否以How开头
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&#34;you&#34;</span><span class="o">));</span><span class="c1">//是否以you结尾
</span><span class="c1"></span>		<span class="n">s</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">4</span><span class="o">);</span><span class="c1">//提取子字符串：从下标为4的开始到字符串结尾为止
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">4</span><span class="o">,</span> <span class="n">7</span><span class="o">);</span><span class="c1">//提取子字符串：下标[4, 7) 不包括7
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">();</span><span class="c1">//转小写
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">();</span><span class="c1">//转大写
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
		<span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;  How old are you!! &#34;</span><span class="o">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">trim</span><span class="o">();</span><span class="c1">//去除字符串首尾的空格。注意：中间的空格不能去除
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//因为String是不可变字符串，所以s2不变
</span><span class="c1"></span>	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-32所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495267792980384.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.11.3阅读API文档</title>
			<link>https://HarryQing.github.io/posts/5.11.3%E9%98%85%E8%AF%BBapi%E6%96%87%E6%A1%A3/</link>
			<pubDate>Fri, 05 Mar 2021 20:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.11.3%E9%98%85%E8%AF%BBapi%E6%96%87%E6%A1%A3/</guid>
			<description>· 如何下载API文档 　1. 下载地址，点击进入： http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html
图5-27 API下载界面图
　2. 下载成功后，解压下载的压缩文件，点击进入docs/api下的index.html文件即可。
图5-28 打开index.html文件
·API文档如何阅读 图5-29 API文档
· eclipse中将鼠标放到类或方法上，即可看到相关的注释说明;再按下F2即可将注释窗口固定。 图5-30 eclipse中的注释说明图</description>
			<content type="html"><![CDATA[<h2 id="-如何下载api文档">· 如何下载API文档</h2>
<p>　　1. 下载地址，点击进入：
　　 <a href="http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html">http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html</a></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495264906753471.png" alt="enter description here"></p>
<p>图5-27 API下载界面图</p>
<p>　　2. 下载成功后，解压下载的压缩文件，点击进入docs/api下的index.html文件即可。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495264915647697.png" alt="enter description here"></p>
<p>图5-28 打开index.html文件</p>
<h2 id="api文档如何阅读">·API文档如何阅读</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495264926513372.png" alt="enter description here"></p>
<p>图5-29 API文档</p>
<h2 id="-eclipse中将鼠标放到类或方法上即可看到相关的注释说明再按下f2即可将注释窗口固定">· eclipse中将鼠标放到类或方法上，即可看到相关的注释说明;再按下F2即可将注释窗口固定。</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495264935546946.png" alt="enter description here"></p>
<p>图5-30 eclipse中的注释说明图</p>
]]></content>
		</item>
		
		<item>
			<title>5.11.2 String类和常量池</title>
			<link>https://HarryQing.github.io/posts/5.11.2-string%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
			<pubDate>Fri, 05 Mar 2021 19:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.11.2-string%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
			<description>在Java的内存分析中，我们会经常听到关于“常量池”的描述，实际上常量池也分了以下三种：
1. 全局字符串常量池(String Pool) 　全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值(在堆中生成字符串对象实例)。
2. class文件常量池(Class Constant Pool) 　class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量(文本字符串、final常量等)和符号引用。
3. 运行时常量池(Runtime Constant Pool) 　运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。
【示例5-28】 常量池
String str1 = &amp;#34;abc&amp;#34;; String str2 = new String(&amp;#34;def&amp;#34;); String str3 = &amp;#34;abc&amp;#34;; String str4 = str2.intern(); String str5 = &amp;#34;def&amp;#34;; System.out.println(str1 == str3);// true System.out.println(str2 == str4);// false System.out.println(str4 == str5);// true 　示例5-28的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象(也就是上例中str1所指向的“abc”实例对象)，然后将这个对象的引用存到全局String Pool中，也就是String Pool中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询String Pool，保证String Pool里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。
　回到示例5-28的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个“abc”实例，全局String Pool中存放着“abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是“def”的实例对象，并且String Pool中存储一个“def”的引用值，还有一个是new出来的一个“def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找String Pool，里面有“abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回String Pool中“def”的引用值，如果没有就将str2的引用值添加进去，在这里，String Pool中已经有了“def”的引用值了，所以返回上面在new str2的时候添加到String Pool中的 “def”引用值，最后str5在解析的时候就也是指向存在于String Pool中的“def”的引用值，那么这样一分析之后，结果就容易理解了。</description>
			<content type="html"><![CDATA[<p>　　在Java的内存分析中，我们会经常听到关于“常量池”的描述，实际上常量池也分了以下三种：</p>
<h2 id="1-全局字符串常量池string-pool">1. 全局字符串常量池(String Pool)</h2>
<p>　　全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值(在堆中生成字符串对象实例)。</p>
<h2 id="2-class文件常量池class-constant-pool">2. class文件常量池(Class Constant Pool)</h2>
<p>　　class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量(文本字符串、final常量等)和符号引用。</p>
<h2 id="3-运行时常量池runtime-constant-pool">3. 运行时常量池(Runtime Constant Pool)</h2>
<p>　　运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</p>
<p><strong>【示例5-28】</strong> 常量池</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="o">;</span>
<span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;def&#34;</span><span class="o">);</span>
<span class="n">String</span> <span class="n">str3</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="o">;</span>
<span class="n">String</span> <span class="n">str4</span> <span class="o">=</span> <span class="n">str2</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
<span class="n">String</span> <span class="n">str5</span> <span class="o">=</span> <span class="s">&#34;def&#34;</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="n">str3</span><span class="o">);</span><span class="c1">// true
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span> <span class="o">==</span> <span class="n">str4</span><span class="o">);</span><span class="c1">// false
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str4</span> <span class="o">==</span> <span class="n">str5</span><span class="o">);</span><span class="c1">// true
</span></code></pre></div><p>　　示例5-28的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象(也就是上例中str1所指向的“abc”实例对象)，然后将这个对象的引用存到全局String Pool中，也就是String Pool中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询String Pool，保证String Pool里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p>
<p>　　回到示例5-28的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个“abc”实例，全局String Pool中存放着“abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是“def”的实例对象，并且String Pool中存储一个“def”的引用值，还有一个是new出来的一个“def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找String Pool，里面有“abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回String Pool中“def”的引用值，如果没有就将str2的引用值添加进去，在这里，String Pool中已经有了“def”的引用值了，所以返回上面在new str2的时候添加到String Pool中的 “def”引用值，最后str5在解析的时候就也是指向存在于String Pool中的“def”的引用值，那么这样一分析之后，结果就容易理解了。</p>
]]></content>
		</item>
		
		<item>
			<title>5.11.1 String基础</title>
			<link>https://HarryQing.github.io/posts/5.11.1-string%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Fri, 05 Mar 2021 17:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.11.1-string%E5%9F%BA%E7%A1%80/</guid>
			<description>1. String类又称作不可变字符序列。
　2. String位于java.lang包中，Java程序默认导入java.lang包下的所有类。
　3. Java字符串就是Unicode字符序列，例如字符串“Java”就是4个Unicode字符’J’、’a’、’v’、’a’组成的。
　4. Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。
【示例5-25】 String类的实例
String e = &amp;#34;&amp;#34; ; // 空字符串 String greeting = &amp;#34; Hello World &amp;#34;; 　5. Java允许使用符号&amp;quot;+&amp;ldquo;把两个字符串连接起来。
【示例5-26】 字符串连接
String s1 = &amp;#34;Hello&amp;#34;; String s2 = &amp;#34;World! &amp;#34;; String s = s1 + s2; //HelloWorld! 　n-符号&amp;rdquo;+&amp;ldquo;把两个字符串按给定的顺序连接在一起，并且是完全按照给定的形式。
　n-当&amp;rdquo;+&amp;ldquo;运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。
【示例5-27】 &amp;ldquo;+&amp;ldquo;连接符
int age = 18; String str = &amp;#34;age is&amp;#34; + age; //str赋值为&amp;#34;age is 18&amp;#34; //这种特性通常被用在输出语句中： System.</description>
			<content type="html"><![CDATA[<p>　　1. String类又称作不可变字符序列。</p>
<p>　　2. String位于java.lang包中，Java程序默认导入java.lang包下的所有类。</p>
<p>　　3. Java字符串就是Unicode字符序列，例如字符串“Java”就是4个Unicode字符’J’、’a’、’v’、’a’组成的。</p>
<p>　　4.  Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。</p>
<p><strong>【示例5-25】</strong> String类的实例</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">e</span> <span class="o">=</span> <span class="s">&#34;&#34;</span>  <span class="o">;</span> <span class="c1">// 空字符串
</span><span class="c1"></span><span class="n">String</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&#34; Hello World &#34;</span><span class="o">;</span>
</code></pre></div><p>　　5. Java允许使用符号&quot;+&ldquo;把两个字符串连接起来。</p>
<p><strong>【示例5-26】</strong> 字符串连接</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="o">;</span>
<span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;World! &#34;</span><span class="o">;</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="o">;</span> <span class="c1">//HelloWorld!
</span></code></pre></div><p>　　n-符号&rdquo;+&ldquo;把两个字符串按给定的顺序连接在一起，并且是完全按照给定的形式。</p>
<p>　　n-当&rdquo;+&ldquo;运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。</p>
<p><strong>【示例5-27】</strong> &ldquo;+&ldquo;连接符</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">18</span><span class="o">;</span>
<span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;age is&#34;</span> <span class="o">+</span> <span class="n">age</span><span class="o">;</span>  <span class="c1">//str赋值为&#34;age is 18&#34;
</span><span class="c1">//这种特性通常被用在输出语句中：
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;age  is&#34;</span> <span class="o">+</span> <span class="n">age</span><span class="o">);</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>5.10.2内部类的分类</title>
			<link>https://HarryQing.github.io/posts/5.10.2%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB/</link>
			<pubDate>Fri, 05 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.10.2%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB/</guid>
			<description>在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。
.成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class) a) 非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同) 　i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。
　ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。
　iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。
　iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。
　v. 成员变量访问要点：
 1. 内部类里方法的局部变量：变量名。2. 内部类属性：this.变量名。3. 外部类属性：外部类名.this.变量名。 【示例5-20】 成员变量的访问要点
class Outer { private int age = 10; class Inner { int age = 20; public void show() { int age = 30; System.out.println(&amp;#34;内部类方法里的局部变量age:&amp;#34; + age);// 30 	System.out.println(&amp;#34;内部类的成员变量age:&amp;#34; + this.age);// 20 	System.out.println(&amp;#34;外部类的成员变量age:&amp;#34; + Outer.this.age);// 10 	} } } 　vi.</description>
			<content type="html"><![CDATA[<p>　　在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。</p>
<h2 id="成员内部类可以使用privatedefaultprotectedpublic任意进行修饰-类文件外部类内部类class">.成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class)</h2>
<h3 id="a-非静态内部类外部类里使用非静态内部类和平时使用其他类没什么不同">a) 非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同)</h3>
<p>　　i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。</p>
<p>　　ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。</p>
<p>　　iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。</p>
<p>　　iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。</p>
<p>　　v. 成员变量访问要点：</p>
<pre><code>    1. 内部类里方法的局部变量：变量名。

    2. 内部类属性：this.变量名。

    3. 外部类属性：外部类名.this.变量名。
</code></pre>
<p><strong>【示例5-20】</strong> 成员变量的访问要点</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Outer</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>
	<span class="kd">class</span> <span class="nc">Inner</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">20</span><span class="o">;</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">30</span><span class="o">;</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;内部类方法里的局部变量age:&#34;</span> <span class="o">+</span> <span class="n">age</span><span class="o">);</span><span class="c1">// 30
</span><span class="c1"></span>			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;内部类的成员变量age:&#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span><span class="c1">// 20
</span><span class="c1"></span>			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;外部类的成员变量age:&#34;</span> <span class="o">+</span> <span class="n">Outer</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span><span class="c1">// 10
</span><span class="c1"></span>		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　vi. 内部类的访问：</p>
<ol>
<li>
<p>外部类中定义内部类：</p>
<p>new Inner()</p>
</li>
<li>
<p>外部类以外的地方使用非静态内部类：</p>
<p>Outer.Inner  varname = new Outer().new Inner()。</p>
</li>
</ol>
<p><strong>【示例5-21】</strong> 内部类的访问</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestInnerClass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//先创建外部类实例，然后使用该外部类实例创建内部类实例
</span><span class="c1"></span>		<span class="n">Outer</span><span class="o">.</span><span class="na">Inner</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Outer</span><span class="o">().</span><span class="na">new</span> <span class="n">Inner</span><span class="o">();</span>
		<span class="n">inner</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
		<span class="n">Outer</span> <span class="n">outer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Outer</span><span class="o">();</span>
		<span class="n">Outer</span><span class="o">.</span><span class="na">Inner</span> <span class="n">inn</span> <span class="o">=</span> <span class="n">outer</span><span class="o">.</span><span class="na">new</span> <span class="nf">Inner</span><span class="o">();</span>
		<span class="n">inn</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-25所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495262283489060.png" alt="enter description here"></p>
<h3 id="b-静态内部类">b) 静态内部类</h3>
<p>　　i. 定义方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span>  <span class="kd">class</span>   <span class="nc">ClassName</span> <span class="o">{</span>
<span class="c1">//类体
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>　　ii. 使用要点：</p>
<ol>
<li>
<p>当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。</p>
</li>
<li>
<p>静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。</p>
</li>
</ol>
<p><strong>【示例5-22】</strong> 静态内部类的访问</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Outer</span><span class="o">{</span>
	<span class="c1">//相当于外部类的一个静态成员
</span><span class="c1"></span>	<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Inner</span><span class="o">{</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestStaticInnerClass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//通过 new 外部类名.内部类名() 来创建内部类对象
</span><span class="c1"></span>		<span class="n">Outer</span><span class="o">.</span><span class="na">Inner</span> <span class="n">inner</span> <span class="o">=</span><span class="k">new</span> <span class="n">Outer</span><span class="o">.</span><span class="na">Inner</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="-匿名内部类">. 匿名内部类</h2>
<p>　　适合那种只需要使用一次的类。比如：键盘监听操作等等。</p>
<h2 id="语法">语法：</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">new</span>  <span class="n">父类构造器</span><span class="o">(</span><span class="n">实参类表</span><span class="o">)</span> <span class="err">\</span><span class="n">实现接口</span> <span class="o">()</span> <span class="o">{</span>
		   <span class="c1">//匿名内部类类体！
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p><strong>【示例5-23】</strong> 匿名内部类的使用</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">this</span><span class="o">.</span><span class="na">addWindowListener</span><span class="o">(</span><span class="k">new</span> <span class="n">WindowAdapter</span><span class="o">(){</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">windowClosing</span><span class="o">(</span><span class="n">WindowEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">);</span>
<span class="k">this</span><span class="o">.</span><span class="na">addKeyListener</span><span class="o">(</span><span class="k">new</span> <span class="n">KeyAdapter</span><span class="o">(){</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">myTank</span><span class="o">.</span><span class="na">keyPressed</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
		<span class="o">}</span>      
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyReleased</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">myTank</span><span class="o">.</span><span class="na">keyReleased</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">);</span>
</code></pre></div><h2 id="注意">注意</h2>
<p>　　1. 匿名内部类没有访问修饰符。</p>
<p>　　2. 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。</p>
<h2 id="局部内部类">.局部内部类</h2>
<p>　　还有一种内部类，它是定义在方法内部的，作用域只限于本方法，称为局部内部类。</p>
<p>　　局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。</p>
<p>　　局部内部类在实际开发中应用很少。</p>
<p><strong>【示例5-24】</strong> 方法中的内部类</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//作用域仅限于该方法
</span><span class="c1"></span>		<span class="kd">class</span> <span class="nc">Inner</span> <span class="o">{</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">fun</span><span class="o">()</span> <span class="o">{</span>
				<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;helloworld&#34;</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">new</span> <span class="n">Inner</span><span class="o">().</span><span class="na">fun</span><span class="o">();</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">new</span> <span class="n">Test2</span><span class="o">().</span><span class="na">show</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-26所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495262685367524.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.10.1内部类的概念</title>
			<link>https://HarryQing.github.io/posts/5.10.1%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
			<pubDate>Fri, 05 Mar 2021 14:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.10.1%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
			<description>一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。
　内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。
注意 　内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。
【示例5-19】 内部类介绍
/**外部类Outer*/ class Outer { private int age = 10; public void show(){ System.out.println(age);//10 	} /**内部类Inner*/ public class Inner { //内部类中可以声明与外部类同名的属性与方法 	private int age = 20; public void show(){ System.out.println(age);//20 	} } } 　示例5-19编译后会产生两个不同的字节码文件，如图5-24所示：
图5-24 内部类编译结果图
内部类的作用： 　1. 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。
　2. 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。
　3. 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。
内部类的使用场合： 　1. 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。
　2. 使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。</description>
			<content type="html"><![CDATA[<p>　　一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。</p>
<p>　　内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。</p>
<h2 id="注意">注意</h2>
<p>　　内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。</p>
<p><strong>【示例5-19】</strong> 内部类介绍</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**外部类Outer*/</span>
<span class="kd">class</span> <span class="nc">Outer</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(){</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">age</span><span class="o">);</span><span class="c1">//10
</span><span class="c1"></span>	<span class="o">}</span>
	<span class="cm">/**内部类Inner*/</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Inner</span> <span class="o">{</span>
		<span class="c1">//内部类中可以声明与外部类同名的属性与方法
</span><span class="c1"></span>		<span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">20</span><span class="o">;</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(){</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">age</span><span class="o">);</span><span class="c1">//20
</span><span class="c1"></span>		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　示例5-19编译后会产生两个不同的字节码文件，如图5-24所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495261579765732.png" alt="enter description here"></p>
<p>图5-24 内部类编译结果图</p>
<h2 id="内部类的作用">内部类的作用：</h2>
<p>　　1. 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。</p>
<p>　　2. 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。</p>
<p>　　3. 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>
<h2 id="内部类的使用场合">内部类的使用场合：</h2>
<p>　　1. 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。</p>
<p>　　2.  使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。</p>
]]></content>
		</item>
		
		<item>
			<title>5.9.4 面向接口编程</title>
			<link>https://HarryQing.github.io/posts/5.9.4-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</link>
			<pubDate>Fri, 05 Mar 2021 12:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.9.4-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</guid>
			<description>面向接口编程是面向对象编程的一部分。
　为什么需要面向接口编程? 软件设计中最难处理的就是需求的复杂变化，需求的变化更多的体现在具体实现上。我们的编程如果围绕具体实现来展开就会陷入”复杂变化”的汪洋大海中，软件也就不能最终实现。我们必须围绕某种稳定的东西开展，才能以静制动，实现规范的高质量的项目。
　接口就是规范，就是项目中最稳定的东东! 面向接口编程可以让我们把握住真正核心的东西，使实现复杂多变的需求成为可能。
　通过面向接口编程，而不是面向实现类编程，可以大大降低程序模块间的耦合性，提高整个系统的可扩展性和和可维护性。
　面向接口编程的概念比接口本身的概念要大得多。设计阶段相对比较困难，在你没有写实现时就要想好接口，接口一变就乱套了，所以设计要比实现难!
老鸟建议 　接口语法本身非常简单，但是如何真正使用?这才是大学问。我们需要后面在项目中反复使用，大家才能体会到。 学到此处，能了解基本概念，熟悉基本语法，就是“好学生”了。 请继续努力!再请工作后，闲余时间再看看上面这段话，相信你会有更深的体会。</description>
			<content type="html"><![CDATA[<p>　　面向接口编程是面向对象编程的一部分。</p>
<p>　　为什么需要面向接口编程? 软件设计中最难处理的就是需求的复杂变化，需求的变化更多的体现在具体实现上。我们的编程如果围绕具体实现来展开就会陷入”复杂变化”的汪洋大海中，软件也就不能最终实现。我们必须围绕某种稳定的东西开展，才能以静制动，实现规范的高质量的项目。</p>
<p>　　接口就是规范，就是项目中最稳定的东东! 面向接口编程可以让我们把握住真正核心的东西，使实现复杂多变的需求成为可能。</p>
<p>　　通过面向接口编程，而不是面向实现类编程，可以大大降低程序模块间的耦合性，提高整个系统的可扩展性和和可维护性。</p>
<p>　　面向接口编程的概念比接口本身的概念要大得多。设计阶段相对比较困难，在你没有写实现时就要想好接口，接口一变就乱套了，所以设计要比实现难!</p>
<h2 id="老鸟建议">老鸟建议</h2>
<p>　　接口语法本身非常简单，但是如何真正使用?这才是大学问。我们需要后面在项目中反复使用，大家才能体会到。 学到此处，能了解基本概念，熟悉基本语法，就是“好学生”了。 请继续努力!再请工作后，闲余时间再看看上面这段话，相信你会有更深的体会。</p>
]]></content>
		</item>
		
		<item>
			<title>5.9.3 接口的多继承</title>
			<link>https://HarryQing.github.io/posts/5.9.3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF/</link>
			<pubDate>Fri, 05 Mar 2021 11:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.9.3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF/</guid>
			<description>　接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。
【示例5-18】 接口的多继承
interface A { void testa(); } interface B { void testb(); } /**接口可以多继承：接口C继承接口A和B*/ interface C extends A, B { void testc(); } public class Test implements C { public void testc() { } public void testa() { } public void testb() { } } </description>
			<content type="html"><![CDATA[<p>　　接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。</p>
<p><strong>【示例5-18】</strong> 接口的多继承</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">A</span> <span class="o">{</span>
	<span class="kt">void</span> <span class="nf">testa</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">B</span> <span class="o">{</span>
	<span class="kt">void</span> <span class="nf">testb</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/**接口可以多继承：接口C继承接口A和B*/</span>
<span class="kd">interface</span> <span class="nc">C</span> <span class="kd">extends</span> <span class="n">A</span><span class="o">,</span> <span class="n">B</span> <span class="o">{</span>
	<span class="kt">void</span> <span class="nf">testc</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="kd">implements</span> <span class="n">C</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testc</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testa</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testb</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>5.9.2 如何定义和使用接口?</title>
			<link>https://HarryQing.github.io/posts/5.9.2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/</link>
			<pubDate>Fri, 05 Mar 2021 09:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.9.2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/</guid>
			<description>声明格式： [访问修饰符] interface 接口名 [extends 父接口1，父接口2…] { 常量定义； 方法定义； } 定义接口的详细说明： 　1. 访问修饰符：只能是public或默认。
　2. 接口名：和类名采用相同命名机制。
　3. extends：接口可以多继承。
　4. 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。
　5. 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。
要点 　1. 子类通过implements来实现接口中的规范。
　2. 接口不能创建实例，但是可用于声明引用变量类型。
　3. 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。
　4. JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。
　5. JDK1.8后，接口中包含普通的静态方法。
【示例5-17】 接口的使用
public class TestInterface { public static void main(String[] args) { Volant volant = new Angel(); volant.fly(); System.out.println(Volant.FLY_HIGHT); Honest honest = new GoodMan(); honest.</description>
			<content type="html"><![CDATA[<h2 id="声明格式">声明格式：</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="o">[</span><span class="n">访问修饰符</span><span class="o">]</span>  <span class="kd">interface</span> <span class="nc">接口名</span>   <span class="o">[</span><span class="kd">extends</span>  <span class="n">父接口1</span><span class="err">，</span><span class="n">父接口2</span><span class="err">…</span><span class="o">]</span>  <span class="o">{</span>
<span class="n">常量定义</span><span class="err">；</span>  
<span class="n">方法定义</span><span class="err">；</span>
<span class="o">}</span>
</code></pre></div><h2 id="定义接口的详细说明">定义接口的详细说明：</h2>
<p>　　1. 访问修饰符：只能是public或默认。</p>
<p>　　2. 接口名：和类名采用相同命名机制。</p>
<p>　　3. extends：接口可以多继承。</p>
<p>　　4. 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。</p>
<p>　　5. 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。</p>
<h2 id="要点">要点</h2>
<p>　　1. 子类通过implements来实现接口中的规范。</p>
<p>　　2. 接口不能创建实例，但是可用于声明引用变量类型。</p>
<p>　　3. 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。</p>
<p>　　4. JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。</p>
<p>　　5. JDK1.8后，接口中包含普通的静态方法。</p>
<p><strong>【示例5-17】</strong> 接口的使用</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestInterface</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Volant</span> <span class="n">volant</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Angel</span><span class="o">();</span>
		<span class="n">volant</span><span class="o">.</span><span class="na">fly</span><span class="o">();</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Volant</span><span class="o">.</span><span class="na">FLY_HIGHT</span><span class="o">);</span>

		<span class="n">Honest</span> <span class="n">honest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GoodMan</span><span class="o">();</span>
		<span class="n">honest</span><span class="o">.</span><span class="na">helpOther</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="cm">/**飞行接口*/</span>
<span class="kd">interface</span> <span class="nc">Volant</span> <span class="o">{</span> 
	<span class="kt">int</span> <span class="n">FLY_HIGHT</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span>  <span class="c1">// 总是：public static final类型的；
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">fly</span><span class="o">();</span>   <span class="c1">//总是：public abstract void fly();
</span><span class="c1"></span><span class="o">}</span>
<span class="cm">/**善良接口*/</span>
<span class="kd">interface</span> <span class="nc">Honest</span> <span class="o">{</span> 
	<span class="kt">void</span> <span class="nf">helpOther</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/**Angle类实现飞行接口和善良接口*/</span>
<span class="kd">class</span> <span class="nc">Angel</span> <span class="kd">implements</span> <span class="n">Volant</span><span class="o">,</span> <span class="n">Honest</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我是天使，飞起来啦！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">helpOther</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;扶老奶奶过马路！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">GoodMan</span> <span class="kd">implements</span> <span class="n">Honest</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">helpOther</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;扶老奶奶过马路！&#34;</span><span class="o">);</span>
	<span class="o">}</span>  
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">BirdMan</span> <span class="kd">implements</span> <span class="n">Volant</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我是鸟人，正在飞！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如果5-23所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495260169113292.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.9.1接口的作用</title>
			<link>https://HarryQing.github.io/posts/5.9.1%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
			<pubDate>Thu, 04 Mar 2021 23:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.9.1%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
			<description>· 为什么需要接口?接口和抽象类的区别? 　接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。
　抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。
　从接口的实现者角度看，接口定义了可以向外部提供的服务。
　从接口的调用者角度看，接口定义了实现者能提供那些服务。
　接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。
　接口和实现类不是父子关系，是实现规则的关系。比如：我定义一个接口Runnable，Car实现它就能在地上跑，Train实现它也能在地上跑，飞机实现它也能在地上跑。就是说，如果它是交通工具，就一定能跑，但是一定要实现Runnable接口。
· 接口的本质探讨 　接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，则必须能干掉坏人;如果你是坏人，则必须欺负好人。
　接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。
　面向对象的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如C++、Java、C#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。
区别  1. 普通类：具体实现2. 抽象类：具体实现，规范(抽象方法)3. 接口：规范! </description>
			<content type="html"><![CDATA[<h2 id="-为什么需要接口接口和抽象类的区别">· 为什么需要接口?接口和抽象类的区别?</h2>
<p>　　接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。</p>
<p>　　抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。</p>
<p>　　从接口的实现者角度看，接口定义了可以向外部提供的服务。</p>
<p>　　从接口的调用者角度看，接口定义了实现者能提供那些服务。</p>
<p>　　接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。</p>
<p>　　接口和实现类不是父子关系，是实现规则的关系。比如：我定义一个接口Runnable，Car实现它就能在地上跑，Train实现它也能在地上跑，飞机实现它也能在地上跑。就是说，如果它是交通工具，就一定能跑，但是一定要实现Runnable接口。</p>
<h2 id="-接口的本质探讨">· 接口的本质探讨</h2>
<p>　　接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，则必须能干掉坏人;如果你是坏人，则必须欺负好人。</p>
<p>　　接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</p>
<p>　　面向对象的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如C++、Java、C#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。</p>
<h2 id="区别">区别</h2>
<pre><code>  1. 普通类：具体实现

  2. 抽象类：具体实现，规范(抽象方法)

  3. 接口：规范!</code></pre>
]]></content>
		</item>
		
		<item>
			<title>5.8 抽象方法和抽象类</title>
			<link>https://HarryQing.github.io/posts/5.8-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link>
			<pubDate>Thu, 04 Mar 2021 22:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.8-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid>
			<description>·抽象方法 　使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。
·抽象类 　包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。
【示例5-16】 抽象类和抽象方法的基本用法
//抽象类 abstract class Animal { abstract public void shout(); //抽象方法 } class Dog extends Animal { //子类必须实现父类的抽象方法，否则编译错误 	public void shout() { System.out.println(&amp;#34;汪汪汪！&amp;#34;); } public void seeDoor(){ System.out.println(&amp;#34;看门中....&amp;#34;); } } //测试抽象类 public class TestAbstractClass { public static void main(String[] args) { Dog a = new Dog(); a.shout(); a.seeDoor(); } } 抽象类的使用要点: 　1. 有抽象方法的类只能定义成抽象类
　2. 抽象类不能实例化，即不能用new来实例化抽象类。
　3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。
　4. 抽象类只能用来被继承。</description>
			<content type="html"><![CDATA[<h2 id="抽象方法">·抽象方法</h2>
<p>　　使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。</p>
<h2 id="抽象类">·抽象类</h2>
<p>　　包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。</p>
<p><strong>【示例5-16】</strong> 抽象类和抽象方法的基本用法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//抽象类
</span><span class="c1"></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
	<span class="kd">abstract</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shout</span><span class="o">();</span>  <span class="c1">//抽象方法
</span><span class="c1"></span><span class="o">}</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span> 
	<span class="c1">//子类必须实现父类的抽象方法，否则编译错误
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shout</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;汪汪汪！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">seeDoor</span><span class="o">(){</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;看门中....&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="c1">//测试抽象类
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestAbstractClass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Dog</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">();</span>
		<span class="n">a</span><span class="o">.</span><span class="na">shout</span><span class="o">();</span>
		<span class="n">a</span><span class="o">.</span><span class="na">seeDoor</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="抽象类的使用要点">抽象类的使用要点:</h2>
<p>　　1. 有抽象方法的类只能定义成抽象类</p>
<p>　　2. 抽象类不能实例化，即不能用new来实例化抽象类。</p>
<p>　　3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。</p>
<p>　　4. 抽象类只能用来被继承。</p>
<p>　　5. 抽象方法必须被子类实现。</p>
]]></content>
		</item>
		
		<item>
			<title>5.7 final关键字</title>
			<link>https://HarryQing.github.io/posts/5.7-final%E5%85%B3%E9%94%AE%E5%AD%97/</link>
			<pubDate>Thu, 04 Mar 2021 20:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.7-final%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
			<description>final关键字的作用： 　1. 修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。
final int MAX_SPEED = 120; 　2. 修饰方法：该方法不可被子类重写。但是可以被重载!
final void study(){} 　3. 修饰类: 修饰的类不能被继承。比如：Math、String等。
final class A {} 　final修饰变量详见第二章示例2-9。
final修饰方法如图5-21所示。
final修饰类如图5-22所示。</description>
			<content type="html"><![CDATA[<h2 id="final关键字的作用">final关键字的作用：</h2>
<p>　　1. 修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。</p>
<pre><code>final  int   MAX_SPEED = 120;
</code></pre>
<p>　　2. 修饰方法：该方法不可被子类重写。但是可以被重载!</p>
<pre><code>final  void  study(){}
</code></pre>
<p>　　3. 修饰类: 修饰的类不能被继承。比如：Math、String等。</p>
<pre><code>final   class  A {}
</code></pre>
<p>　　final修饰变量详见第二章示例2-9。</p>
<p>final修饰方法如图5-21所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495258739380250.png" alt="enter description here"></p>
<p>final修饰类如图5-22所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495258781342385.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.6 对象的转型(casting)</title>
			<link>https://HarryQing.github.io/posts/5.6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E5%9E%8Bcasting/</link>
			<pubDate>Thu, 04 Mar 2021 18:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E5%9E%8Bcasting/</guid>
			<description>父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。
　向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型!
【示例5-13】 对象的转型
public class TestCasting { public static void main(String[] args) { Object obj = new String(&amp;#34;北京&amp;#34;); // 向上可以自动转型 	// obj.charAt(0) 无法调用。编译器认为obj是Object类型而不是String类型 	/* 编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。 * 不然通不过编译器的检查。 */ String str = (String) obj; // 向下转型 	System.out.println(str.charAt(0)); // 位于0索引位置的字符 	System.out.println(obj == str); // true.他们俩运行时是同一个对象 	} } 　执行结果如果5-18所示：
　在向下转型过程中，必须将引用变量转成真实的子类类型(运行时类型)否则会出现类型转换异常ClassCastException。如示例5-14所示。
【示例5-14】 类型转换异常
public class TestCasting2 { public static void main(String[] args) { Object obj = new String(&amp;#34;北京尚学堂&amp;#34;); //真实的子类类型是String，但是此处向下转型为StringBuffer 	StringBuffer str = (StringBuffer) obj; System.</description>
			<content type="html"><![CDATA[<p>　　父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。</p>
<p>　　向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型!</p>
<p><strong>【示例5-13】</strong> 对象的转型</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestCasting</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;北京&#34;</span><span class="o">);</span> <span class="c1">// 向上可以自动转型
</span><span class="c1"></span>		<span class="c1">// obj.charAt(0) 无法调用。编译器认为obj是Object类型而不是String类型
</span><span class="c1"></span>		<span class="cm">/* 编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。
</span><span class="cm">		 * 不然通不过编译器的检查。 */</span>
		<span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span> <span class="c1">// 向下转型
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">));</span> <span class="c1">// 位于0索引位置的字符
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="n">str</span><span class="o">);</span> <span class="c1">// true.他们俩运行时是同一个对象
</span><span class="c1"></span>	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　执行结果如果5-18所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495254148771321.png" alt="enter description here"></p>
<p>　　在向下转型过程中，必须将引用变量转成真实的子类类型(运行时类型)否则会出现类型转换异常ClassCastException。如示例5-14所示。</p>
<p><strong>【示例5-14】</strong> 类型转换异常</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestCasting2</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;北京尚学堂&#34;</span><span class="o">);</span>
		<span class="c1">//真实的子类类型是String，但是此处向下转型为StringBuffer
</span><span class="c1"></span>		<span class="n">StringBuffer</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="n">StringBuffer</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　执行结果如果5-19所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495256025435935.png" alt="enter description here"></p>
<p>　　为了避免出现这种异常，我们可以使用5.1.2中所学的instanceof运算符进行判断，如示例5-15所示。</p>
<p><strong>【示例5-15】</strong> 向下转型中使用instanceof</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestCasting3</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;北京&#34;</span><span class="o">);</span>
		<span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="n">String</span><span class="o">){</span>
			<span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">obj</span><span class="o">;</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
		<span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="n">StringBuffer</span><span class="o">){</span>
			<span class="n">StringBuffer</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="n">StringBuffer</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　执行结果如果5-20所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495256138635602.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.5 多态(polymorphism)</title>
			<link>https://HarryQing.github.io/posts/5.5-%E5%A4%9A%E6%80%81polymorphism/</link>
			<pubDate>Thu, 04 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.5-%E5%A4%9A%E6%80%81polymorphism/</guid>
			<description>多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 比如：同样是调用人的“休息”方法，张三是睡觉，李四是旅游，高淇老师是敲代码，数学教授是做数学题; 同样是调用人“吃饭”的方法，中国人用筷子吃饭，英国人用刀叉吃饭，印度人用手吃饭。
多态的要点：  1. 多态是方法的多态，不是属性的多态(多态与属性无关)。2. 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。3. 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 【示例5-12】 多态和类型转换测试
class Animal { public void shout() { System.out.println(&amp;#34;叫了一声！&amp;#34;); } } class Dog extends Animal { public void shout() { System.out.println(&amp;#34;旺旺旺！&amp;#34;); } public void seeDoor() { System.out.println(&amp;#34;看门中....&amp;#34;); } } class Cat extends Animal { public void shout() { System.out.println(&amp;#34;喵喵喵喵！&amp;#34;); } } public class TestPolym { public static void main(String[] args) { Animal a1 = new Cat(); // 向上可以自动转型 	//传的具体是哪一个类就调用哪一个类的方法。大大提高了程序的可扩展性。 	animalCry(a1); Animal a2 = new Dog(); animalCry(a2);//a2为编译类型，Dog对象才是运行时类型。  //编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。 	// 否则通不过编译器的检查。 	Dog dog = (Dog)a2;//向下需要强制类型转换 	dog.</description>
			<content type="html"><![CDATA[<p>　　多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 比如：同样是调用人的“休息”方法，张三是睡觉，李四是旅游，高淇老师是敲代码，数学教授是做数学题; 同样是调用人“吃饭”的方法，中国人用筷子吃饭，英国人用刀叉吃饭，印度人用手吃饭。</p>
<h2 id="多态的要点">多态的要点：</h2>
<pre><code>  1. 多态是方法的多态，不是属性的多态(多态与属性无关)。

  2. 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。

  3. 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。
</code></pre>
<p><strong>【示例5-12】</strong> 多态和类型转换测试</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shout</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;叫了一声！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shout</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;旺旺旺！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">seeDoor</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;看门中....&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shout</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;喵喵喵喵！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestPolym</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Animal</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="o">();</span> <span class="c1">// 向上可以自动转型
</span><span class="c1"></span>		<span class="c1">//传的具体是哪一个类就调用哪一个类的方法。大大提高了程序的可扩展性。
</span><span class="c1"></span>		<span class="n">animalCry</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>
		<span class="n">Animal</span> <span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">();</span>
		<span class="n">animalCry</span><span class="o">(</span><span class="n">a2</span><span class="o">);</span><span class="c1">//a2为编译类型，Dog对象才是运行时类型。
</span><span class="c1"></span>
		<span class="c1">//编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。
</span><span class="c1"></span>		<span class="c1">// 否则通不过编译器的检查。
</span><span class="c1"></span>		<span class="n">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="o">(</span><span class="n">Dog</span><span class="o">)</span><span class="n">a2</span><span class="o">;</span><span class="c1">//向下需要强制类型转换
</span><span class="c1"></span>		<span class="n">dog</span><span class="o">.</span><span class="na">seeDoor</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="c1">// 有了多态，只需要让增加的这个类继承Animal类就可以了。
</span><span class="c1"></span>	<span class="kd">static</span> <span class="kt">void</span> <span class="nf">animalCry</span><span class="o">(</span><span class="n">Animal</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">a</span><span class="o">.</span><span class="na">shout</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="cm">/* 如果没有多态，我们这里需要写很多重载的方法。
</span><span class="cm">	 * 每增加一种动物，就需要重载一种动物的喊叫方法。非常麻烦。
</span><span class="cm">	static void animalCry(Dog d) {
</span><span class="cm">		d.shout();
</span><span class="cm">	}
</span><span class="cm">	static void animalCry(Cat c) {
</span><span class="cm">		c.shout();
</span><span class="cm">	}*/</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-17所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495253451887350.png" alt="enter description here"></p>
<p>图5-17 示例5-12运行效果图</p>
<p>　　示例5-12给大家展示了多态最为多见的一种用法，即父类引用做方法的形参，实参可以是任意的子类对象，可以通过不同的子类对象实现不同的行为方式。</p>
<p>　　由此，我们可以看出多态的主要优势是提高了代码的可扩展性，符合开闭原则。但是多态也有弊端，就是无法调用子类特有的功能，比如，我不能使用父类的引用变量调用Dog类特有的seeDoor()方法。</p>
<p>　　那如果我们就想使用子类特有的功能行不行呢?行!这就是我们下一章节所讲的内容：对象的转型。</p>
]]></content>
		</item>
		
		<item>
			<title>5.4.3 封装的使用细节</title>
			<link>https://HarryQing.github.io/posts/5.4.3-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</link>
			<pubDate>Wed, 03 Mar 2021 23:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.4.3-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</guid>
			<description>类的属性的处理: 　1. 一般使用private访问权限。
　2. 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。
　3. 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。
【示例5-10】 JavaBean的封装实例
public class Person { // 属性一般使用private修饰 	private String name; private int age; private boolean flag; // 为属性提供public修饰的set/get方法 	public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public boolean isFlag() {// 注意：boolean类型的属性get方法是is开头的 	return flag; } public void setFlag(boolean flag) { this.</description>
			<content type="html"><![CDATA[<h2 id="类的属性的处理">类的属性的处理:</h2>
<p>　　1. 一般使用private访问权限。</p>
<p>　　2.  提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。</p>
<p>　　3. 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。</p>
<p><strong>【示例5-10】</strong> JavaBean的封装实例</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="c1">// 属性一般使用private修饰
</span><span class="c1"></span>	<span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">flag</span><span class="o">;</span>
	<span class="c1">// 为属性提供public修饰的set/get方法
</span><span class="c1"></span>	<span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFlag</span><span class="o">()</span> <span class="o">{</span><span class="c1">// 注意：boolean类型的属性get方法是is开头的
</span><span class="c1"></span>		<span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFlag</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">flag</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　下面我们使用封装来解决一下5.4.1中提到的年龄非法赋值的问题。</p>
<p><strong>【示例5-11】</strong> 封装的使用</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>

	<span class="o">}</span>
	<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
		<span class="c1">// this.age = age;//构造方法中不能直接赋值，应该调用setAge方法
</span><span class="c1"></span>		<span class="n">setAge</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//在赋值之前先判断年龄是否合法
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&gt;</span> <span class="n">130</span> <span class="o">||</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">18</span><span class="o">;</span><span class="c1">//不合法赋默认值18
</span><span class="c1"></span>		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span><span class="c1">//合法才能赋值给属性age
</span><span class="c1"></span>		<span class="o">}</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="s">&#34;Person [name=&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#34;, age=&#34;</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
		<span class="c1">//p1.name = &#34;小红&#34;; //编译错误
</span><span class="c1"></span>		<span class="c1">//p1.age = -45;  //编译错误
</span><span class="c1"></span>		<span class="n">p1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;小红&#34;</span><span class="o">);</span>
		<span class="n">p1</span><span class="o">.</span><span class="na">setAge</span><span class="o">(-</span><span class="n">45</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">);</span>

		<span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;小白&#34;</span><span class="o">,</span> <span class="n">300</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-16所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495253058271276.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.4.2 封装的实现—使用访问控制符</title>
			<link>https://HarryQing.github.io/posts/5.4.2-%E5%B0%81%E8%A3%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/</link>
			<pubDate>Wed, 03 Mar 2021 22:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.4.2-%E5%B0%81%E8%A3%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/</guid>
			<description>Java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。
　下面详细讲述它们的访问权限问题。其访问权限范围如表5-1所示。
表5-1 访问权限修饰符
 1. private 表示私有，只有自己类能访问2. default表示没有修饰符修饰，只有同一个包的类能访问3. protected表示可以被同一个包的类以及其他包中的子类访问4. public表示可以被该项目的所有包中的所有类访问 　下面做进一步说明Java中4种访问权限修饰符的区别：首先我们创建4个类：Person类、Student类、Animal类和Computer类，分别比较本类、本包、子类、其他包的区别。
public访问权限修饰符： 图5-8 public访问权限—本类中访问public属性
图5-9 public访问权限—本包中访问public属性
图5-10 public访问权限—不同包中的子类访问public属性
图5-11 public访问权限—不同包中的非子类访问public属性
　通过图5-8 ~ 图5-11可以说明，public修饰符的访问权限为：该项目的所有包中的所有类。
protected访问权限修饰符：将Person类中属性改为protected，其他类不修改。 图5-12 protected访问权限—修改后的Person类
图5-13 protected访问权限—不同包中的非子类不能访问protected属性
　通过图5-12和图5-13可以说明，protected修饰符的访问权限为：同一个包中的类以及其他包中的子类。
默认访问权限修饰符：将Person类中属性改为默认的，其他类不修改。 图5-14 默认访问权限—修改后的Person类
　通过图5-14可以说明，默认修饰符的访问权限为：同一个包中的类。
private访问权限修饰符：将Person类中属性改为private，其他类不修改。 图5-15 private访问权限—修改后的Person类
　通过图5-15可以说明，private修饰符的访问权限为：同一个类。</description>
			<content type="html"><![CDATA[<p>　　Java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。</p>
<p>　　下面详细讲述它们的访问权限问题。其访问权限范围如表5-1所示。</p>
<p>表5-1 访问权限修饰符</p>
<p><img src="https://i.loli.net/2021/03/16/nyDWhU3mLpwl7j2.png" alt="image.png"></p>
<pre><code>  1. private 表示私有，只有自己类能访问

  2. default表示没有修饰符修饰，只有同一个包的类能访问

  3. protected表示可以被同一个包的类以及其他包中的子类访问

  4. public表示可以被该项目的所有包中的所有类访问
</code></pre>
<p>　　下面做进一步说明Java中4种访问权限修饰符的区别：首先我们创建4个类：Person类、Student类、Animal类和Computer类，分别比较本类、本包、子类、其他包的区别。</p>
<h2 id="public访问权限修饰符">public访问权限修饰符：</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495251897514580.png" alt="enter description here"></p>
<p>图5-8 public访问权限—本类中访问public属性</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495251910209664.png" alt="enter description here"></p>
<p>图5-9 public访问权限—本包中访问public属性</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495251926154354.png" alt="enter description here"></p>
<p>图5-10 public访问权限—不同包中的子类访问public属性</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495251937942718.png" alt="enter description here"></p>
<p>图5-11 public访问权限—不同包中的非子类访问public属性</p>
<p>　　通过图5-8 ~ 图5-11可以说明，public修饰符的访问权限为：该项目的所有包中的所有类。</p>
<h2 id="protected访问权限修饰符将person类中属性改为protected其他类不修改">protected访问权限修饰符：将Person类中属性改为protected，其他类不修改。</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495251999316349.png" alt="enter description here"></p>
<p>图5-12 protected访问权限—修改后的Person类</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495252016275089.png" alt="enter description here"></p>
<p>图5-13 protected访问权限—不同包中的非子类不能访问protected属性</p>
<p>　　通过图5-12和图5-13可以说明，protected修饰符的访问权限为：同一个包中的类以及其他包中的子类。</p>
<h2 id="默认访问权限修饰符将person类中属性改为默认的其他类不修改">默认访问权限修饰符：将Person类中属性改为默认的，其他类不修改。</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495252053329405.png" alt="enter description here"></p>
<p>图5-14 默认访问权限—修改后的Person类</p>
<p>　　通过图5-14可以说明，默认修饰符的访问权限为：同一个包中的类。</p>
<h2 id="private访问权限修饰符将person类中属性改为private其他类不修改">private访问权限修饰符：将Person类中属性改为private，其他类不修改。</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495252087548083.png" alt="enter description here"></p>
<p>图5-15 private访问权限—修改后的Person类</p>
<p>　　通过图5-15可以说明，private修饰符的访问权限为：同一个类。</p>
]]></content>
		</item>
		
		<item>
			<title>5.4.1 封装的作用和含义</title>
			<link>https://HarryQing.github.io/posts/5.4.1-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%90%AB%E4%B9%89/</link>
			<pubDate>Wed, 03 Mar 2021 18:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.4.1-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%90%AB%E4%B9%89/</guid>
			<description>我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗?有必要碰碰显像管吗?制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如：电源开关。具体内部是怎么实现的，我们不需要操心。
　需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。
　我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。
编程中封装的具体优点：  1. 提高代码的安全性。2. 提高代码的复用性。3. “高内聚”：封装细节，便于修改内部代码，提高可维护性。4. “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 【示例5-9】 没有封装的代码会出现一些问题
class Person { String name; int age; @Override public String toString() { return &amp;#34;Person [name=&amp;#34; + name + &amp;#34;, age=&amp;#34; + age + &amp;#34;]&amp;#34;; } } public class Test { public static void main(String[] args) { Person p = new Person(); p.name = &amp;#34;小红&amp;#34;; p.age = -45;//年龄可以通过这种方式随意赋值，没有任何限制 	System.out.println(p); } } 　我们都知道，年龄不可能是负数，也不可能超过130岁，但是如果没有使用封装的话，便可以给年龄赋值成任意的整数，这显然不符合我们的正常逻辑思维。执行结果如图5-7所示:</description>
			<content type="html"><![CDATA[<p>　　我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗?有必要碰碰显像管吗?制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如：电源开关。具体内部是怎么实现的，我们不需要操心。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20171028/1509199502558961.png" alt="enter description here"></p>
<p>　　需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。</p>
<p>　　我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。</p>
<h2 id="编程中封装的具体优点">编程中封装的具体优点：</h2>
<pre><code> 1. 提高代码的安全性。

 2. 提高代码的复用性。

 3. “高内聚”：封装细节，便于修改内部代码，提高可维护性。

 4. “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。
</code></pre>
<p><strong>【示例5-9】</strong> 没有封装的代码会出现一些问题</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="s">&#34;Person [name=&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#34;, age=&#34;</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
		<span class="n">p</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">&#34;小红&#34;</span><span class="o">;</span>
		<span class="n">p</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="o">-</span><span class="n">45</span><span class="o">;</span><span class="c1">//年龄可以通过这种方式随意赋值，没有任何限制
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　我们都知道，年龄不可能是负数，也不可能超过130岁，但是如果没有使用封装的话，便可以给年龄赋值成任意的整数，这显然不符合我们的正常逻辑思维。执行结果如图5-7所示:</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495250202677298.png" alt="enter description here"></p>
<p>　　再比如说，如果哪天我们需要将Person类中的age属性修改为String类型的，你会怎么办?你只有一处使用了这个类的话那还比较幸运，但如果你有几十处甚至上百处都用到了，那你岂不是要改到崩溃。而封装恰恰能解决这样的问题。如果使用封装，我们只需要稍微修改下Person类的setAge()方法即可，而无需修改使用了该类的客户代码。</p>
]]></content>
		</item>
		
		<item>
			<title>5.3.1 继承树追溯</title>
			<link>https://HarryQing.github.io/posts/5.3.1-%E7%BB%A7%E6%89%BF%E6%A0%91%E8%BF%BD%E6%BA%AF/</link>
			<pubDate>Wed, 03 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.3.1-%E7%BB%A7%E6%89%BF%E6%A0%91%E8%BF%BD%E6%BA%AF/</guid>
			<description>·属性/方法查找顺序：(比如：查找变量h)  1. 查找当前类中有没有属性h2. 依次上溯每个父类，查看每个父类中是否有h，直到Object3. 如果没找到，则出现编译错误。4. 上面步骤，只要找到h变量，则这个过程终止。 ·构造方法调用顺序： 　构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。
　注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。
【示例5-8】 构造方法向上追溯执行测试
public class TestSuper02 { public static void main(String[] args) { System.out.println(&amp;#34;开始创建一个ChildClass对象......&amp;#34;); new ChildClass(); } } class FatherClass { public FatherClass() { System.out.println(&amp;#34;创建FatherClass&amp;#34;); } } class ChildClass extends FatherClass { public ChildClass() { System.out.println(&amp;#34;创建ChildClass&amp;#34;); } } 执行结果如图5-6所示：</description>
			<content type="html"><![CDATA[<h2 id="属性方法查找顺序比如查找变量h">·属性/方法查找顺序：(比如：查找变量h)</h2>
<pre><code>  1. 查找当前类中有没有属性h

  2. 依次上溯每个父类，查看每个父类中是否有h，直到Object

  3. 如果没找到，则出现编译错误。

  4. 上面步骤，只要找到h变量，则这个过程终止。
</code></pre>
<h2 id="构造方法调用顺序">·构造方法调用顺序：</h2>
<p>　　构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。</p>
<p>　　注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。</p>
<p><strong>【示例5-8】</strong> 构造方法向上追溯执行测试</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestSuper02</span> <span class="o">{</span> 
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;开始创建一个ChildClass对象......&#34;</span><span class="o">);</span>
		<span class="k">new</span> <span class="n">ChildClass</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">FatherClass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nf">FatherClass</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;创建FatherClass&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">ChildClass</span> <span class="kd">extends</span> <span class="n">FatherClass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nf">ChildClass</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;创建ChildClass&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-6所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170519/1495187263836897.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.3 super关键字</title>
			<link>https://HarryQing.github.io/posts/5.3-super%E5%85%B3%E9%94%AE%E5%AD%97/</link>
			<pubDate>Tue, 02 Mar 2021 18:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.3-super%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
			<description>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。
　使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。
　若是构造方法的第一行代码没有显式的调用super(&amp;hellip;)或者this(&amp;hellip;);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。
【示例5-7】 super关键字的使用
public class TestSuper01 { public static void main(String[] args) { new ChildClass().f(); } } class FatherClass { public int value; public void f(){ value = 100; System.out.println (&amp;#34;FatherClass.value=&amp;#34;+value); } } class ChildClass extends FatherClass { public int value; public void f() { super.f(); //调用父类对象的普通方法 	value = 200; System.out.println(&amp;#34;ChildClass.value=&amp;#34;+value); System.out.println(value); System.out.println(super.value); //调用父类对象的成员变量 	} } 执行结果如图5-5所示：</description>
			<content type="html"><![CDATA[<p>　　super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。</p>
<p>　　使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。</p>
<p>　　若是构造方法的第一行代码没有显式的调用super(&hellip;)或者this(&hellip;);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。</p>
<p><strong>【示例5-7】</strong> super关键字的使用</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestSuper01</span> <span class="o">{</span> 
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">new</span> <span class="n">ChildClass</span><span class="o">().</span><span class="na">f</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">FatherClass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">(){</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span> <span class="o">(</span><span class="s">&#34;FatherClass.value=&#34;</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">ChildClass</span> <span class="kd">extends</span> <span class="n">FatherClass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
		<span class="kd">super</span><span class="o">.</span><span class="na">f</span><span class="o">();</span>  <span class="c1">//调用父类对象的普通方法
</span><span class="c1"></span>		<span class="n">value</span> <span class="o">=</span> <span class="n">200</span><span class="o">;</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;ChildClass.value=&#34;</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="kd">super</span><span class="o">.</span><span class="na">value</span><span class="o">);</span> <span class="c1">//调用父类对象的成员变量
</span><span class="c1"></span>	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-5所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170519/1495186136513650.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.2.3 ==和equals方法</title>
			<link>https://HarryQing.github.io/posts/5.2.3-%E5%92%8Cequals%E6%96%B9%E6%B3%95/</link>
			<pubDate>Tue, 02 Mar 2021 17:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.2.3-%E5%92%8Cequals%E6%96%B9%E6%B3%95/</guid>
			<description>“==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。
　Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。比如，我们在公安系统中认为id相同的人就是同一个人、学籍系统中认为学号相同的人就是同一个人。
　Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。
【示例5-6】 equals方法测试和自定义类重写equals方法
public class TestEquals { public static void main(String[] args) { Person p1 = new Person(123,&amp;#34;王雪庆&amp;#34;); Person p2 = new Person(123,&amp;#34;张雪&amp;#34;); System.out.println(p1==p2); //false，不是同一个对象 	System.out.println(p1.equals(p2)); //true，id相同则认为两个对象内容相同 	String s1 = new String(&amp;#34;我爱你！&amp;#34;); String s2 = new String(&amp;#34;立刻有！&amp;#34;); System.out.println(s1==s2); //false, 两个字符串不是同一个对象 	System.out.println(s1.equals(s2)); //true, 两个字符串内容相同 	} } class Person { int id; String name; public Person(int id,String name) { this.</description>
			<content type="html"><![CDATA[<p>　　“==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。</p>
<p>　　Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。比如，我们在公安系统中认为id相同的人就是同一个人、学籍系统中认为学号相同的人就是同一个人。</p>
<p>　　Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。</p>
<p><strong>【示例5-6】</strong> equals方法测试和自定义类重写equals方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestEquals</span> <span class="o">{</span> 
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="n">123</span><span class="o">,</span><span class="s">&#34;王雪庆&#34;</span><span class="o">);</span>
		<span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="n">123</span><span class="o">,</span><span class="s">&#34;张雪&#34;</span><span class="o">);</span>     
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">==</span><span class="n">p2</span><span class="o">);</span>     <span class="c1">//false，不是同一个对象
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p2</span><span class="o">));</span>  <span class="c1">//true，id相同则认为两个对象内容相同
</span><span class="c1"></span>		<span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;我爱你！&#34;</span><span class="o">);</span>
		<span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;立刻有！&#34;</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">==</span><span class="n">s2</span><span class="o">);</span>         <span class="c1">//false, 两个字符串不是同一个对象
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>  <span class="c1">//true,  两个字符串内容相同
</span><span class="c1"></span>	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
	<span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">=</span><span class="n">id</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="o">}</span><span class="k">else</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="n">Person</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">Person</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span><span class="n">obj</span><span class="o">;</span>
				<span class="k">if</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">id</span><span class="o">==</span><span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>　　JDK提供的一些类，如String、Date、包装类等，重写了Object的equals方法，调用这些类的equals方法， x.equals (y) ，当x和y所引用的对象是同一类对象且属性内容相等时（并不一定是相同对象），返回 true 否则返回 false。</p>
]]></content>
		</item>
		
		<item>
			<title>5.2.2 toString方法</title>
			<link>https://HarryQing.github.io/posts/5.2.2-tostring%E6%96%B9%E6%B3%95/</link>
			<pubDate>Tue, 02 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.2.2-tostring%E6%96%B9%E6%B3%95/</guid>
			<description>Object类中定义有public String toString()方法，其返回值是 String 类型。Object类中toString方法的源码为：
public String toString() { return getClass().getName() + &amp;#34;@&amp;#34; + Integer.toHexString(hashCode()); } 　根据如上源码得知，默认会返回“类名+@+16进制的hashcode”。在打印输出或者用字符串连接对象时，会自动调用该对象的toString()方法。
【示例5-5】 toString()方法测试和重写toString()方法
class Person { String name; int age; @Override public String toString() { return name+&amp;#34;,年龄：&amp;#34;+age; } } public class Test { public static void main(String[] args) { Person p=new Person(); p.age=20; p.name=&amp;#34;李东&amp;#34;; System.out.println(&amp;#34;info:&amp;#34;+p); Test t = new Test(); System.out.println(t); } } 执行结果如图5-4所示：</description>
			<content type="html"><![CDATA[<p>　　Object类中定义有public String toString()方法，其返回值是 String 类型。Object类中toString方法的源码为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;@&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toHexString</span><span class="o">(</span><span class="n">hashCode</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div><p>　　根据如上源码得知，默认会返回“类名+@+16进制的hashcode”。在打印输出或者用字符串连接对象时，会自动调用该对象的toString()方法。</p>
<p><strong>【示例5-5】</strong> toString()方法测试和重写toString()方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">name</span><span class="o">+</span><span class="s">&#34;,年龄：&#34;</span><span class="o">+</span><span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Person</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
		<span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">=</span><span class="n">20</span><span class="o">;</span>
		<span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">&#34;李东&#34;</span><span class="o">;</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;info:&#34;</span><span class="o">+</span><span class="n">p</span><span class="o">);</span>

		<span class="n">Test</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>执行结果如图5-4所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170519/1495183720428188.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.2.1 Object类基本特性</title>
			<link>https://HarryQing.github.io/posts/5.2.1-object%E7%B1%BB%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</link>
			<pubDate>Mon, 01 Mar 2021 23:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.2.1-object%E7%B1%BB%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</guid>
			<description>　Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。
【示例5-4】 Object类
public class Person { ... } //等价于： public class Person extends Object { ... } </description>
			<content type="html"><![CDATA[<p>　　Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。</p>
<p><strong>【示例5-4】</strong> Object类</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="o">...</span>
<span class="o">}</span>
<span class="c1">//等价于：
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">extends</span> <span class="n">Object</span> <span class="o">{</span>
	<span class="o">...</span>
<span class="o">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>5.1.4方法的重写override</title>
			<link>https://HarryQing.github.io/posts/5.1.4%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99override/</link>
			<pubDate>Mon, 01 Mar 2021 22:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.1.4%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99override/</guid>
			<description>子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。
方法的重写需要符合下面的三个要点：  1.“==”： 方法名、形参列表相同。2.“≤”：返回值类型和声明异常类型，子类小于等于父类。3.“≥”： 访问权限，子类大于等于父类。 【示例5-3】 方法重写
public class TestOverride { public static void main(String[] args) { Vehicle v1 = new Vehicle(); Vehicle v2 = new Horse(); Vehicle v3 = new Plane(); v1.run(); v2.run(); v3.run(); v2.stop(); v3.stop(); } } class Vehicle { // 交通工具类 	public void run() { System.out.println(&amp;#34;跑....&amp;#34;); } public void stop() { System.out.println(&amp;#34;停止不动&amp;#34;); } } class Horse extends Vehicle { // 马也是交通工具 	public void run() { // 重写父类方法 	System.</description>
			<content type="html"><![CDATA[<p>　　子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。</p>
<h2 id="方法的重写需要符合下面的三个要点">方法的重写需要符合下面的三个要点：</h2>
<pre><code>  1.“==”： 方法名、形参列表相同。

  2.“≤”：返回值类型和声明异常类型，子类小于等于父类。

  3.“≥”： 访问权限，子类大于等于父类。
</code></pre>
<p><strong>【示例5-3】</strong> 方法重写</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestOverride</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Vehicle</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vehicle</span><span class="o">();</span>
		<span class="n">Vehicle</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Horse</span><span class="o">();</span>
		<span class="n">Vehicle</span> <span class="n">v3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Plane</span><span class="o">();</span>
		<span class="n">v1</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
		<span class="n">v2</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
		<span class="n">v3</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
		<span class="n">v2</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
		<span class="n">v3</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Vehicle</span> <span class="o">{</span> <span class="c1">// 交通工具类
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;跑....&#34;</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;停止不动&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Horse</span> <span class="kd">extends</span> <span class="n">Vehicle</span> <span class="o">{</span> <span class="c1">// 马也是交通工具
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// 重写父类方法
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;四蹄翻飞，嘚嘚嘚...&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Plane</span> <span class="kd">extends</span> <span class="n">Vehicle</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// 重写父类方法
</span><span class="c1"></span>		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;天上飞！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;空中不能停，坠毁了！&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>  
</code></pre></div><p>执行结果如图5-3所示：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170519/1495182341450054.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>5.1.3 继承使用要点</title>
			<link>https://HarryQing.github.io/posts/5.1.3-%E7%BB%A7%E6%89%BF%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/</link>
			<pubDate>Mon, 01 Mar 2021 21:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.1.3-%E7%BB%A7%E6%89%BF%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/</guid>
			<description>1.父类也称作超类、基类、派生类等。
2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。
3.Java中类没有多继承，接口有多继承。
4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。
5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。</description>
			<content type="html"><![CDATA[<p>1.父类也称作超类、基类、派生类等。</p>
<p>2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。</p>
<p>3.Java中类没有多继承，接口有多继承。</p>
<p>4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。</p>
<p>5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。</p>
]]></content>
		</item>
		
		<item>
			<title>5.1.2  instanceof 运算符</title>
			<link>https://HarryQing.github.io/posts/5.1.2-instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Mon, 01 Mar 2021 20:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.1.2-instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>instanceof是二元运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。比如：
【示例5-2】 使用instanceof运算符进行类型判断
public class Test{ public static void main(String[] args) { Student s = new Student(&amp;#34;高淇&amp;#34;,172,&amp;#34;Java&amp;#34;); System.out.println(s instanceof Person); System.out.println(s instanceof Student); } } 两条语句的输出结果都是true</description>
			<content type="html"><![CDATA[<p>　　instanceof是二元运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。比如：</p>
<p><strong>【示例5-2】</strong> 使用instanceof运算符进行类型判断</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Student</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;高淇&#34;</span><span class="o">,</span><span class="n">172</span><span class="o">,</span><span class="s">&#34;Java&#34;</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="k">instanceof</span> <span class="n">Person</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="k">instanceof</span> <span class="n">Student</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>两条语句的输出结果都是true</p>
]]></content>
		</item>
		
		<item>
			<title>5.1.1 继承的实现</title>
			<link>https://HarryQing.github.io/posts/5.1.1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Mon, 01 Mar 2021 19:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.1.1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
			<description>继承让我们更加容易实现类的扩展。 比如，我们定义了人类，再定义Boy类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t reinvent wheels)。
　从英文字面意思理解，extends的意思是“扩展”。子类是父类的扩展。现实世界中的继承无处不在。比如：
图5-1 现实世界中的继承
　上图中，哺乳动物继承了动物。意味着，动物的特性，哺乳动物都有；在我们编程中，如果新定义一个Student类，发现已经有Person类包含了我们需要的属性和方法，那么Student类只需要继承Person类即可拥有Person类的属性和方法。
【示例5-1】 使用extends实现继承
public class Test{ public static void main(String[] args) { Student s = new Student(&amp;#34;王雪庆&amp;#34;,172,&amp;#34;Java&amp;#34;); s.rest(); s.study(); } } class Person { String name; int height; public void rest(){ System.out.println(&amp;#34;休息一会！&amp;#34;); } } class Student extends Person { String major; //专业  public void study(){ System.out.println(&amp;#34;雪儿，学习Java&amp;#34;); } public Student(String name,int height,String major) { //天然拥有父类的属性  this.name = name; this.height = height; this.</description>
			<content type="html"><![CDATA[<p>　　继承让我们更加容易实现类的扩展。 比如，我们定义了人类，再定义Boy类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t  reinvent  wheels)。</p>
<p>　　从英文字面意思理解，extends的意思是“扩展”。子类是父类的扩展。现实世界中的继承无处不在。比如：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170519/1495179917567916.png" alt="enter description here"></p>
<p>图5-1 现实世界中的继承</p>
<p>　　上图中，哺乳动物继承了动物。意味着，动物的特性，哺乳动物都有；在我们编程中，如果新定义一个Student类，发现已经有Person类包含了我们需要的属性和方法，那么Student类只需要继承Person类即可拥有Person类的属性和方法。</p>
<p><strong>【示例5-1】</strong> 使用extends实现继承</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Student</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;王雪庆&#34;</span><span class="o">,</span><span class="n">172</span><span class="o">,</span><span class="s">&#34;Java&#34;</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">rest</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">study</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rest</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;休息一会！&#34;</span><span class="o">);</span>
    <span class="o">}</span>  
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">major</span><span class="o">;</span> <span class="c1">//专业
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">study</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;雪儿，学习Java&#34;</span><span class="o">);</span>
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span><span class="kt">int</span> <span class="n">height</span><span class="o">,</span><span class="n">String</span> <span class="n">major</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//天然拥有父类的属性
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">height</span> <span class="o">=</span> <span class="n">height</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">major</span> <span class="o">=</span> <span class="n">major</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>5.1 概述</title>
			<link>https://HarryQing.github.io/posts/5.1-%E6%A6%82%E8%BF%B0/</link>
			<pubDate>Mon, 01 Mar 2021 17:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/5.1-%E6%A6%82%E8%BF%B0/</guid>
			<description>本章重点针对面向对象的三大特征：继承、封装、多态进行详细的讲解。另外还包括抽象类、接口、内部类等概念。很多概念对于初学者来说，更多的是先进行语法性质的了解。不要期望，通过本章学习就“搞透面向对象”。本章只是面向对象的起点，后面所有的章节说白了都是对面向对象这一章的应用。
老鸟建议： 　建议大家，学习本章，莫停留！学完以后，迅速开展后面的章节。可以这么说，以后所有的编程都是“面向对象”的应用而已！</description>
			<content type="html"><![CDATA[<p>　　本章重点针对面向对象的三大特征：继承、封装、多态进行详细的讲解。另外还包括抽象类、接口、内部类等概念。很多概念对于初学者来说，更多的是先进行语法性质的了解。不要期望，通过本章学习就“搞透面向对象”。本章只是面向对象的起点，后面所有的章节说白了都是对面向对象这一章的应用。</p>
<h2 id="老鸟建议">老鸟建议：</h2>
<p>　　建议大家，学习本章，莫停留！学完以后，迅速开展后面的章节。可以这么说，以后所有的编程都是“面向对象”的应用而已！</p>
]]></content>
		</item>
		
		<item>
			<title>第五章 Java面对对象进阶</title>
			<link>https://HarryQing.github.io/posts/%E7%AC%AC%E4%BA%94%E7%AB%A0-java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</link>
			<pubDate>Mon, 01 Mar 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/%E7%AC%AC%E4%BA%94%E7%AB%A0-java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</guid>
			<description>目录 5.1 概述 5.1.1 继承的实现 5.1.2 instanceof 运算符 5.1.3 继承使用要点 5.1.4方法的重写override 5.2.1 Object类基本特性 5.2.2 toString方法 5.2.3 ==和equals方法 5.3 super关键字 5.3.1 继承树追溯 5.4.1 封装的作用和含义 5.4.2 封装的实现—使用访问控制符 5.4.3 封装的使用细节 5.5 多态(polymorphism) 5.6 对象的转型(casting) 5.7 final关键字 5.8 抽象方法和抽象类 5.9.1接口的作用 5.9.2 如何定义和使用接口? 5.9.3 接口的多继承 5.9.4 面向接口编程 5.10.1内部类的概念 5.10.2内部类的分类 5.11.1 String基础 5.11.2 String类和常量池 5.11.3阅读API文档 5.11.4 String类常用的方法 5.11.5 字符串相等的判断 5.12.1 开闭原则 5.12.2 模板方法模式和回调机制 5.12.3 组合模式 </description>
			<content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="51-概述">5.1 概述</h2>
<h2 id="511-继承的实现">5.1.1 继承的实现</h2>
<h2 id="512--instanceof-运算符">5.1.2  instanceof 运算符</h2>
<h2 id="513-继承使用要点">5.1.3 继承使用要点</h2>
<h2 id="514方法的重写override">5.1.4方法的重写override</h2>
<h2 id="521-object类基本特性">5.2.1 Object类基本特性</h2>
<h2 id="522-tostring方法">5.2.2 toString方法</h2>
<h2 id="523-和equals方法">5.2.3 ==和equals方法</h2>
<h2 id="53-super关键字">5.3 super关键字</h2>
<h2 id="531-继承树追溯">5.3.1 继承树追溯</h2>
<h2 id="541-封装的作用和含义">5.4.1 封装的作用和含义</h2>
<h2 id="542-封装的实现使用访问控制符">5.4.2 封装的实现—使用访问控制符</h2>
<h2 id="543-封装的使用细节">5.4.3 封装的使用细节</h2>
<h2 id="55-多态polymorphism">5.5 多态(polymorphism)</h2>
<h2 id="56-对象的转型casting">5.6 对象的转型(casting)</h2>
<h2 id="57-final关键字">5.7 final关键字</h2>
<h2 id="58-抽象方法和抽象类">5.8 抽象方法和抽象类</h2>
<h2 id="591接口的作用">5.9.1接口的作用</h2>
<h2 id="592-如何定义和使用接口">5.9.2 如何定义和使用接口?</h2>
<h2 id="593-接口的多继承">5.9.3 接口的多继承</h2>
<h2 id="594-面向接口编程">5.9.4 面向接口编程</h2>
<h2 id="5101内部类的概念">5.10.1内部类的概念</h2>
<h2 id="5102内部类的分类">5.10.2内部类的分类</h2>
<h2 id="5111-string基础">5.11.1 String基础</h2>
<h2 id="5112-string类和常量池">5.11.2 String类和常量池</h2>
<h2 id="5113阅读api文档">5.11.3阅读API文档</h2>
<h2 id="5114-string类常用的方法">5.11.4 String类常用的方法</h2>
<h2 id="5115-字符串相等的判断">5.11.5 字符串相等的判断</h2>
<h2 id="5121-开闭原则">5.12.1 开闭原则</h2>
<h2 id="5122-模板方法模式和回调机制">5.12.2 模板方法模式和回调机制</h2>
<h2 id="5123-组合模式">5.12.3 组合模式</h2>
<p><img src="data:image/jpeg;base64,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" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>4.13.3 静态导入</title>
			<link>https://HarryQing.github.io/posts/4.13.3-%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5/</link>
			<pubDate>Sun, 28 Feb 2021 20:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.13.3-%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5/</guid>
			<description>　静态导入(static import)是在JDK1.5新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。
【示例4-16】 静态导入的使用　package cn.sxt;//以下两种静态导入的方式二选一即可import static java.lang.Math.*;//导入Math类的所有静态属性import static java.lang.Math.PI;//导入Math类的PI属性public class Test2{public static void main(String [] args){System.out.println(PI);System.out.println(random());}} 　执行结果如图4-15所示。 </description>
			<content type="html"><![CDATA[<p>　　静态导入(static import)是在JDK1.5新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。</p>
<p><strong>【示例4-16】</strong> 静态导入的使用　　</p>
<pre><code>package cn.sxt;
 //以下两种静态导入的方式二选一即可
import static java.lang.Math.*;//导入Math类的所有静态属性
import static java.lang.Math.PI;//导入Math类的PI属性

public class Test2{
    public static void main(String [] args){
        System.out.println(PI);
        System.out.println(random());
    }
}
</code></pre>
<p>　　执行结果如图4-15所示。
<img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494928654561591.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>4.13.2 导入类import</title>
			<link>https://HarryQing.github.io/posts/4.13.2-%E5%AF%BC%E5%85%A5%E7%B1%BBimport/</link>
			<pubDate>Sun, 28 Feb 2021 17:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.13.2-%E5%AF%BC%E5%85%A5%E7%B1%BBimport/</guid>
			<description>　如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。
注意要点： 　1. Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。
　2. 如果导入两个同名的类，只能用包名+类名来显示调用相关类：　java.util.Date date = new java.util.Date(); 【示例4-15】 导入同名类的处理　import java.sql.Date;import java.util.*;//导入该包下所有的类。会降低编译速度，但不会降低运行速度。public class Test{public static void main(String[] args) {//这里指的是java.sql.DateDate now; //java.util.Date因为和java.sql.Date类同名，需要完整路径java.util.Date now2 = new java.util.Date();System.out.println(now2); //java.util包的非同名类不需要完整路径Scanner input = new Scanner(System.in); }} </description>
			<content type="html"><![CDATA[<p>　　如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。</p>
<h2 id="注意要点">注意要点：</h2>
<p>　　1. Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。</p>
<p>　　2. 如果导入两个同名的类，只能用包名+类名来显示调用相关类：　</p>
<pre><code>java.util.Date date  = new  java.util.Date();
</code></pre>
<p><strong>【示例4-15】</strong> 导入同名类的处理　　</p>
<pre><code>import java.sql.Date;
import java.util.*;//导入该包下所有的类。会降低编译速度，但不会降低运行速度。

public class Test{
    public static void main(String[] args) {
        //这里指的是java.sql.Date
        Date now; 
        //java.util.Date因为和java.sql.Date类同名，需要完整路径
        java.util.Date  now2 = new java.util.Date();
        System.out.println(now2);      
        //java.util包的非同名类不需要完整路径
        Scanner input = new Scanner(System.in);    
    }
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>4.13.1 JDK中的主要包</title>
			<link>https://HarryQing.github.io/posts/4.13.1-jdk%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%85/</link>
			<pubDate>Sun, 28 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.13.1-jdk%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%85/</guid>
			<description></description>
			<content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/03/14/T5rXjhMmia3gJ8u.png" alt="image.png"></p>
]]></content>
		</item>
		
		<item>
			<title>4.13 package</title>
			<link>https://HarryQing.github.io/posts/4.13-package/</link>
			<pubDate>Sat, 27 Feb 2021 23:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.13-package/</guid>
			<description>我们通过package实现对类的管理，package的使用有两个要点：
　1. 通常是类的第一句非注释性语句。
　2. 包名：域名倒着写即可，再加上模块名，便于内部管理类。
【示例4-13】 package的命名举例
com.sun.test;com.oracle.test;cn.sxt.gao.test;cn.sxt.gao.view;cn.sxt.gao.view.model; 注意事项： 　1. 写项目时都要加包，不要使用默认包。
　2. com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。
【示例4-14】 package的使用
package cn.sxt;public class Test {public static void main(String[] args) {System.out.println(&amp;quot;helloworld&amp;quot;);}} ·在eclipse项目中新建包 　在src目录上单击右键，选择new-&amp;gt;package
图4-13 创建package
　在package窗口上输入包名即可
图4-14 指定包名称
　接下来，我们就可以在包上单击右键，新建类啦!</description>
			<content type="html"><![CDATA[<p>　　我们通过package实现对类的管理，package的使用有两个要点：</p>
<p>　　1. 通常是类的第一句非注释性语句。</p>
<p>　　2. 包名：域名倒着写即可，再加上模块名，便于内部管理类。</p>
<p><strong>【示例4-13】</strong> package的命名举例</p>
<pre><code>com.sun.test;
com.oracle.test;
cn.sxt.gao.test;
cn.sxt.gao.view;
cn.sxt.gao.view.model;
</code></pre>
<h2 id="注意事项">注意事项：</h2>
<p>　　1. 写项目时都要加包，不要使用默认包。</p>
<p>　　2. com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。</p>
<p><strong>【示例4-14】</strong> package的使用</p>
<pre><code>package cn.sxt;
public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;helloworld&quot;);
    }
}
</code></pre>
<h3 id="在eclipse项目中新建包">·在eclipse项目中新建包</h3>
<p>　　在src目录上单击右键，选择new-&gt;package</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494928098161998.png" alt="enter description here"></p>
<p>图4-13 创建package</p>
<p>　　在package窗口上输入包名即可</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494928109616215.png" alt="enter description here"></p>
<p>图4-14 指定包名称</p>
<p>　　接下来，我们就可以在包上单击右键，新建类啦!</p>
]]></content>
		</item>
		
		<item>
			<title>4.12 包</title>
			<link>https://HarryQing.github.io/posts/4.12-%E5%8C%85/</link>
			<pubDate>Sat, 27 Feb 2021 22:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.12-%E5%8C%85/</guid>
			<description>包机制是Java中管理类的重要手段。 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 包对于类，相当于文件夹对于文件的作用。</description>
			<content type="html"><![CDATA[<p>　　包机制是Java中管理类的重要手段。 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 包对于类，相当于文件夹对于文件的作用。</p>
]]></content>
		</item>
		
		<item>
			<title>4.11 参数传值机制</title>
			<link>https://HarryQing.github.io/posts/4.11-%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 27 Feb 2021 20:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.11-%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC%E6%9C%BA%E5%88%B6/</guid>
			<description>Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。
· 基本数据类型参数的传值 　传递的是值的副本。 副本改变不会影响原件。
· 引用类型参数的传值 　传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。
【示例4-12】 多个变量指向同一个对象
/*** 测试参数传值机制* @author 王雪庆**/public class User4 {int id; //idString name; //账户名String pwd; //密码public User4(int id, String name) {this.id = id;this.name = name;}public void testParameterTransfer01(User4 u){u.name=&amp;quot;王雪庆&amp;quot;;}public void testParameterTransfer02(User4 u){u = new User4(200,&amp;quot;王永庆&amp;quot;);}public static void main(String[] args) {User4 u1 = new User4(100, &amp;quot;张雪&amp;quot;);u1.</description>
			<content type="html"><![CDATA[<p>　　Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。</p>
<h3 id="-基本数据类型参数的传值">· 基本数据类型参数的传值</h3>
<p>　　传递的是值的副本。 副本改变不会影响原件。</p>
<h3 id="-引用类型参数的传值">· 引用类型参数的传值</h3>
<p>　　传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。</p>
<p><strong>【示例4-12】</strong> 多个变量指向同一个对象</p>
<pre><code>/**
 * 测试参数传值机制
 * @author 王雪庆
 *
 */
public class User4 {
    int id;        //id
    String name;   //账户名
    String pwd;   //密码

    public User4(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public   void   testParameterTransfer01(User4  u){
        u.name=&quot;王雪庆&quot;;
    }

    public   void   testParameterTransfer02(User4  u){
        u  =  new  User4(200,&quot;王永庆&quot;);
    }

    public static void main(String[] args) {
        User4   u1  =  new User4(100, &quot;张雪&quot;);

        u1.testParameterTransfer01(u1); 
        System.out.println(u1.name);

        u1.testParameterTransfer02(u1);
        System.out.println(u1.name);
    }
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>4.10 静态初始化块</title>
			<link>https://HarryQing.github.io/posts/4.10-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/</link>
			<pubDate>Sat, 27 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.10-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/</guid>
			<description>　构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。
注意事项： 　静态初始化块执行顺序(学完继承再看这里)：
　1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。
　2. 构造方法执行顺序和上面顺序一样!!
【示例4-11】 static初始化块
public class User3 {int id; //idString name; //账户名String pwd; //密码static String company; //公司名称static {System.out.println(&amp;quot;执行类的初始化工作&amp;quot;);company = &amp;quot;王雪庆&amp;quot;;printCompany();} public static void printCompany(){System.out.println(company);} public static void main(String[] args) {User3 u3 = new User3();}} </description>
			<content type="html"><![CDATA[<p>　　构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。</p>
<h2 id="注意事项">注意事项：</h2>
<p>　　静态初始化块执行顺序(学完继承再看这里)：</p>
<p>　　1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。</p>
<p>　　2. 构造方法执行顺序和上面顺序一样!!</p>
<p><strong>【示例4-11】</strong> static初始化块</p>
<pre><code>public class User3 {
    int id;        //id
    String name;   //账户名
    String pwd;   //密码
    static String company; //公司名称
    static {
        System.out.println(&quot;执行类的初始化工作&quot;);
        company = &quot;王雪庆&quot;;
        printCompany();
    }  
    public static void printCompany(){
        System.out.println(company);
    }  
    public static void main(String[] args) {
        User3  u3 = new User3();
    }
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>4.9 static 关键字</title>
			<link>https://HarryQing.github.io/posts/4.9-static-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
			<pubDate>Fri, 26 Feb 2021 23:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.9-static-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
			<description>在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点：
　1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。
　2. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!!
　3. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)
　4. 在static方法中不可直接访问非static的成员。
核心要点：  static修饰的成员变量和方法，从属于类。普通变量和方法从属于对象的。 【示例4-10】 static关键字的使用
/*** 测试static关键字的用法* @author **/public class User2 {int id; // idString name; // 账户名String pwd; // 密码static String company = &amp;quot;北京尚学堂&amp;quot;; // 公司名称public User2(int id, String name) {this.id = id;this.name = name;}public void login() {printCompany();System.</description>
			<content type="html"><![CDATA[<p>　　在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点：</p>
<p>　　1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。</p>
<p>　　2. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!!</p>
<p>　　3. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)</p>
<p>　　4. 在static方法中不可直接访问非static的成员。</p>
<h2 id="核心要点">核心要点：</h2>
<pre><code>        static修饰的成员变量和方法，从属于类。

        普通变量和方法从属于对象的。
</code></pre>
<p><strong>【示例4-10】</strong> static关键字的使用</p>
<pre><code>/**
 * 测试static关键字的用法
 * @author 
 *
 */
public class User2 {
    int id; // id
    String name; // 账户名
    String pwd; // 密码

    static String company = &quot;北京尚学堂&quot;; // 公司名称


    public User2(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public void login() {
        printCompany();
        System.out.println(company); 
        System.out.println(&quot;登录：&quot; + name);
    }

    public static void printCompany() {
//         login();//调用非静态成员，编译就会报错
        System.out.println(company);
    }

    public static void main(String[] args) {
        User2 u = new User2(101, &quot;高小七&quot;);
        User2.printCompany();
        User2.company = &quot;北京阿里爷爷&quot;;
        User2.printCompany();
    }
}
</code></pre>
<p>　　运行结果如图4-9所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494927327134687.png" alt="enter description here"></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494927332527045.png" alt="enter description here"></p>
<p>图4-10 示例4-10的内存分配图</p>
]]></content>
		</item>
		
		<item>
			<title>4.8 this关键字</title>
			<link>https://HarryQing.github.io/posts/4.8-this%E5%85%B3%E9%94%AE%E5%AD%97/</link>
			<pubDate>Fri, 26 Feb 2021 22:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.8-this%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
			<description>· 对象创建的过程和this的本质 　构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步：
　1. 分配对象空间，并将对象成员变量初始化为0或空
　2. 执行属性值的显示初始化
　3. 执行构造方法
　4. 返回对象的地址给相关的变量
　this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。
this最常的用法： 　1. 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。
　2. 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。
　3. this不能用于static方法中。
【示例4-8】 this代表“当前对象”示例
public class User {int id; //idString name; //账户名String pwd; //密码public User() {}public User(int id, String name) {System.out.println(&amp;quot;正在初始化已经创建好的对象：&amp;quot;+this);this.id = id; //不写this，无法区分局部变量id和成员变量idthis.name = name;}public void login(){System.out.println(this.name+&amp;quot;,要登录！&amp;quot;); //不写this效果一样} public static void main(String[] args) {User u3 = new User(101,&amp;quot;高小七&amp;quot;);System.</description>
			<content type="html"><![CDATA[<h2 id="-对象创建的过程和this的本质">· 对象创建的过程和this的本质</h2>
<p>　　构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步：</p>
<p>　　1. 分配对象空间，并将对象成员变量初始化为0或空</p>
<p>　　2. 执行属性值的显示初始化</p>
<p>　　3. 执行构造方法</p>
<p>　　4. 返回对象的地址给相关的变量</p>
<p>　　this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。</p>
<h3 id="this最常的用法">this最常的用法：</h3>
<p>　　1.  在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。</p>
<p>　　2. 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。</p>
<p>　　3. this不能用于static方法中。</p>
<p><strong>【示例4-8】</strong> this代表“当前对象”示例</p>
<pre><code>public class User {
    int id;        //id
    String name;   //账户名
    String pwd;   //密码

    public User() {
    }
    public User(int id, String name) {
        System.out.println(&quot;正在初始化已经创建好的对象：&quot;+this);
        this.id = id;   //不写this，无法区分局部变量id和成员变量id
        this.name = name;
    }
    public void login(){
        System.out.println(this.name+&quot;,要登录！&quot;);  //不写this效果一样
    }  

    public static void main(String[] args) {
        User  u3 = new User(101,&quot;高小七&quot;);
        System.out.println(&quot;打印高小七对象：&quot;+u3);
        u3.login();
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494927000371640.png" alt="enter description here"></p>
<p>图4-8 示例4-8运行结果</p>
<p><strong>【示例4-9】</strong> this()调用重载构造方法</p>
<pre><code>public class TestThis {
    int a, b, c;

    TestThis() {
        System.out.println(&quot;正要初始化一个Hello对象&quot;);
    }
    TestThis(int a, int b) {
        // TestThis(); //这样是无法调用构造方法的！
        this(); // 调用无参的构造方法，并且必须位于第一行！
        a = a;// 这里都是指的局部变量而不是成员变量
// 这样就区分了成员变量和局部变量. 这种情况占了this使用情况大多数！
        this.a = a;
        this.b = b;
    }
    TestThis(int a, int b, int c) {
        this(a, b); // 调用带参的构造方法，并且必须位于第一行！
        this.c = c;
    }

    void sing() {
    }
    void eat() {
        this.sing(); // 调用本类中的sing();
        System.out.println(&quot;你妈妈喊你回家吃饭！&quot;);
    }

    public static void main(String[] args) {
        TestThis hi = new TestThis(2, 3);
        hi.eat();
    }
}
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>4.7.4 开发中容易造成内存泄露的操作</title>
			<link>https://HarryQing.github.io/posts/4.7.4-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AE%B9%E6%98%93%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
			<pubDate>Fri, 26 Feb 2021 21:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.7.4-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AE%B9%E6%98%93%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
			<description>建议： 　1. 在实际开发中，经常会造成系统的崩溃。如下这些操作我们应该注意这些使用场景。 请大家学完相关内容后，回头过来温习下面的内容。不要求此处掌握相关细节。
　如下四种情况时最容易造成内存泄露的场景，请大家开发时一定注意：
· 创建大量无用对象 　比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。
String str = &amp;quot;&amp;quot;;for (int i = 0; i &amp;lt; 10000; i++) { str += i; //相当于产生了10000个String对象} · 静态集合类的使用 　像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。
· 各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭 　IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。
· 监听器的使用 　释放对象时，没有删除相应的监听器。
要点： 　1. 程序员无权调用垃圾回收器。
　2. 程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能。
　3. finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。</description>
			<content type="html"><![CDATA[<h2 id="建议">建议：</h2>
<p>　　1. 在实际开发中，经常会造成系统的崩溃。如下这些操作我们应该注意这些使用场景。 请大家学完相关内容后，回头过来温习下面的内容。不要求此处掌握相关细节。</p>
<p>　　如下四种情况时最容易造成内存泄露的场景，请大家开发时一定注意：</p>
<h3 id="-创建大量无用对象">· 创建大量无用对象</h3>
<p>　　比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。</p>
<pre><code>String str = &quot;&quot;;
for (int i = 0; i &lt; 10000; i++) {   
    str += i;     //相当于产生了10000个String对象
}
</code></pre>
<h3 id="-静态集合类的使用">· 静态集合类的使用</h3>
<p>　　像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。</p>
<h3 id="-各种连接对象io流对象数据库连接对象网络连接对象未关闭">· 各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭</h3>
<p>　　IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。</p>
<h3 id="-监听器的使用">· 监听器的使用</h3>
<p>　　释放对象时，没有删除相应的监听器。</p>
<h2 id="要点">要点：</h2>
<p>　　1. 程序员无权调用垃圾回收器。</p>
<p>　　2. 程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能。</p>
<p>　　3. finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。</p>
]]></content>
		</item>
		
		<item>
			<title>4.7.3 JVM调优和Full GC</title>
			<link>https://HarryQing.github.io/posts/4.7.3-jvm%E8%B0%83%E4%BC%98%E5%92%8Cfull-gc/</link>
			<pubDate>Fri, 26 Feb 2021 20:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.7.3-jvm%E8%B0%83%E4%BC%98%E5%92%8Cfull-gc/</guid>
			<description>在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：
　1.年老代(Tenured)被写满
　2.持久代(Perm)被写满
　3.System.gc()被显式调用（程序建议GC启动，不是调用GC）
　4.上一次GC之后Heap的各域分配策略动态变化</description>
			<content type="html"><![CDATA[<p>　　在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：</p>
<p>　　1.年老代(Tenured)被写满</p>
<p>　　2.持久代(Perm)被写满</p>
<p>　　3.System.gc()被显式调用（程序建议GC启动，不是调用GC）</p>
<p>　　4.上一次GC之后Heap的各域分配策略动态变化</p>
]]></content>
		</item>
		
		<item>
			<title>4.7.2 通用的分代垃圾回收机制</title>
			<link>https://HarryQing.github.io/posts/4.7.2-%E9%80%9A%E7%94%A8%E7%9A%84%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Fri, 26 Feb 2021 17:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.7.2-%E9%80%9A%E7%94%A8%E7%9A%84%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
			<description>分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。
　1. 年轻代
　所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。
　2. 年老代
　在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。
　3. 持久代
　用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。
　·Minor GC:
　用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)
　·Major GC：
　用于清理老年代区域。
　·Full GC：
　用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。
垃圾回收过程： 　1、新创建的对象，绝大多数都会存储在Eden中，
　2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，
　然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区
　3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，
　同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
　4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，
　5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）</description>
			<content type="html"><![CDATA[<p>　　分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。</p>
<p>　　1. 年轻代</p>
<p>　　所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。</p>
<p>　　2. 年老代</p>
<p>　　在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。</p>
<p>　　3. 持久代</p>
<p>　　用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494926399617250.png" alt="enter description here"></p>
<p>　　·Minor GC:</p>
<p>　　用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)</p>
<p>　　·Major GC：</p>
<p>　　用于清理老年代区域。</p>
<p>　　·Full GC：</p>
<p>　　用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。</p>
<h2 id="垃圾回收过程">垃圾回收过程：</h2>
<p>　　1、新创建的对象，绝大多数都会存储在Eden中，</p>
<p>　　2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，</p>
<p>　　　然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区</p>
<p>　　3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，</p>
<p>　　同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。</p>
<p>　　4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，</p>
<p>　　5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）</p>
]]></content>
		</item>
		
		<item>
			<title>4.7.1 垃圾回收原理和算法</title>
			<link>https://HarryQing.github.io/posts/4.7.1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95/</link>
			<pubDate>Fri, 26 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.7.1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95/</guid>
			<description>·内存管理 　Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。
　对象空间的分配：使用new关键字创建对象即可
　对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。
·垃圾回收过程 　任何一种垃圾回收算法一般要做两件基本事情：
　1. 发现无用的对象
　2. 回收无用对象占用的内存空间。
　垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。
·垃圾回收相关算法 　1. 引用计数法
　堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。
【示例4-7】 循环引用示例　public class Student {String name;Student friend;public static void main(String[] args) {Student s1 = new Student();Student s2 = new Student();s1.friend = s2;s2.friend = s1; s1 = null;s2 = null;}} 　s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。
　2. 引用可达法(根搜索算法)</description>
			<content type="html"><![CDATA[<h2 id="内存管理">·内存管理</h2>
<p>　　Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。</p>
<p>　　对象空间的分配：使用new关键字创建对象即可</p>
<p>　　对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。</p>
<h2 id="垃圾回收过程">·垃圾回收过程</h2>
<p>　　任何一种垃圾回收算法一般要做两件基本事情：</p>
<p>　　1. 发现无用的对象</p>
<p>　　2. 回收无用对象占用的内存空间。</p>
<p>　　垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。</p>
<h2 id="垃圾回收相关算法">·垃圾回收相关算法</h2>
<p>　　1. 引用计数法</p>
<p>　　堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。</p>
<p><strong>【示例4-7】</strong> 循环引用示例　　</p>
<pre><code>public class Student {
    String name;
    Student friend;

    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student();

        s1.friend = s2;
        s2.friend = s1;        
        s1 = null;
        s2 = null;
    }
}
</code></pre>
<p>　　s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。</p>
<p>　　2. 引用可达法(根搜索算法)</p>
<p>　　程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
]]></content>
		</item>
		
		<item>
			<title>4.7 垃圾回收机制(Garbage Collection)</title>
			<link>https://HarryQing.github.io/posts/4.7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6garbage-collection/</link>
			<pubDate>Thu, 25 Feb 2021 23:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6garbage-collection/</guid>
			<description>Java引入了垃圾回收机制，令C++程序员最头疼的内存管理问题迎刃而解。Java程序员可以将更多的精力放到业务逻辑上而不是内存管理工作上，大大的提高了开发效率。</description>
			<content type="html"><![CDATA[<p>　　Java引入了垃圾回收机制，令C++程序员最头疼的内存管理问题迎刃而解。Java程序员可以将更多的精力放到业务逻辑上而不是内存管理工作上，大大的提高了开发效率。</p>
]]></content>
		</item>
		
		<item>
			<title>4.6 构造方法的重载</title>
			<link>https://HarryQing.github.io/posts/4.6-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/</link>
			<pubDate>Thu, 25 Feb 2021 22:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.6-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/</guid>
			<description>构造方法也是方法，只不过有特殊的作用而已。与普通方法一样，构造方法也可以重载。
【示例4-6】 构造方法重载(创建不同用户对象)
public class User {int id; // idString name; // 账户名String pwd; // 密码public User() {}public User(int id, String name) {super();this.id = id;this.name = name;}public User(int id, String name, String pwd) {this.id = id;this.name = name;this.pwd = pwd;}public static void main(String[] args) {User u1 = new User();User u2 = new User(101, &amp;quot;高小七&amp;quot;);User u3 = new User(100, &amp;quot;高淇&amp;quot;, &amp;quot;123456&amp;quot;); }} 雷区： 　如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。如示例4-6所示：</description>
			<content type="html"><![CDATA[<p>　　构造方法也是方法，只不过有特殊的作用而已。与普通方法一样，构造方法也可以重载。</p>
<p><strong>【示例4-6】</strong> 构造方法重载(创建不同用户对象)</p>
<pre><code>public class User {
    int id; // id
    String name; // 账户名
    String pwd; // 密码
    public User() {

    }
    public User(int id, String name) {
        super();
        this.id = id;
        this.name = name;
    }
    public User(int id, String name, String pwd) {
        this.id = id;
        this.name = name;
        this.pwd = pwd;
    }
    public static void main(String[] args) {
        User u1 = new User();
        User u2 = new User(101, &quot;高小七&quot;);
        User u3 = new User(100, &quot;高淇&quot;, &quot;123456&quot;);     
    }
}
</code></pre>
<h2 id="雷区">雷区：</h2>
<p>　　如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。如示例4-6所示：</p>
<p>　　this.id 表示属性id;id表示形参id</p>
]]></content>
		</item>
		
		<item>
			<title>4.5 构造方法</title>
			<link>https://HarryQing.github.io/posts/4.5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</link>
			<pubDate>Thu, 25 Feb 2021 21:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</guid>
			<description>构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。
声明格式：　 [修饰符] 类名(形参列表){//n条语句} 要点： 　1. 通过new关键字调用!!
　2. 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。
　3. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!
　4. 构造器的方法名必须和类名一致!
课堂练习： 　1. 定义一个“点”(Point)类用来表示二维空间中的点(有两个坐标)。要求如下：
　(1) 可以生成具有特定坐标的点对象。
　(2) 提供可以设置坐标的方法。
　(3)提供可以计算该“点”距另外一点距离的方法。
参考答案：　 class Point {double x, y;public Point(double _x, double _y) {x = _x;y = _y; }public double getDistance(Point p) {return Math.sqrt((x - p.x) * (x - p.x) + (y - p.</description>
			<content type="html"><![CDATA[<p>　　构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。</p>
<h2 id="声明格式">声明格式：　</h2>
<pre><code>[修饰符] 类名(形参列表){
    //n条语句
}
</code></pre>
<h2 id="要点">要点：</h2>
<p>　　1. 通过new关键字调用!!</p>
<p>　　2. 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。</p>
<p>　　3. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!</p>
<p>　　4. 构造器的方法名必须和类名一致!</p>
<h2 id="课堂练习">课堂练习：</h2>
<p>　　1. 定义一个“点”(Point)类用来表示二维空间中的点(有两个坐标)。要求如下：</p>
<p>　　(1) 可以生成具有特定坐标的点对象。</p>
<p>　　(2) 提供可以设置坐标的方法。</p>
<p>　　(3)提供可以计算该“点”距另外一点距离的方法。</p>
<h3 id="参考答案">参考答案：　</h3>
<pre><code>class Point {
    double x, y;
    public Point(double _x, double _y) {
        x = _x;
        y = _y;  
    }
    public double getDistance(Point p) {
        return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));
    }
}
public class TestConstructor {
    public static void main(String[] args) {
        Point p = new Point(3.0, 4.0);
        Point origin = new Point(0.0, 0.0);
        System.out.println(p.getDistance(origin));
    }
}
</code></pre>
<h2 id="作业">作业：</h2>
<p>　　1. 很多零基础同学会在这个地方开始晕菜。大家都学过内存分析，将这个程序的执行过程的内存分析画出来。如果画不出，好好再温习一下内存分析那一节课 面向对象内存分析。　　</p>
]]></content>
		</item>
		
		<item>
			<title>4.4 面向对象的内存分析</title>
			<link>https://HarryQing.github.io/posts/4.4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</link>
			<pubDate>Thu, 25 Feb 2021 20:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</guid>
			<description>为了让大家对于面向对象编程有更深入的了解，我们要对程序的执行过程中，内存到底发生了什么变化进行剖析，让大家做到“心中有数”，通过更加形象方式理解程序的执行方式。
建议： 　1. 本节课是为了让初学者更深入了解程序底层执行情况，为了完整的体现内存分析流程，会有些新的名词，比如：线程、Class对象。大家暂时可以不求甚解的了解，后期学了这两个概念再回头来看我们这篇内存分析，肯定收获会更大。
　2.学习本节，一定要结合视频学习!
　Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。
栈的特点如下： 　1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)
　2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)
　3. 栈属于线程私有，不能实现线程间的共享!
　4. 栈的存储特性是“先进后出，后进先出”
　5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间!
堆的特点如下： 　1. 堆用于存储创建好的对象和数组(数组也是对象)
　2. JVM只有一个堆，被所有线程共享
　3. 堆是一个不连续的内存空间，分配灵活，速度慢!
方法区(又叫静态区)特点如下： 　1. JVM只有一个方法区，被所有线程共享!
　2. 方法区实际也是堆，只是用于存储类、常量相关的信息!
　3. 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)
图4-4 示例4-3内存分配图</description>
			<content type="html"><![CDATA[<p>　　为了让大家对于面向对象编程有更深入的了解，我们要对程序的执行过程中，内存到底发生了什么变化进行剖析，让大家做到“心中有数”，通过更加形象方式理解程序的执行方式。</p>
<h2 id="建议">建议：</h2>
<p>　　1. 本节课是为了让初学者更深入了解程序底层执行情况，为了完整的体现内存分析流程，会有些新的名词，比如：线程、Class对象。大家暂时可以不求甚解的了解，后期学了这两个概念再回头来看我们这篇内存分析，肯定收获会更大。</p>
<p>　　2.学习本节，一定要结合视频学习!</p>
<p>　　Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。</p>
<h2 id="栈的特点如下">栈的特点如下：</h2>
<p>　　1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)</p>
<p>　　2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)</p>
<p>　　3. 栈属于线程私有，不能实现线程间的共享!</p>
<p>　　4. 栈的存储特性是“先进后出，后进先出”</p>
<p>　　5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间!</p>
<h2 id="堆的特点如下">堆的特点如下：</h2>
<p>　　1. 堆用于存储创建好的对象和数组(数组也是对象)</p>
<p>　　2. JVM只有一个堆，被所有线程共享</p>
<p>　　3. 堆是一个不连续的内存空间，分配灵活，速度慢!</p>
<h2 id="方法区又叫静态区特点如下">方法区(又叫静态区)特点如下：</h2>
<p>　　1. JVM只有一个方法区，被所有线程共享!</p>
<p>　　2. 方法区实际也是堆，只是用于存储类、常量相关的信息!</p>
<p>　　3. 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494925174358420.png" alt="enter description here"></p>
<p>图4-4 示例4-3内存分配图</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20171026/1509008324820095.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>4.3.4 一个典型类的定义和UML图</title>
			<link>https://HarryQing.github.io/posts/4.3.4-%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8Cuml%E5%9B%BE/</link>
			<pubDate>Thu, 25 Feb 2021 17:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.3.4-%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8Cuml%E5%9B%BE/</guid>
			<description>【示例4-3】 模拟学生使用电脑学习
class Computer {String brand; //品牌}public class SxtStu {// fieldint id;String sname;int age;Computer comp;void study() {System.out.println(&amp;quot;我正在学习！使用我们的电脑，&amp;quot;+comp.brand);}SxtStu() {}public static void main(String[] args) {SxtStu stu1 = new SxtStu();stu1.sname = &amp;quot;张三&amp;quot;;Computer comp1 = new Computer();comp1.brand = &amp;quot;联想&amp;quot;;stu1.comp = comp1;stu1.study();}} 执行结果： 对应的UML图如下： </description>
			<content type="html"><![CDATA[<p><strong>【示例4-3】</strong> 模拟学生使用电脑学习</p>
<pre><code>class Computer {
    String brand;  //品牌
}
public class SxtStu {
    // field
    int id;
    String sname;
    int age;
    Computer comp;
    void study() {
        System.out.println(&quot;我正在学习！使用我们的电脑，&quot;+comp.brand);
    }
    SxtStu() {
    }
    public static void main(String[] args) {
        SxtStu stu1 = new SxtStu();
        stu1.sname = &quot;张三&quot;;
        Computer comp1 = new Computer();
         comp1.brand = &quot;联想&quot;;
        stu1.comp = comp1;
        stu1.study();
    }
}
</code></pre>
<h2 id="执行结果">执行结果：</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494924993319375.png" alt="enter description here">
　　</p>
<h2 id="对应的uml图如下">对应的UML图如下：</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494924998558667.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>4.3.3 方法</title>
			<link>https://HarryQing.github.io/posts/4.3.3-%E6%96%B9%E6%B3%95/</link>
			<pubDate>Thu, 25 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.3.3-%E6%96%B9%E6%B3%95/</guid>
			<description>　方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。
方法定义格式：　 [修饰符] 方法返回值类型 方法名(形参列表) {// n条语句} </description>
			<content type="html"><![CDATA[<p>　　方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。</p>
<h3 id="方法定义格式">方法定义格式：　</h3>
<pre><code>[修饰符]  方法返回值类型  方法名(形参列表) {
    // n条语句
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>4.3.2 属性(field，或者叫成员变量)</title>
			<link>https://HarryQing.github.io/posts/4.3.2-%E5%B1%9E%E6%80%A7field%E6%88%96%E8%80%85%E5%8F%AB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</link>
			<pubDate>Wed, 24 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.3.2-%E5%B1%9E%E6%80%A7field%E6%88%96%E8%80%85%E5%8F%AB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</guid>
			<description>　属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。
　在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。
属性定义格式： [修饰符] 属性类型 属性名 = [默认值] ; </description>
			<content type="html"><![CDATA[<p>　　属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。</p>
<p>　　在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。</p>
<p><img src="https://i.loli.net/2021/03/13/qT8vO16iMrJcZVb.png" alt="image.png"></p>
<h3 id="属性定义格式">属性定义格式：</h3>
<pre><code>[修饰符]  属性类型  属性名 = [默认值] ;</code></pre>
]]></content>
		</item>
		
		<item>
			<title>4.3.1 第一个类的定义</title>
			<link>https://HarryQing.github.io/posts/4.3.1-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89/</link>
			<pubDate>Tue, 23 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.3.1-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89/</guid>
			<description>【示例4-1】 类的定义方式
// 每一个源文件必须有且只有一个public class，并且类名和文件名保持一致！public class Car { }class Tyre { // 一个Java文件可以同时定义多个class}class Engine {}class Seat {} 　上面的类定义好后，没有任何的其他信息，就跟我们拿到一张张图纸，但是纸上没有任何信息，这是一个空类，没有任何实际意义。所以，我们需要定义类的具体信息。对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。这三种成员都可以定义零个或多个。
【示例4-2】 简单的学生类编写
public class SxtStu {//属性（成员变量）int id;String sname;int age; //方法void study(){System.out.println(&amp;quot;我正在想着雪儿宝贝喔，加油，刚把爹！&amp;quot;);} //构造方法SxtStu(){}} </description>
			<content type="html"><![CDATA[<p><strong>【示例4-1】</strong> 类的定义方式</p>
<pre><code>// 每一个源文件必须有且只有一个public class，并且类名和文件名保持一致！
public class Car { 
}
class Tyre { // 一个Java文件可以同时定义多个class
}
class Engine {
}
class Seat {
}
</code></pre>
<p>　　上面的类定义好后，没有任何的其他信息，就跟我们拿到一张张图纸，但是纸上没有任何信息，这是一个空类，没有任何实际意义。所以，我们需要定义类的具体信息。对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。这三种成员都可以定义零个或多个。</p>
<p><strong>【示例4-2】</strong> 简单的学生类编写</p>
<pre><code>public class SxtStu {
    //属性（成员变量）
    int id;
    String sname;
    int age;  
    //方法
    void study(){
        System.out.println(&quot;我正在想着雪儿宝贝喔，加油，刚把爹！&quot;);
    }  
    //构造方法
   SxtStu(){
   }
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>4.3 对象和类的概念</title>
			<link>https://HarryQing.github.io/posts/4.3-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
			<pubDate>Mon, 22 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.3-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
			<description>我们人认识世界，其实就是面向对象的(此对象可不是男女谈对象的彼对象呀)。比如现在让大家认识一下“天使”这个新事物，天使大家没见过吧，怎么样认识呢?最好的办法就是，给你们面前摆4个天使，带翅膀的美女，让大家看，看完以后，即使我不说，大家下一次是不是就都认识天使了。
　但是，看完10个天使后，我们总要总结一下，什么样的东东才算天使?天使是无数的，总有没见过的!所以必须总结抽象，便于认识未知事物!总结的过程就是抽象的过程。小时候，我们学自然数时怎么定义的?像1，2，3，4…这样的数就叫做自然数。 通过抽象，我们发现天使有这样一下特征：
　1. 带翅膀(带翅膀不一定是天使，还可能是鸟人)
　2. 女孩(天使掉下来脸着地，也是天使!)
　3. 善良
　4. 头上有光环
　那么通过这4个具体的天使，我们进行抽象，抽象出了天使的特征，我们也可以归纳一个天使类。 通过这个过程，类就是对象的抽象。
　类可以看做是一个模版，或者图纸，系统根据类的定义来造出对象。我们要造一个汽车，怎么样造?类就是这个图纸，规定了汽车的详细信息，然后根据图纸将汽车造出来。
　类： 我们叫做class。对象： 我们叫做Object,instance(实例)。以后我们说某个类的对象，某个类的实例。是一样的意思。
总结 　1.对象是具体的事物;类是对对象的抽象;
　2.类可以看成一类对象的模板，对象可以看成该类的一个具体实例。
　3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。</description>
			<content type="html"><![CDATA[<p>　　我们人认识世界，其实就是面向对象的(此对象可不是男女谈对象的彼对象呀)。比如现在让大家认识一下“天使”这个新事物，天使大家没见过吧，怎么样认识呢?最好的办法就是，给你们面前摆4个天使，带翅膀的美女，让大家看，看完以后，即使我不说，大家下一次是不是就都认识天使了。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494924270913105.png" alt="enter description here"></p>
<p>　　但是，看完10个天使后，我们总要总结一下，什么样的东东才算天使?天使是无数的，总有没见过的!所以必须总结抽象，便于认识未知事物!总结的过程就是抽象的过程。小时候，我们学自然数时怎么定义的?像1，2，3，4…这样的数就叫做自然数。 通过抽象，我们发现天使有这样一下特征：</p>
<p>　　1. 带翅膀(带翅膀不一定是天使，还可能是鸟人)</p>
<p>　　2. 女孩(天使掉下来脸着地，也是天使!)</p>
<p>　　3. 善良</p>
<p>　　4. 头上有光环</p>
<p>　　那么通过这4个具体的天使，我们进行抽象，抽象出了天使的特征，我们也可以归纳一个天使类。 通过这个过程，类就是对象的抽象。</p>
<p>　　类可以看做是一个模版，或者图纸，系统根据类的定义来造出对象。我们要造一个汽车，怎么样造?类就是这个图纸，规定了汽车的详细信息，然后根据图纸将汽车造出来。</p>
<p>　　<strong>类：</strong> 我们叫做class。<strong>对象：</strong> 我们叫做Object,instance(实例)。以后我们说某个类的对象，某个类的实例。是一样的意思。</p>
<h2 id="总结">总结</h2>
<p>　　1.对象是具体的事物;类是对对象的抽象;</p>
<p>　　2.类可以看成一类对象的模板，对象可以看成该类的一个具体实例。</p>
<p>　　3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。</p>
]]></content>
		</item>
		
		<item>
			<title>4.2 对象的进化史(数据管理和企业管理共通之处)</title>
			<link>https://HarryQing.github.io/posts/4.2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%9B%E5%8C%96%E5%8F%B2%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86%E5%85%B1%E9%80%9A%E4%B9%8B%E5%A4%84/</link>
			<pubDate>Sun, 21 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%9B%E5%8C%96%E5%8F%B2%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86%E5%85%B1%E9%80%9A%E4%B9%8B%E5%A4%84/</guid>
			<description>事物的发展总是遵循“量变引起质变”的哲学原则;企业管理和数据管理、甚至社会管理也有很多共通的地方。本节课类比企业发展，让大家更容易理解为什么会产生“对象”这个概念。
·数据无管理时代 　最初的计算机语言只有基本变量(类似我们学习的基本数据类型)，用来保存数据。那时候面对的数据非常简单，只需要几个变量即可搞定;这个时候不涉及“数据管理”的问题。同理，就像在企业最初发展阶段只有几个人，不涉及管理问题，大家闷头做事就OK了。
·数组管理和企业部门制 　企业发展中，员工多了怎么办?我们很自然的想法就是归类，将类型一致的人放到一起;企业中，会将都做销售工作的放到销售部管理;会将研发软件的放到开发部管理。同理在编程中，变量多了，我们很容易的想法就是“将同类型数据放到一起”， 于是就形成了“数组”的概念，单词对应“array”。 这种“归类”的思想，便于管理数据、管理人。
·对象和企业项目制 　企业继续发展，面对的场景更加复杂。一个项目可能需要经常协同多个部门才能完成工作;一个项目从谈判接触可能需要销售部介入;谈判完成后，需求调研开始，研发部和销售部一起介入;开发阶段需要开发部和测试部互相配合敏捷开发，同时整个过程财务部也需要跟进。在企业中，为了便于协作和管理，很自然就兴起了“项目制”，以项目组的形式组织，一个项目组可能包含各种类型的人员。 一个完整的项目组，麻雀虽小五脏俱全，就是个创业公司甚至小型公司的编制，包含行政后勤人员、财务核算人员、开发人员、售前人员、售后人员、测试人员、设计人员等等。事实上，华为、腾讯、阿里巴巴等大型公司内部都是采用这种“项目制”的方式进行管理。
　同理，计算机编程继续发展，各种类型的变量更加多了，而且对数据的操作(指的就是方法，方法可以看做是对数据操作的管理)也复杂了，怎么办?
　为了便于协作和管理，我们“将相关数据和相关方法封装到一个独立的实体”，于是“对象”产生了。 比如，我们的一个学生对象：
　有属性(静态特征)：年龄：18，姓名：雪庆，学号：1234
　也可以有方法(动态行为)：看雪，陪雪，爱雪
　请大家举一反三，根据上表理解一下企业的进化史，会发现大道至简。原来，数据管理、企业管理、社会发展也是有很多共通的地方。“量变引起质变，不同的数量级必然采用不同的管理模式”。
总结 　1.对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。
　2.在内存上，对象就是一个内存块，存放了相关的数据集合!
　3.对象的本质就一种数据的组织方式!</description>
			<content type="html"><![CDATA[<p>　　事物的发展总是遵循“量变引起质变”的哲学原则;企业管理和数据管理、甚至社会管理也有很多共通的地方。本节课类比企业发展，让大家更容易理解为什么会产生“对象”这个概念。</p>
<h2 id="数据无管理时代">·数据无管理时代</h2>
<p>　　最初的计算机语言只有基本变量(类似我们学习的基本数据类型)，用来保存数据。那时候面对的数据非常简单，只需要几个变量即可搞定;这个时候不涉及“数据管理”的问题。同理，就像在企业最初发展阶段只有几个人，不涉及管理问题，大家闷头做事就OK了。</p>
<h2 id="数组管理和企业部门制">·数组管理和企业部门制</h2>
<p>　　企业发展中，员工多了怎么办?我们很自然的想法就是归类，将类型一致的人放到一起;企业中，会将都做销售工作的放到销售部管理;会将研发软件的放到开发部管理。同理在编程中，变量多了，我们很容易的想法就是“将同类型数据放到一起”， 于是就形成了“数组”的概念，单词对应“array”。 这种“归类”的思想，便于管理数据、管理人。</p>
<h2 id="对象和企业项目制">·对象和企业项目制</h2>
<p>　　企业继续发展，面对的场景更加复杂。一个项目可能需要经常协同多个部门才能完成工作;一个项目从谈判接触可能需要销售部介入;谈判完成后，需求调研开始，研发部和销售部一起介入;开发阶段需要开发部和测试部互相配合敏捷开发，同时整个过程财务部也需要跟进。在企业中，为了便于协作和管理，很自然就兴起了“项目制”，以项目组的形式组织，一个项目组可能包含各种类型的人员。 一个完整的项目组，麻雀虽小五脏俱全，就是个创业公司甚至小型公司的编制，包含行政后勤人员、财务核算人员、开发人员、售前人员、售后人员、测试人员、设计人员等等。事实上，华为、腾讯、阿里巴巴等大型公司内部都是采用这种“项目制”的方式进行管理。</p>
<p>　　同理，计算机编程继续发展，各种类型的变量更加多了，而且对数据的操作(指的就是方法，方法可以看做是对数据操作的管理)也复杂了，怎么办?</p>
<p>　　为了便于协作和管理，我们“将相关数据和相关方法封装到一个独立的实体”，于是“对象”产生了。 比如，我们的一个学生对象：</p>
<p>　　有属性(静态特征)：年龄：18，姓名：雪庆，学号：1234</p>
<p>　　也可以有方法(动态行为)：看雪，陪雪，爱雪</p>
<p>　　请大家举一反三，根据上表理解一下企业的进化史，会发现大道至简。原来，数据管理、企业管理、社会发展也是有很多共通的地方。“量变引起质变，不同的数量级必然采用不同的管理模式”。</p>
<p><img src="https://i.loli.net/2021/03/13/FzquH12sDbvYSCW.png" alt="image.png"></p>
<h2 id="总结">总结</h2>
<p>　　1.对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。</p>
<p>　　2.在内存上，对象就是一个内存块，存放了相关的数据集合!</p>
<p>　　3.对象的本质就一种数据的组织方式!</p>
]]></content>
		</item>
		
		<item>
			<title>4.1 面向过程和面向对象</title>
			<link>https://HarryQing.github.io/posts/4.1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
			<pubDate>Sat, 20 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/4.1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
			<description>面向过程(Procedure Oriented)和面向对象(Object Oriented,OO)都是对软件分析、设计和开发的一种思想,它指导着人们以不同的方式去分析、设计和开发软件。早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的弊端越来越明显的显示出来，出现了面向对象思想并成为目前主流的方式。两者都贯穿于软件分析、设计和开发各个阶段，对应面向对象就分别称为面向对象分析(OOA)、面向对象设计(OOD)和面向对象编程(OOP)。C语言是一种典型的面向过程语言，Java是一种典型的面向对象语言。
　面向过程思想思考问题时，我们首先思考“怎么按步骤实现?”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车?我们很容易就列出实现步骤：
　1. 发动车 2. 挂挡 3.踩油门 4. 走你
　面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车?”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。
　面向对象(Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物?” 比如思考造车，我们就会先思考“车怎么设计?”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。
　一、面向对象思想思考造车，发现车由如下对象组成：
　1. 轮胎
　2. 发动机
　3. 车壳
　4. 座椅
　5. 挡风玻璃
　为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤;这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想!
　因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作(就是一个个方法)，仍然需要面向过程的思路去处理。
　我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程!
面向对象和面向过程的总结 　1、都是解决问题的思维方式，都是代码组织的方式。
　2、解决简单问题可以使用面向过程
　3、解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。
面向对象思考方式 　遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。
建议 　1.面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。
　2.一个经典的比喻：面向对象是盖浇饭、面向过程是蛋炒饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。</description>
			<content type="html"><![CDATA[<p>　　面向过程(Procedure Oriented)和面向对象(Object Oriented,OO)都是对软件分析、设计和开发的一种思想,它指导着人们以不同的方式去分析、设计和开发软件。早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的弊端越来越明显的显示出来，出现了面向对象思想并成为目前主流的方式。两者都贯穿于软件分析、设计和开发各个阶段，对应面向对象就分别称为面向对象分析(OOA)、面向对象设计(OOD)和面向对象编程(OOP)。C语言是一种典型的面向过程语言，Java是一种典型的面向对象语言。</p>
<p>　　面向过程思想思考问题时，我们首先思考“怎么按步骤实现?”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车?我们很容易就列出实现步骤：</p>
<p>　　1. 发动车 
　　2. 挂挡 
　　3.踩油门 
　　4. 走你</p>
<p>　　面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车?”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。</p>
<p>　　面向对象(Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物?” 比如思考造车，我们就会先思考“车怎么设计?”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。</p>
<p>　　一、面向对象思想思考造车，发现车由如下对象组成：</p>
<p>　　1. 轮胎</p>
<p>　　2. 发动机</p>
<p>　　3. 车壳</p>
<p>　　4. 座椅</p>
<p>　　5. 挡风玻璃</p>
<p>　　为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤;这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想!</p>
<p>　　因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作(就是一个个方法)，仍然需要面向过程的思路去处理。</p>
<p>　　我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程!</p>
<h2 id="面向对象和面向过程的总结">面向对象和面向过程的总结</h2>
<p>　　1、都是解决问题的思维方式，都是代码组织的方式。</p>
<p>　　2、解决简单问题可以使用面向过程</p>
<p>　　3、解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。</p>
<h2 id="面向对象思考方式">面向对象思考方式</h2>
<p>　　遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。</p>
<h2 id="建议">建议</h2>
<p>　　1.面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。</p>
<p>　　2.一个经典的比喻：面向对象是盖浇饭、面向过程是蛋炒饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。</p>
]]></content>
		</item>
		
		<item>
			<title>第四章 Java面对对象基础</title>
			<link>https://HarryQing.github.io/posts/%E7%AC%AC%E5%9B%9B%E7%AB%A0-java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Wed, 17 Feb 2021 18:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/%E7%AC%AC%E5%9B%9B%E7%AB%A0-java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</guid>
			<description>目录 4.1 面向过程和面向对象 4.2 对象的进化史(数据管理和企业管理共通之处) 4.3 对象和类的概念 4.3.1 第一个类的定义 4.3.2 属性(field，或者叫成员变量) 4.3.3 方法 4.3.4 一个典型类的定义和UML图 4.4 面向对象的内存分析 4.5 构造方法 4.6 构造方法的重载 4.7 垃圾回收机制(Garbage Collection) 4.7.1 垃圾回收原理和算法 4.7.2 通用的分代垃圾回收机制 4.7.3 JVM调优和Full GC 4.7.4 开发中容易造成内存泄露的操作 4.9 static 关键字 4.10 静态初始化块 4.11 参数传值机制 4.12 包 4.13 package 4.13.1 JDK中的主要包 4.13.2 导入类import 4.13.3 静态导入 </description>
			<content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="41-面向过程和面向对象">4.1 面向过程和面向对象</h2>
<h2 id="42-对象的进化史数据管理和企业管理共通之处">4.2 对象的进化史(数据管理和企业管理共通之处)</h2>
<h2 id="43-对象和类的概念">4.3 对象和类的概念</h2>
<h2 id="431-第一个类的定义">4.3.1 第一个类的定义</h2>
<h2 id="432-属性field或者叫成员变量">4.3.2 属性(field，或者叫成员变量)</h2>
<h2 id="433-方法">4.3.3 方法</h2>
<h2 id="434-一个典型类的定义和uml图">4.3.4 一个典型类的定义和UML图</h2>
<h2 id="44-面向对象的内存分析">4.4 面向对象的内存分析</h2>
<h2 id="45-构造方法">4.5 构造方法</h2>
<h2 id="46-构造方法的重载">4.6 构造方法的重载</h2>
<h2 id="47-垃圾回收机制garbage-collection">4.7 垃圾回收机制(Garbage Collection)</h2>
<h2 id="471-垃圾回收原理和算法">4.7.1 垃圾回收原理和算法</h2>
<h2 id="472-通用的分代垃圾回收机制">4.7.2 通用的分代垃圾回收机制</h2>
<h2 id="473-jvm调优和full-gc">4.7.3 JVM调优和Full GC</h2>
<h2 id="474-开发中容易造成内存泄露的操作">4.7.4 开发中容易造成内存泄露的操作</h2>
<h2 id="49-static-关键字">4.9 static 关键字</h2>
<h2 id="410-静态初始化块">4.10 静态初始化块</h2>
<h2 id="411-参数传值机制">4.11 参数传值机制</h2>
<h2 id="412-包">4.12 包</h2>
<h2 id="413-package">4.13 package</h2>
<h2 id="4131-jdk中的主要包">4.13.1 JDK中的主要包</h2>
<h2 id="4132-导入类import">4.13.2 导入类import</h2>
<h2 id="4133-静态导入">4.13.3 静态导入</h2>
<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1666491998,3961460638&amp;fm=26&amp;gp=0.jpg" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>3.6 递归结构</title>
			<link>https://HarryQing.github.io/posts/3.6-%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84/</link>
			<pubDate>Wed, 17 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.6-%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84/</guid>
			<description>递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。
利用递归可以用简单的程序来解决一些复杂的问题。比如：斐波那契数列的计算、汉诺塔、快排等问题。
递归结构包括两个部分： 1.定义递归头。解答：什么时候不调用自身方法。如果没有头，将陷入死循环，也就是递归的结束条件。
2.递归体。解答：什么时候需要调用自身方法。
【示例3-22】 递归：计算n!　public class Test22 {public static void main(String[] args) {long d1 = System.currentTimeMillis(); System.out.printf(&amp;quot;%d阶乘的结果:%s%n&amp;quot;, 10, factorial(10));long d2 = System.currentTimeMillis();System.out.printf(&amp;quot;递归费时：%s%n&amp;quot;, d2-d1); //耗时：32ms}/** 求阶乘的方法*/static long factorial(int n){if(n==1){//递归头return 1;}else{//递归体return n*factorial(n-1);//n! = n * (n-1)!}}} 图3-27 示例3-22运行效果图
图3-28 递归原理分析图
递归的缺陷 1.简单的程序是递归的优点之一。但是递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。
2.比如上面的递归耗时558ms。但是用普通循环的话快得多，如示例3-23所示。
【示例3-23】 使用循环求n!　public class Test23 {public static void main(String[] args) {long d3 = System.</description>
			<content type="html"><![CDATA[<p>递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。</p>
<p>利用递归可以用简单的程序来解决一些复杂的问题。比如：斐波那契数列的计算、汉诺塔、快排等问题。</p>
<h3 id="递归结构包括两个部分">递归结构包括两个部分：</h3>
<p>1.定义递归头。解答：什么时候不调用自身方法。如果没有头，将陷入死循环，也就是递归的结束条件。</p>
<p>2.递归体。解答：什么时候需要调用自身方法。</p>
<p><strong>【示例3-22】</strong> 递归：计算n!　　</p>
<pre><code>public class Test22 {
    public static void main(String[] args) {
        long d1 = System.currentTimeMillis();  
        System.out.printf(&quot;%d阶乘的结果:%s%n&quot;, 10, factorial(10));
        long d2 = System.currentTimeMillis();
        System.out.printf(&quot;递归费时：%s%n&quot;, d2-d1);  //耗时：32ms
    }
    /** 求阶乘的方法*/
    static long  factorial(int n){
        if(n==1){//递归头
            return 1;
        }else{//递归体
            return n*factorial(n-1);//n! = n * (n-1)!
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494921671901397.png" alt="enter description here"></p>
<p>图3-27 示例3-22运行效果图</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494921676253834.png" alt="enter description here"></p>
<p>图3-28 递归原理分析图</p>
<h2 id="递归的缺陷">递归的缺陷</h2>
<p>1.简单的程序是递归的优点之一。但是递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。</p>
<p>2.比如上面的递归耗时558ms。但是用普通循环的话快得多，如示例3-23所示。</p>
<p><strong>【示例3-23】</strong> 使用循环求n!　</p>
<pre><code>public class Test23 {
    public static void main(String[] args) {
        long d3 = System.currentTimeMillis();
        int a = 10;
        int result = 1;
        while (a &gt; 1) {
            result *= a * (a - 1);
            a -= 2;
        }
        long d4 = System.currentTimeMillis();
        System.out.println(result);
        System.out.printf(&quot;普通循环费时：%s%n&quot;, d4 - d3);
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494921739716261.png" alt="enter description here"></p>
<h2 id="注意事项">注意事项</h2>
<p>任何能用递归解决的问题也能使用迭代解决。当递归方法可以更加自然地反映问题，并且易于理解和调试，并且不强调效率问题时，可以采用递归;</p>
<p>在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存。</p>
]]></content>
		</item>
		
		<item>
			<title>3.5 方法的重载(overload)</title>
			<link>https://HarryQing.github.io/posts/3.5-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BDoverload/</link>
			<pubDate>Tue, 16 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.5-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BDoverload/</guid>
			<description>方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。
雷区  重载的方法，实际是完全不同的方法，只是名称相同而已!构成方法重载的条件：1.不同的含义：形参类型、形参个数、形参顺序不同2.只有返回值不同不构成方法的重载如：int a(String str){}与 void a(String str){}不构成方法重载3.只有形参的名称不同，不构成方法的重载如：int a(String str){}与int a(String s){}不构成方法重载 【示例3-21】 方法重载
public class Test21 {public static void main(String[] args) {System.out.println(add(3, 5));// 8System.out.println(add(3, 5, 10));// 18System.out.println(add(3.0, 5));// 8.0System.out.println(add(3, 5.0));// 8.0// 我们已经见过的方法的重载System.out.println();// 0个参数System.out.println(1);// 参数是1个intSystem.out.println(3.0);// 参数是1个double}/** 求和的方法 */public static int add(int n1, int n2) {int sum = n1 + n2;return sum;}// 方法名相同，参数个数不同，构成重载public static int add(int n1, int n2, int n3) {int sum = n1 + n2 + n3;return sum;}// 方法名相同，参数类型不同，构成重载public static double add(double n1, int n2) {double sum = n1 + n2;return sum;}// 方法名相同，参数顺序不同，构成重载public static double add(int n1, double n2) {double sum = n1 + n2;return sum;}//编译错误：只有返回值不同，不构成方法的重载public static double add(int n1, int n2) {double sum = n1 + n2;return sum;}//编译错误：只有参数名称不同，不构成方法的重载public static int add(int n2, int n1) {double sum = n1 + n2; return sum;} } </description>
			<content type="html"><![CDATA[<p>方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。</p>
<h2 id="雷区">雷区</h2>
<pre><code>  重载的方法，实际是完全不同的方法，只是名称相同而已!

  构成方法重载的条件：

  1.不同的含义：形参类型、形参个数、形参顺序不同

  2.只有返回值不同不构成方法的重载
  如：
int a(String str){}与 void a(String str){}
      不构成方法重载

  3.只有形参的名称不同，不构成方法的重载
  如：
int a(String str){}与int a(String s){}
      不构成方法重载
</code></pre>
<p><strong>【示例3-21】</strong> 方法重载</p>
<pre><code>public class Test21 {
    public static void main(String[] args) {
        System.out.println(add(3, 5));// 8
        System.out.println(add(3, 5, 10));// 18
        System.out.println(add(3.0, 5));// 8.0
        System.out.println(add(3, 5.0));// 8.0
        // 我们已经见过的方法的重载
        System.out.println();// 0个参数
        System.out.println(1);// 参数是1个int
        System.out.println(3.0);// 参数是1个double
    }
    /** 求和的方法 */
    public static int add(int n1, int n2) {
        int sum = n1 + n2;
        return sum;
    }
    // 方法名相同，参数个数不同，构成重载
    public static int add(int n1, int n2, int n3) {
        int sum = n1 + n2 + n3;
        return sum;
    }
    // 方法名相同，参数类型不同，构成重载
    public static double add(double n1, int n2) {
        double sum = n1 + n2;
        return sum;
    }
    // 方法名相同，参数顺序不同，构成重载
    public static double add(int n1, double n2) {
        double sum = n1 + n2;
        return sum;
    }
    //编译错误：只有返回值不同，不构成方法的重载
    public static double add(int n1, int n2) {
        double sum = n1 + n2;
        return sum;
    }
    //编译错误：只有参数名称不同，不构成方法的重载
    public static int add(int n2, int n1) {
        double sum = n1 + n2;         
        return sum;
    }  
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>3.4 方法</title>
			<link>https://HarryQing.github.io/posts/3.4-%E6%96%B9%E6%B3%95/</link>
			<pubDate>Mon, 15 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.4-%E6%96%B9%E6%B3%95/</guid>
			<description>方法就是一段用来完成特定功能的代码片段，类似于其它语言的函数。
方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。
方法声明格式： [修饰符1 修饰符2 …] 返回值类型 方法名(形式参数列表){Java语句；… … …} 方法的调用方式：  对象名.方法名(实参列表)方法的详细说明1. 形式参数：在方法声明时用于接收外界传入的数据。2. 实参：调用方法时实际传给方法的数据。3. 返回值：方法在执行完毕后返还给调用它的环境的数据。4. 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。 【示例3-20】 方法的声明及调用
public class Test20 {/** main方法：程序的入口 */public static void main(String[] args) {int num1 = 10;int num2 = 20;//调用求和的方法：将num1与num2的值传给add方法中的n1与n2// 求完和后将结果返回，用sum接收结果int sum = add(num1, num2);System.out.println(&amp;quot;sum = &amp;quot; + sum);//输出：sum = 30//调用打印的方法：该方法没有返回值print();}/** 求和的方法 */public static int add(int n1, int n2) {int sum = n1 + n2;return sum;//使用return返回计算的结果}/** 打印的方法 */public static void print() {System.</description>
			<content type="html"><![CDATA[<p>方法就是一段用来完成特定功能的代码片段，类似于其它语言的函数。</p>
<p>方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。</p>
<h2 id="方法声明格式">方法声明格式：</h2>
<pre><code>[修饰符1  修饰符2  …]   返回值类型    方法名(形式参数列表){
    Java语句；… … …
 }
</code></pre>
<h2 id="方法的调用方式">方法的调用方式：</h2>
<pre><code>  对象名.方法名(实参列表)

  方法的详细说明

  1. 形式参数：在方法声明时用于接收外界传入的数据。

  2. 实参：调用方法时实际传给方法的数据。

  3. 返回值：方法在执行完毕后返还给调用它的环境的数据。

  4. 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。
</code></pre>
<p><strong>【示例3-20】</strong> 方法的声明及调用</p>
<pre><code>public class Test20 {
    /** main方法：程序的入口 */
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 20;
        //调用求和的方法：将num1与num2的值传给add方法中的n1与n2
        // 求完和后将结果返回，用sum接收结果
        int sum = add(num1, num2);
        System.out.println(&quot;sum = &quot; + sum);//输出：sum = 30
        //调用打印的方法：该方法没有返回值
        print();
    }
    /** 求和的方法 */
    public static int add(int n1, int n2) {
        int sum = n1 + n2;
        return sum;//使用return返回计算的结果
    }
    /** 打印的方法 */
    public static void print() {
        System.out.println(&quot;北京尚学堂...&quot;);
    }
}
</code></pre>
<p>　　</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494921229311723.png" alt="enter description here"></p>
<h2 id="注意事项">注意事项</h2>
<pre><code>  1. 实参的数目、数据类型和次序必须和所调用的方法声明的形式参数列表匹配。

  2. return 语句终止方法的运行并指定要返回的数据。

  3. Java中进行方法调用中传递参数时，遵循值传递的原则(传递的都是数据的副本)：

  4. 基本类型传递的是该数据值的copy值。

  5. 引用类型传递的是该对象引用的copy值，但指向的是同一个对象。</code></pre>
]]></content>
		</item>
		
		<item>
			<title>3.3 语句块</title>
			<link>https://HarryQing.github.io/posts/3.3-%E8%AF%AD%E5%8F%A5%E5%9D%97/</link>
			<pubDate>Sun, 14 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.3-%E8%AF%AD%E5%8F%A5%E5%9D%97/</guid>
			<description>语句块(有时叫做复合语句)，是用花括号扩起的任意数量的简单Java语句。块确定了局部变量的作用域。块中的程序代码，作为一个整体，是要被一起执行的。块可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中定义的变量，因为语句块中定义的变量作用域只限于语句块。
【示例3-19】 语句块　public class Test19 {public static void main(String[] args) {int n;int a;{int k;int n; //编译错误：不能重复定义变量n} //变量k的作用域到此为止}} </description>
			<content type="html"><![CDATA[<p>语句块(有时叫做复合语句)，是用花括号扩起的任意数量的简单Java语句。块确定了局部变量的作用域。块中的程序代码，作为一个整体，是要被一起执行的。块可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中定义的变量，因为语句块中定义的变量作用域只限于语句块。</p>
<p><strong>【示例3-19】</strong> 语句块　</p>
<pre><code>public class Test19 {
    public static void main(String[] args) {
        int n;
        int a;
        {
            int k;
            int n; //编译错误：不能重复定义变量n
        } //变量k的作用域到此为止
    }
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>3.2.6 带标签的break和continue</title>
			<link>https://HarryQing.github.io/posts/3.2.6-%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84break%E5%92%8Ccontinue/</link>
			<pubDate>Sat, 13 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.2.6-%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84break%E5%92%8Ccontinue/</guid>
			<description>goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在Java语言中得到正式使用;Java没有goto语句。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子&amp;mdash;带标签的break和continue。
“标签”是指后面跟一个冒号的标识符，例如：“label:”。对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。
在 “goto有害”论中，最有问题的就是标签，而非goto， 随着标签在一个程序里数量的增多，产生错误的机会也越来越多。 但Java标签不会造成这方面的问题，因为它们的活动场所已被限死，不可通过特别的方式到处传递程序的控制权。由此也引出了一个有趣的问题：通过限制语句的能力，反而能使一项语言特性更加有用。
【示例3-18】 带标签break和continue：控制嵌套循环跳转(打印101-150之间所有的质数)
public class Test18 {public static void main(String args[]) {outer: for (int i = 101; i &amp;lt; 150; i++) {for (int j = 2; j &amp;lt; i / 2; j++) {if (i % j == 0){continue outer;}}System.out.print(i + &amp;quot; &amp;quot;);}}} </description>
			<content type="html"><![CDATA[<p>goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在Java语言中得到正式使用;Java没有goto语句。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子&mdash;带标签的break和continue。</p>
<p>“标签”是指后面跟一个冒号的标识符，例如：“label:”。对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。</p>
<p>在 “goto有害”论中，最有问题的就是标签，而非goto， 随着标签在一个程序里数量的增多，产生错误的机会也越来越多。 但Java标签不会造成这方面的问题，因为它们的活动场所已被限死，不可通过特别的方式到处传递程序的控制权。由此也引出了一个有趣的问题：通过限制语句的能力，反而能使一项语言特性更加有用。</p>
<p><strong>【示例3-18】</strong> 带标签break和continue：控制嵌套循环跳转(打印101-150之间所有的质数)</p>
<pre><code>public class Test18 {
    public static void main(String args[]) {
        outer: for (int i = 101; i &lt; 150; i++) {
            for (int j = 2; j &lt; i / 2; j++) {
                if (i % j == 0){
                    continue outer;
                }
            }
            System.out.print(i + &quot;  &quot;);
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494920764681803.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>3.2.5 break语句和continue语句</title>
			<link>https://HarryQing.github.io/posts/3.2.5-break%E8%AF%AD%E5%8F%A5%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5/</link>
			<pubDate>Fri, 12 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.2.5-break%E8%AF%AD%E5%8F%A5%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5/</guid>
			<description>在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。
【示例3-16】 break语句
public class Test16 {public static void main(String[] args) {int total = 0;//定义计数器System.out.println(&amp;quot;Begin&amp;quot;);while (true) {total++;//每循环一次计数器加1int i = (int) Math.round(100 * Math.random());//当i等于88时，退出循环if (i == 88) {break;}}//输出循环的次数System.out.println(&amp;quot;Game over， used &amp;quot; + total + &amp;quot; times.&amp;quot;);}} 　continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。
注意事项   continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。
  continue用在for循环中，跳到for循环的迭代因子部分。
  【示例3-17】 continue语句：把100~150之间不能被3整除的数输出，并且每行输出5个
public class Test17 {public static void main(String[] args) {int count = 0;//定义计数器for (int i = 100; i &amp;lt; 150; i++) {//如果是3的倍数，则跳过本次循环，继续进行下一次循环if (i % 3 == 0){continue;}//否则（不是3的倍数），输出该数System.</description>
			<content type="html"><![CDATA[<p>在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。</p>
<p><strong>【示例3-16】</strong> break语句</p>
<pre><code>public class Test16 {
    public static void main(String[] args) {
        int total = 0;//定义计数器
        System.out.println(&quot;Begin&quot;);
        while (true) {
            total++;//每循环一次计数器加1
            int i = (int) Math.round(100 * Math.random());
            //当i等于88时，退出循环
            if (i == 88) {
                break;
            }
        }
        //输出循环的次数
        System.out.println(&quot;Game over， used &quot; + total + &quot; times.&quot;);
    }
}
</code></pre>
<p>　　</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494920487770900.png" alt="enter description here"></p>
<p>continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>
<p>continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。</p>
</li>
<li>
<p>continue用在for循环中，跳到for循环的迭代因子部分。</p>
</li>
</ol>
<p><strong>【示例3-17】</strong> continue语句：把100~150之间不能被3整除的数输出，并且每行输出5个</p>
<pre><code>public class Test17 {
    public static void main(String[] args) {
        int count = 0;//定义计数器
        for (int i = 100; i &lt; 150; i++) {
            //如果是3的倍数，则跳过本次循环，继续进行下一次循环
            if (i % 3 == 0){
                continue;
            }
            //否则（不是3的倍数），输出该数
            System.out.print(i + &quot;、&quot;);
            count++;//没输出一个数，计数器加1
            //根据计数器判断每行是否已经输出了5个数
            if (count % 5 == 0) {
                System.out.println();
            }
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494920557116706.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>3.2.4 嵌套循环</title>
			<link>https://HarryQing.github.io/posts/3.2.4-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF/</link>
			<pubDate>Thu, 11 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.2.4-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF/</guid>
			<description>在一个循环语句内部再嵌套一个或多个循环，称为嵌套循环。while、do-while与for循环可以任意嵌套多层。
【示例3-14】 嵌套循环　public class Test14 {public static void main(String args[]) {for (int i=1; i &amp;lt;=5; i++) {for(int j=1; j&amp;lt;=5; j++){System.out.print(i+&amp;quot; &amp;quot;);}System.out.println();}}} 【示例3-15】 使用嵌套循环实现九九乘法表
public class Test15 {public static void main(String args[]) {for (int i = 1; i &amp;lt; 10; i++) { // i是一个乘数for (int j = 1; j &amp;lt;= i; j++) { // j是另一个乘数System.out.print(j + &amp;quot;*&amp;quot; + i + &amp;quot;=&amp;quot; + (i * j &amp;lt; 10 ?</description>
			<content type="html"><![CDATA[<p>在一个循环语句内部再嵌套一个或多个循环，称为嵌套循环。while、do-while与for循环可以任意嵌套多层。</p>
<p><strong>【示例3-14】</strong> 嵌套循环　</p>
<pre><code>public class Test14 {
    public static void main(String args[]) {
        for (int i=1; i &lt;=5; i++) {
            for(int j=1; j&lt;=5; j++){
                System.out.print(i+&quot;  &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494920185494188.png" alt="enter description here"></p>
<p><strong>【示例3-15】</strong> 使用嵌套循环实现九九乘法表</p>
<pre><code>public class Test15 {
    public static void main(String args[]) {
        for (int i = 1; i &lt; 10; i++) { // i是一个乘数
            for (int j = 1; j &lt;= i; j++) { // j是另一个乘数
                System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + (i * j &lt; 10 ? (&quot; &quot; + i * j) : i * j) + &quot;  &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494920241544320.png" alt="enter description here"></p>
<h2 id="课堂练习">课堂练习</h2>
<ol>
<li>
<p>用while循环分别计算100以内的奇数及偶数的和，并输出。</p>
</li>
<li>
<p>用while循环或其他循环输出1-1000之间能被5整除的数，且每行输出5个。</p>
</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>3.2.3 for循环</title>
			<link>https://HarryQing.github.io/posts/3.2.3-for%E5%BE%AA%E7%8E%AF/</link>
			<pubDate>Wed, 10 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.2.3-for%E5%BE%AA%E7%8E%AF/</guid>
			<description>语法结构：　 for (初始表达式; 布尔表达式; 迭代因子) {循环体;} for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。for循环在第一次反复之前要进行初始化，即执行初始表达式;随后，对布尔表达式进行判定，若判定结果为true，则执行循环体，否则，终止循环;最后在每一次反复的时候，进行某种形式的“步进”，即执行迭代因子。
 A. 初始化部分设置循环变量的初值B. 条件判断部分为任意布尔表达式C. 迭代因子控制循环变量的增减for循环在执行条件判定后，先执行的循环体部分，再执行步进。for循环结构的流程图如图3-18所示。 【示例3-10】 for循环　public class Test10 {public static void main(String args[]) {int sum = 0;//1.求1-100之间的累加和for (int i = 0; i &amp;lt;= 100; i++) {sum += i;}System.out.println(&amp;quot;Sum= &amp;quot; + sum);//2.循环输出9-1之间的数for(int i=9;i&amp;gt;0;i--){System.out.print(i+&amp;quot;、&amp;quot;);}System.out.println();//3.输出90-1之间能被3整除的数for(int i=90;i&amp;gt;0;i-=3){System.out.print(i+&amp;quot;、&amp;quot;);}System.out.println();}} Java里能用到逗号运算符的地方屈指可数，其中一处就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，我们可以使用一系列由逗号分隔的表达式，而且那些表达式均会独立执行。</description>
			<content type="html"><![CDATA[<h2 id="语法结构">语法结构：　　</h2>
<pre><code>for (初始表达式; 布尔表达式; 迭代因子) {
      循环体;
}
</code></pre>
<p>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。for循环在第一次反复之前要进行初始化，即执行初始表达式;随后，对布尔表达式进行判定，若判定结果为true，则执行循环体，否则，终止循环;最后在每一次反复的时候，进行某种形式的“步进”，即执行迭代因子。</p>
<pre><code>  A. 初始化部分设置循环变量的初值

  B. 条件判断部分为任意布尔表达式

  C. 迭代因子控制循环变量的增减

  for循环在执行条件判定后，先执行的循环体部分，再执行步进。

  for循环结构的流程图如图3-18所示。
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919708427157.png" alt="enter description here"></p>
<p><strong>【示例3-10】</strong> for循环　　</p>
<pre><code>public class Test10 {
    public static void main(String args[]) {
        int sum = 0;
        //1.求1-100之间的累加和
        for (int i = 0; i &lt;= 100; i++) {
            sum += i;
        }
        System.out.println(&quot;Sum= &quot; + sum);
        //2.循环输出9-1之间的数
        for(int i=9;i&gt;0;i--){
            System.out.print(i+&quot;、&quot;);
        }
        System.out.println();
        //3.输出90-1之间能被3整除的数
        for(int i=90;i&gt;0;i-=3){
            System.out.print(i+&quot;、&quot;);
        }
        System.out.println();
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919882344126.png" alt="enter description here"></p>
<p>Java里能用到逗号运算符的地方屈指可数，其中一处就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，我们可以使用一系列由逗号分隔的表达式，而且那些表达式均会独立执行。</p>
<p><strong>【示例3-11】</strong> 逗号运算符　</p>
<pre><code>public class Test11 {
    public static void main(String[] args) { 
        for(int i = 1, j = i + 10; i &lt; 5; i++, j = i * 2) {
            System.out.println(&quot;i= &quot; + i + &quot; j= &quot; + j); 
        } 
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919920133938.png" alt="enter description here"></p>
<ol>
<li>
<p>无论在初始化还是在步进部分，语句都是顺序执行的。</p>
</li>
<li>
<p>尽管初始化部分可设置任意数量的定义，但都属于同一类型。</p>
</li>
<li>
<p>约定:只在for语句的控制表达式中写入与循环变量初始化，条件判断和迭代因子相关的表达式。</p>
</li>
</ol>
<p>初始化部分、条件判断部分和迭代因子可以为空语句，但必须以“;”分开，如示例3-12所示。</p>
<p><strong>【示例3-12】</strong> 无限循环</p>
<pre><code>public class Test12 {
    public static void main(String[] args) { 
        for ( ; ; ) {    // 无限循环: 相当于 while(true)
            System.out.println(&quot;北京尚学堂&quot;);
        }
    }
}
</code></pre>
<p>编译器将while(true)与for(;;)看作同一回事，都指的是无限循环。</p>
<p>在for语句的初始化部分声明的变量，其作用域为整个for循环体，不能在循环外部使用该变量。如示例3-13所示。</p>
<p><strong>【示例3-13】</strong> 初始化变量的作用域</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494920002726434.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>3.2.2 do-while循环</title>
			<link>https://HarryQing.github.io/posts/3.2.2-do-while%E5%BE%AA%E7%8E%AF/</link>
			<pubDate>Tue, 09 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.2.2-do-while%E5%BE%AA%E7%8E%AF/</guid>
			<description>语法结构： do {循环体;} while(布尔表达式) ; do-while循环结构会先执行循环体，然后再判断布尔表达式的值，若条件为真，执行循环体，当条件为假时结束循环。do-while循环的循环体至少执行一次。do-while循环结构流程图如图3.15所示。
【示例3-8】 do-while循环结构：1-100之间的累加和
public class Test8 {public static void main(String[] args) {int i = 0;int sum = 0;do {sum += i; // sum = sum + ii++;} while (i &amp;lt;= 100);//此处的；不能省略System.out.println(&amp;quot;Sum= &amp;quot; + sum);}} 　【示例3-9】 while与do-while的区别
public class Test9 {public static void main(String[] args) {//while循环：先判断再执行int a = 0;while (a &amp;lt; 0) {System.</description>
			<content type="html"><![CDATA[<h2 id="语法结构">语法结构：</h2>
<pre><code>do {
        循环体;
     } while(布尔表达式) ;
</code></pre>
<p>do-while循环结构会先执行循环体，然后再判断布尔表达式的值，若条件为真，执行循环体，当条件为假时结束循环。do-while循环的循环体至少执行一次。do-while循环结构流程图如图3.15所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919347187056.png" alt="enter description here"></p>
<p><strong>【示例3-8】</strong> do-while循环结构：1-100之间的累加和</p>
<pre><code>public class Test8 {
    public static void main(String[] args) {
        int i = 0;
        int sum = 0;
        do {
            sum += i; // sum = sum + i
            i++;
        } while (i &lt;= 100);//此处的；不能省略
        System.out.println(&quot;Sum= &quot; + sum);
    }
}
</code></pre>
<p>　</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919404947497.png" alt="enter description here"></p>
<p><strong>【示例3-9】</strong> while与do-while的区别</p>
<pre><code>public class Test9 {
    public static void main(String[] args) {
        //while循环：先判断再执行
        int a = 0;
        while (a &lt; 0) {
            System.out.println(a);
            a++;
        }
        System.out.println(&quot;-----&quot;);
        //do-while循环：先执行再判断
        a = 0;
        do {
            System.out.println(a);
            a++;
        } while (a &lt; 0);
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919475143305.png" alt="enter description here"></p>
<p>从运行效图中可以看出do-while总是保证循环体至少会被执行一次!</p>
]]></content>
		</item>
		
		<item>
			<title>3.2.1 while循环</title>
			<link>https://HarryQing.github.io/posts/3.2.1-while%E5%BE%AA%E7%8E%AF/</link>
			<pubDate>Mon, 08 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.2.1-while%E5%BE%AA%E7%8E%AF/</guid>
			<description>语法结构：　 while (布尔表达式) {循环体;} 在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。
语句中应有使循环趋向于结束的语句，否则会出现无限循环–––&amp;ldquo;死&amp;quot;循环。
while循环结构流程图如图3.13所示。
【示例3-7】 while循环结构：求1到100之间的累加和
public class Test7 {public static void main(String[] args) {int i = 0;int sum = 0;// 1+2+3+…+100=?while (i &amp;lt;= 100) {sum += i;//相当于sum = sum+i;i++;}System.out.println(&amp;quot;Sum= &amp;quot; + sum);}} </description>
			<content type="html"><![CDATA[<h2 id="语法结构">语法结构：　</h2>
<pre><code>while (布尔表达式) {
    循环体;
}
</code></pre>
<p>在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。</p>
<p>语句中应有使循环趋向于结束的语句，否则会出现无限循环–––&ldquo;死&quot;循环。</p>
<p>while循环结构流程图如图3.13所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919125339101.png" alt="enter description here"></p>
<p><strong>【示例3-7】</strong> while循环结构：求1到100之间的累加和</p>
<pre><code>public class Test7 {
    public static void main(String[] args) {
        int  i = 0;
        int  sum = 0;
        // 1+2+3+…+100=?
        while (i &lt;= 100) {
            sum += i;//相当于sum = sum+i;
            i++;
        }
        System.out.println(&quot;Sum= &quot; + sum);
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494919188264576.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>3.2 循环结构</title>
			<link>https://HarryQing.github.io/posts/3.2-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</link>
			<pubDate>Sun, 07 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.2-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</guid>
			<description>循环结构分两大类，一类是当型，一类是直到型。
当型： 当布尔表达式条件为true时，反复执行某语句，当布尔表达式的值为false时才停止循环，比如：while与for循环。
直到型： 先执行某语句， 再判断布尔表达式，如果为true，再执行某语句，如此反复，直到布尔表达式条件为false时才停止循环，比如do-while循环。</description>
			<content type="html"><![CDATA[<p>循环结构分两大类，一类是当型，一类是直到型。</p>
<h3 id="当型">当型：</h3>
<p>当布尔表达式条件为true时，反复执行某语句，当布尔表达式的值为false时才停止循环，比如：while与for循环。</p>
<h3 id="直到型">直到型：</h3>
<p>先执行某语句， 再判断布尔表达式，如果为true，再执行某语句，如此反复，直到布尔表达式条件为false时才停止循环，比如do-while循环。</p>
]]></content>
		</item>
		
		<item>
			<title>3.1.4 switch多选择结构</title>
			<link>https://HarryQing.github.io/posts/3.1.4-switch%E5%A4%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</link>
			<pubDate>Sat, 06 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.1.4-switch%E5%A4%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</guid>
			<description>语法结构：　 switch (表达式) {case 值1: 语句序列1;[break];case 值2:语句序列2;[break];… … … … …[default:默认语句;]} switch语句会根据表达式的值从相匹配的case标签处开始执行，一直执行到break语句处或者是switch语句的末尾。如果表达式的值与任一case值不匹配，则进入default语句(如果存在default语句的情况)。
根据表达式值的不同可以执行许多不同的操作。switch语句中case标签在JDK1.5之前必须是整数(long类型除外)或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。
大家要注意，当布尔表达式是等值判断的情况，可以使用if-else if-else多选择结构或者switch结构，如果布尔表达式区间判断的情况，则只能使用if-else if-else多选择结构。
switch多选择结构的流程图如图3-10所示。
【示例3-6】 switch结构
public class Test6 {public static void main(String[] args) {char c = &#39;a&#39;;int rand = (int) (26 * Math.random());char c2 = (char) (c + rand);System.out.print(c2 + &amp;quot;: &amp;quot;);switch (c2) {case &#39;a&#39;:case &#39;e&#39;:case &#39;i&#39;:case &#39;o&#39;:case &#39;u&#39;:System.</description>
			<content type="html"><![CDATA[<h2 id="语法结构">语法结构：　</h2>
<pre><code>switch (表达式) {
case 值1: 
语句序列1;
[break];
case 值2:
 语句序列2;
[break];
     … … …      … …
[default:
 默认语句;]
}
</code></pre>
<p>switch语句会根据表达式的值从相匹配的case标签处开始执行，一直执行到break语句处或者是switch语句的末尾。如果表达式的值与任一case值不匹配，则进入default语句(如果存在default语句的情况)。</p>
<p>根据表达式值的不同可以执行许多不同的操作。switch语句中case标签在JDK1.5之前必须是整数(long类型除外)或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。</p>
<p>大家要注意，当布尔表达式是等值判断的情况，可以使用if-else if-else多选择结构或者switch结构，如果布尔表达式区间判断的情况，则只能使用if-else if-else多选择结构。</p>
<p>switch多选择结构的流程图如图3-10所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494918663569372.png" alt="enter description here"></p>
<p><strong>【示例3-6】</strong> switch结构</p>
<pre><code>public class Test6 {
    public static void main(String[] args) {
        char c = 'a';
        int rand = (int) (26 * Math.random());
        char c2 = (char) (c + rand);
        System.out.print(c2 + &quot;: &quot;);
        switch (c2) {
        case 'a':
        case 'e':
        case 'i':
        case 'o':
        case 'u':
            System.out.println(&quot;元音&quot;);
            break;
        case 'y':
        case 'w':
            System.out.println(&quot;半元音&quot;);
            break;
        default:
            System.out.println(&quot;辅音&quot;);
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494918740540880.png" alt="enter description here"></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494918747692225.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>3.1.3 if-else if-else多选择结构</title>
			<link>https://HarryQing.github.io/posts/3.1.3-if-else-if-else%E5%A4%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</link>
			<pubDate>Fri, 05 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.1.3-if-else-if-else%E5%A4%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</guid>
			<description>语法结构： if(布尔表达式1) {语句块1;} else if(布尔表达式2) {语句块2;}……else if(布尔表达式n){语句块n;} else {语句块n+1;} 当布尔表达式1为真时，执行语句块1;否则，判断布尔表达式2，当布尔表达式2为真时，执行语句块2;否则，继续判断布尔表达式3······;如果1~n个布尔表达式均判定为假时，则执行语句块n+1，也就是else部分。流程图如图3-7所示。
【示例3-5】 if-else if-else多选择结构
public class Test5 {public static void main(String[] args) {int age = (int) (100 * Math.random());System.out.print(&amp;quot;年龄是&amp;quot; + age + &amp;quot;， 属于&amp;quot;);if (age &amp;lt; 15) {System.out.println(&amp;quot;儿童， 喜欢玩！&amp;quot;);} else if (age &amp;lt; 25) {System.out.println(&amp;quot;青年， 要学习！&amp;quot;);} else if (age &amp;lt; 45) {System.out.println(&amp;quot;中年， 要工作！&amp;quot;);} else if (age &amp;lt; 65) {System.</description>
			<content type="html"><![CDATA[<h2 id="语法结构">语法结构：</h2>
<pre><code>if(布尔表达式1) {
语句块1;
} else if(布尔表达式2) {
语句块2;
}……
else if(布尔表达式n){
    语句块n;
} else {
    语句块n+1;
}
</code></pre>
<p>当布尔表达式1为真时，执行语句块1;否则，判断布尔表达式2，当布尔表达式2为真时，执行语句块2;否则，继续判断布尔表达式3······;如果1~n个布尔表达式均判定为假时，则执行语句块n+1，也就是else部分。流程图如图3-7所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494918202257279.png" alt="enter description here"></p>
<p><strong>【示例3-5】</strong> if-else if-else多选择结构</p>
<pre><code>public class Test5 {
    public static void main(String[] args) {
        int age = (int) (100 * Math.random());
        System.out.print(&quot;年龄是&quot; + age + &quot;， 属于&quot;);
        if (age &lt; 15) {
            System.out.println(&quot;儿童， 喜欢玩！&quot;);
        } else if (age &lt; 25) {
            System.out.println(&quot;青年， 要学习！&quot;);
        } else if (age &lt; 45) {
            System.out.println(&quot;中年， 要工作！&quot;);
        } else if (age &lt; 65) {
            System.out.println(&quot;中老年， 要补钙！&quot;);
        } else if (age &lt; 85) {
            System.out.println(&quot;老年， 多运动！&quot;);
        } else {
            System.out.println(&quot;老寿星， 古来稀！&quot;);
        }
    }
}
</code></pre>
<p>　　</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494918283781121.png" alt="enter description here"></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494918291733484.png" alt="enter description here"></p>
<h2 id="课堂练习">课堂练习</h2>
<h3 id="仿照示例3-5实现如下功能">仿照【示例3-5】，实现如下功能：</h3>
<p>随机生成一个100以内的成绩，当成绩在85及以上的时候输出”等级A”，70以上到84之间输出”等级B”，60到69之间输出”等级C”，60以下输出”等级D”。</p>
]]></content>
		</item>
		
		<item>
			<title>3.1.2 if-else双选择结构</title>
			<link>https://HarryQing.github.io/posts/3.1.2-if-else%E5%8F%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</link>
			<pubDate>Thu, 04 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.1.2-if-else%E5%8F%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</guid>
			<description>语法结构: if(布尔表达式){语句块1}else{语句块2} 当布尔表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分。流程图如图3-3所示。
【示例3-2】 if-else结构
public class Test2 {public static void main(String[] args) {//随机产生一个[0.0, 4.0)区间的半径，并根据半径求圆的面积和周长double r = 4 * Math.random();//Math.pow(r, 2)求半径r的平方double area = Math.PI * Math.pow(r, 2);double circle = 2 * Math.PI * r;System.out.println(&amp;quot;半径为： &amp;quot; + r);System.out.println(&amp;quot;面积为： &amp;quot; + area);System.out.println(&amp;quot;周长为： &amp;quot; + circle);//如果面积&amp;gt;=周长，则输出&amp;quot;面积大于等于周长&amp;quot;，否则，输出周长大于面积if(area &amp;gt;= circle) {System.out.println(&amp;quot;面积大于等于周长&amp;quot;);} else {System.out.println(&amp;quot;周长大于面积&amp;quot;);}}} 条件运算符有时候可用于代替if-else，如示例3-3与示例3-4所示。</description>
			<content type="html"><![CDATA[<h2 id="语法结构">语法结构:</h2>
<pre><code>if(布尔表达式){
 语句块1
}else{
       语句块2
}
</code></pre>
<p>当布尔表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分。流程图如图3-3所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494917663543171.png" alt="enter description here"></p>
<p><strong>【示例3-2】</strong> if-else结构</p>
<pre><code>public class Test2 {
    public static void main(String[] args) {
        //随机产生一个[0.0, 4.0)区间的半径，并根据半径求圆的面积和周长
        double r = 4 * Math.random();
       //Math.pow(r, 2)求半径r的平方
        double area = Math.PI * Math.pow(r, 2);
        double circle = 2 * Math.PI * r;
        System.out.println(&quot;半径为： &quot; + r);
        System.out.println(&quot;面积为： &quot; + area);
        System.out.println(&quot;周长为： &quot; + circle);
        //如果面积&gt;=周长，则输出&quot;面积大于等于周长&quot;，否则，输出周长大于面积
        if(area &gt;= circle) {
            System.out.println(&quot;面积大于等于周长&quot;);
        } else {
            System.out.println(&quot;周长大于面积&quot;);
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494917747605880.png" alt="enter description here"></p>
<p>条件运算符有时候可用于代替if-else，如示例3-3与示例3-4所示。</p>
<p><strong>【示例3-3】</strong> 使用if-else</p>
<pre><code>public class Test3 {
    public static void main(String[] args) {
        int a=2; 
        int b=3;
        if (a&lt;b) {
            System.out.println(a);
        } else {
            System.out.println(b);
        }
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494917807854177.png" alt="enter description here"></p>
<p><strong>【示例3-4】</strong> 使用条件运算符</p>
<p>public class Test4 {
public static void main(String[] args) {
int a=2;
int b=3;
System.out.println((a&lt;b)?a:b);
}
}</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494917807854177.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>3.1.1 if单选择结构</title>
			<link>https://HarryQing.github.io/posts/3.1.1-if%E5%8D%95%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</link>
			<pubDate>Wed, 03 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.1.1-if%E5%8D%95%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</guid>
			<description>语法结构: if(布尔表达式){语句块} if语句对布尔表达式进行一次判定，若判定为真，则执行{}中的语句块，否则跳过该语句块。流程图如图3-1所示。
【示例3-1】 if单选择结构
public class Test1 {public static void main(String[] args) {//通过掷三个骰子看看今天的手气如何？int i = (int)(6 * Math.random()) + 1;//通过Math.random()产生随机数int j = (int)(6 * Math.random()) + 1;int k = (int)(6 * Math.random()) + 1;int count = i + j + k;//如果三个骰子之和大于15，则手气不错if(count &amp;gt; 15) {System.out.println(&amp;quot;今天手气不错&amp;quot;);}//如果三个骰子之和在10到15之间，则手气一般if(count &amp;gt;= 10 &amp;amp;&amp;amp; count &amp;lt;= 15) { //错误写法：10&amp;lt;=count&amp;lt;=15System.out.println(&amp;quot;今天手气很一般&amp;quot;);}//如果三个骰子之和小于10，则手气不怎么样if(count &amp;lt; 10) {System.</description>
			<content type="html"><![CDATA[<h2 id="语法结构">语法结构:</h2>
<pre><code>if(布尔表达式){
    语句块
}
</code></pre>
<p>if语句对布尔表达式进行一次判定，若判定为真，则执行{}中的语句块，否则跳过该语句块。流程图如图3-1所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494915015552935.png" alt="enter description here"></p>
<p><strong>【示例3-1】</strong> if单选择结构</p>
<pre><code>public class Test1 {
    public static void main(String[] args) {
        //通过掷三个骰子看看今天的手气如何？
        int i = (int)(6 * Math.random()) + 1;//通过Math.random()产生随机数
        int j = (int)(6 * Math.random()) + 1;
        int k = (int)(6 * Math.random()) + 1;
        int count = i + j + k;
        //如果三个骰子之和大于15，则手气不错
        if(count &gt; 15) {
            System.out.println(&quot;今天手气不错&quot;);
        }
        //如果三个骰子之和在10到15之间，则手气一般
        if(count &gt;= 10 &amp;&amp; count &lt;= 15) { //错误写法：10&lt;=count&lt;=15
            System.out.println(&quot;今天手气很一般&quot;);
        }
        //如果三个骰子之和小于10，则手气不怎么样
        if(count &lt; 10) {
            System.out.println(&quot;今天手气不怎么样&quot;);
        }
        System.out.println(&quot;得了&quot; + count + &quot;分&quot;);
    }
}
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170517/1494983790710364.png" alt="enter description here"></p>
<h2 id="math类的使用">Math类的使用</h2>
<p>1.java.lang包中的Math类提供了一些用于数学计算的方法。</p>
<p>2.Math.random()该方法用于产生一个0到1区间的double类型的随机数，但是不包括1。</p>
<p>int i = (int) (6 * Math.random()); //产生：[0，5]之间的随机整数</p>
<h2 id="新手雷区">新手雷区</h2>
<p>1.如果if语句不写{}，则只能作用于后面的第一条语句。</p>
<p>2.强烈建议，任何时候都写上{}，即使里面只有一句话！</p>
]]></content>
		</item>
		
		<item>
			<title>3.0 控制语句</title>
			<link>https://HarryQing.github.io/posts/3.0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link>
			<pubDate>Tue, 02 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid>
			<description>本章开始我们需要学习流程控制语句，流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。控制语句分为三类：顺序、选择和循环。
“顺序结构”代表“先执行a，再执行b”的逻辑。比如，先找个女朋友，再给女朋友打电话；先订婚，再结婚；
“选择结构”代表“如果…，则…”的逻辑。比如，如果女朋友来电，则迅速接电话；如果看到红灯，则停车；
“循环结构”代表“如果…，则再继续…”的逻辑。比如，如果没打通女朋友电话，则再继续打一次； 如果没找到喜欢的人，则再继续找。
前面两章讲解的程序都是顺序结构，即按照书写顺序执行每一条语句，这并不是我们的重点，因此本章研究的重点是“选择结构”和“循环结构”。
很神奇的是，三种流程控制语句就能表示所有的事情！不信，你可以试试拆分你遇到的各种事情。实际上，任何软件和程序，小到一个练习，大到一个操作系统，本质上都是由“变量、选择语句、循环语句”组成。
这三种基本逻辑结构是相互支撑的，它们共同构成了算法的基本结构，无论怎样复杂的逻辑结构，都可以通过它们来表达。上述两种结构组成的程序可以解决全部的问题，所以任何一种高级语言都具备上述两种结构。
因此，本章是大家真正跨入编程界的“门槛”，是成为“程序猿”的“门票”。 本章后面会附加大量的练习，供大家提升自我。</description>
			<content type="html"><![CDATA[<p>本章开始我们需要学习流程控制语句，流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。控制语句分为三类：顺序、选择和循环。</p>
<p>“顺序结构”代表“先执行a，再执行b”的逻辑。比如，先找个女朋友，再给女朋友打电话；先订婚，再结婚；</p>
<p>“选择结构”代表“如果…，则…”的逻辑。比如，如果女朋友来电，则迅速接电话；如果看到红灯，则停车；</p>
<p>“循环结构”代表“如果…，则再继续…”的逻辑。比如，如果没打通女朋友电话，则再继续打一次； 如果没找到喜欢的人，则再继续找。</p>
<p>前面两章讲解的程序都是顺序结构，即按照书写顺序执行每一条语句，这并不是我们的重点，因此本章研究的重点是“选择结构”和“循环结构”。</p>
<p>很神奇的是，三种流程控制语句就能表示所有的事情！不信，你可以试试拆分你遇到的各种事情。实际上，任何软件和程序，小到一个练习，大到一个操作系统，本质上都是由“变量、选择语句、循环语句”组成。</p>
<p>这三种基本逻辑结构是相互支撑的，它们共同构成了算法的基本结构，无论怎样复杂的逻辑结构，都可以通过它们来表达。上述两种结构组成的程序可以解决全部的问题，所以任何一种高级语言都具备上述两种结构。</p>
<p>因此，本章是大家真正跨入编程界的“门槛”，是成为“程序猿”的“门票”。 本章后面会附加大量的练习，供大家提升自我。</p>
]]></content>
		</item>
		
		<item>
			<title>3.1 选择结构</title>
			<link>https://HarryQing.github.io/posts/3.1-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</link>
			<pubDate>Tue, 02 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/3.1-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</guid>
			<description>在还没有知道Java选择结构的时候，我们编写的程序总是从程序入口开始，顺序执行每一条语句直到执行完最后一条语句结束，但是生活中经常需要进行条件判断，根据判断结果决定是否做一件事情，这就需要选择结构。
选择结构用于判断给定的条件，然后根据判断的结果来控制程序的流程。
主要的选择结构有：if选择结构和switch多选择结构。有如下结构：
 1.if单选择结构2.if-else双选择结构3.if-else if-else多选择结构4.switch结构 </description>
			<content type="html"><![CDATA[<p>在还没有知道Java选择结构的时候，我们编写的程序总是从程序入口开始，顺序执行每一条语句直到执行完最后一条语句结束，但是生活中经常需要进行条件判断，根据判断结果决定是否做一件事情，这就需要选择结构。</p>
<p>选择结构用于判断给定的条件，然后根据判断的结果来控制程序的流程。</p>
<p>主要的选择结构有：if选择结构和switch多选择结构。有如下结构：</p>
<pre><code>   1.if单选择结构

   2.if-else双选择结构

   3.if-else if-else多选择结构

   4.switch结构</code></pre>
]]></content>
		</item>
		
		<item>
			<title>第三章 控制语句</title>
			<link>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link>
			<pubDate>Mon, 01 Feb 2021 17:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid>
			<description>目录 3.0 控制语句 3.1 选择结构 3.1.1 if单选择结构 3.1.2 if-else双选择结构 3.1.3 if-else if-else多选择结构 3.1.4 switch多选择结构 3.2 循环结构 3.2.1 while循环 3.2.2 do-while循环 3.2.3 for循环 3.2.4 嵌套循环 3.2.5 break语句和continue语句 3.2.6 带标签的break和continue 3.3 语句块 3.4 方法 3.5 方法的重载(overload) 3.6 递归结构 </description>
			<content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="30-控制语句">3.0 控制语句</h2>
<h2 id="31-选择结构">3.1 选择结构</h2>
<h2 id="311-if单选择结构">3.1.1 if单选择结构</h2>
<h2 id="312-if-else双选择结构">3.1.2 if-else双选择结构</h2>
<h2 id="313-if-else-if-else多选择结构">3.1.3 if-else if-else多选择结构</h2>
<h2 id="314-switch多选择结构">3.1.4 switch多选择结构</h2>
<h2 id="32-循环结构">3.2 循环结构</h2>
<h2 id="321-while循环">3.2.1 while循环</h2>
<h2 id="322-do-while循环">3.2.2 do-while循环</h2>
<h2 id="323-for循环">3.2.3 for循环</h2>
<h2 id="324-嵌套循环">3.2.4 嵌套循环</h2>
<h2 id="325-break语句和continue语句">3.2.5 break语句和continue语句</h2>
<h2 id="326-带标签的break和continue">3.2.6 带标签的break和continue</h2>
<h2 id="33-语句块">3.3 语句块</h2>
<h2 id="34-方法">3.4 方法</h2>
<h2 id="35-方法的重载overload">3.5 方法的重载(overload)</h2>
<h2 id="36-递归结构">3.6 递归结构</h2>
]]></content>
		</item>
		
		<item>
			<title>2.9 简单的键盘输入和输出</title>
			<link>https://HarryQing.github.io/posts/2.9-%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/</link>
			<pubDate>Mon, 01 Feb 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.9-%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/</guid>
			<description>为了我们能写出更加复杂的程序，可以让我们的程序和用户可以通过键盘交互，我们先学习一下简单的键盘输入和输出。
【示例2-31】 使用Scanner获取键盘输入
import java.util.Scanner;/*** 测试获得键盘输入* @author 高**/public class TestScanner {public static void main(String[] args) {Scanner scanner = new Scanner(System.in);System.out.println(&amp;quot;请输入名字：&amp;quot;);String name = scanner.nextLine();System.out.println(&amp;quot;请输入你的爱好：&amp;quot;);String favor = scanner.nextLine();System.out.println(&amp;quot;请输入你的年龄：&amp;quot;);int age = scanner.nextInt();System.out.println(&amp;quot;###############&amp;quot;);System.out.println(name);System.out.println(favor);System.out.println(&amp;quot;来到地球的天数：&amp;quot;+age*365);System.out.println(&amp;quot;离开地球的天数：&amp;quot;+(72-age)*365);}} 运行结果如图所示 </description>
			<content type="html"><![CDATA[<p>为了我们能写出更加复杂的程序，可以让我们的程序和用户可以通过键盘交互，我们先学习一下简单的键盘输入和输出。</p>
<p><strong>【示例2-31】</strong> 使用Scanner获取键盘输入</p>
<pre><code>import  java.util.Scanner;
/**
 * 测试获得键盘输入
 * @author 高
 *
 */
public class TestScanner {
    public static void main(String[] args) {
        Scanner   scanner =  new Scanner(System.in);
        System.out.println(&quot;请输入名字：&quot;);
        String   name =  scanner.nextLine();
        System.out.println(&quot;请输入你的爱好：&quot;);
        String  favor = scanner.nextLine();
        System.out.println(&quot;请输入你的年龄：&quot;);
        int   age = scanner.nextInt();

        System.out.println(&quot;###############&quot;);
        System.out.println(name);
        System.out.println(favor);
        System.out.println(&quot;来到地球的天数：&quot;+age*365);
        System.out.println(&quot;离开地球的天数：&quot;+(72-age)*365);

    }
}
</code></pre>
<h2 id="运行结果如图所示">运行结果如图所示</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20171018/1508314351247501.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>2.8.3 基本类型转化时常见错误和问题</title>
			<link>https://HarryQing.github.io/posts/2.8.3-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E6%97%B6%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%92%8C%E9%97%AE%E9%A2%98/</link>
			<pubDate>Sun, 31 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.8.3-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E6%97%B6%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%92%8C%E9%97%AE%E9%A2%98/</guid>
			<description>操作比较大的数时，要留意是否溢出，尤其是整数操作时。
【示例2-29】 常见问题一
int money = 1000000000; //10亿int years = 20;//返回的total是负数，超过了int的范围int total = money*years;System.out.println(&amp;quot;total=&amp;quot;+total);//返回的total仍然是负数。默认是int，因此结果会转成int值，再转成long。但是已经发生//了数据丢失long total1 = money*years; System.out.println(&amp;quot;total1=&amp;quot;+total1);//返回的total2正确:先将一个因子变成long，整个表达式发生提升。全部用long来计算。long total2 = money*((long)years); System.out.println(&amp;quot;total2=&amp;quot;+total2); 运行结果如图所示。 L和l 的问题： 不要命名名字为l的变量，l容易和1混淆。long类型使用大写L不要用小写。
【示例2-30】 常见问题二
 int l = 2; //分不清是L还是1,long a = 23451l;//建议使用大写LSystem.out.println(l+1); </description>
			<content type="html"><![CDATA[<p>操作比较大的数时，要留意是否溢出，尤其是整数操作时。</p>
<p><strong>【示例2-29】</strong> 常见问题一</p>
<pre><code>int money = 1000000000; //10亿
int years = 20;
//返回的total是负数，超过了int的范围
int total = money*years;
System.out.println(&quot;total=&quot;+total);
//返回的total仍然是负数。默认是int，因此结果会转成int值，再转成long。但是已经发生//了数据丢失
long total1 = money*years; 
System.out.println(&quot;total1=&quot;+total1);
//返回的total2正确:先将一个因子变成long，整个表达式发生提升。全部用long来计算。
long total2 = money*((long)years); 
System.out.println(&quot;total2=&quot;+total2);
</code></pre>
<h2 id="运行结果如图所示">运行结果如图所示。</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494906673550331.png" alt="1.png"></p>
<h2 id="l和l-的问题">L和l 的问题：</h2>
<p>不要命名名字为l的变量，l容易和1混淆。long类型使用大写L不要用小写。</p>
<p><strong>【示例2-30】</strong> 常见问题二</p>
<pre><code>    int l = 2; //分不清是L还是1,
    long a = 23451l;//建议使用大写L
    System.out.println(l+1);
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.8.2 强制类型转换</title>
			<link>https://HarryQing.github.io/posts/2.8.2-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
			<pubDate>Sat, 30 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.8.2-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
			<description>强制类型转换，又被称为造型，用于显式的转换一个数值的类型。在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。
语法格式： (type)var 运算符“()”中的type表示将值var想要转换成的目标数据类型。
【示例2-27】 强制类型转换
double x = 3.14; int nx = (int)x; //值为3char c = &#39;a&#39;;int d = c+1;System.out.println(nx);System.out.println(d);System.out.println((char)d); 运行结果如图所示。 当将一种类型强制转换成另一种类型，而又超出了目标类型的表数范围，就会被截断成为一个完全不同的值。
【示例2-28】 强制类型转换特例
int x = 300;byte bx = (byte)x; //值为44 新手雷区 不能在布尔类型和任何数值类型之间做强制类型转换</description>
			<content type="html"><![CDATA[<p>强制类型转换，又被称为造型，用于显式的转换一个数值的类型。在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。</p>
<h3 id="语法格式">语法格式：</h3>
<pre><code>(type)var
</code></pre>
<p>运算符“()”中的type表示将值var想要转换成的目标数据类型。</p>
<p><strong>【示例2-27】</strong> 强制类型转换</p>
<pre><code>double x  = 3.14; 
int nx = (int)x;   //值为3
char c = 'a';
int d = c+1;
System.out.println(nx);
System.out.println(d);
System.out.println((char)d);
</code></pre>
<h2 id="运行结果如图所示">运行结果如图所示。</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494906447385004.png" alt="enter description here"></p>
<p>当将一种类型强制转换成另一种类型，而又超出了目标类型的表数范围，就会被截断成为一个完全不同的值。</p>
<p><strong>【示例2-28】</strong> 强制类型转换特例</p>
<pre><code>int x = 300;
byte bx = (byte)x;    //值为44
</code></pre>
<h2 id="新手雷区">新手雷区</h2>
<p>不能在布尔类型和任何数值类型之间做强制类型转换</p>
]]></content>
		</item>
		
		<item>
			<title>2.8.1 自动类型转换</title>
			<link>https://HarryQing.github.io/posts/2.8.1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
			<pubDate>Fri, 29 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.8.1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
			<description>自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。如图2-6所示，黑色的实线表示无数据丢失的自动类型转换，而虚线表示在转换时可能会有精度的损失。
图 自动类型转换 可以将整型常量直接赋值给byte、 short、 char等类型变量，而不需要进行强制类型转换，只要不超出其表数范围即可。
【示例2-26】 自动类型转换特例
short b = 12; //合法short b = 1234567;//非法，1234567超出了short的表数范围 </description>
			<content type="html"><![CDATA[<p>自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。如图2-6所示，黑色的实线表示无数据丢失的自动类型转换，而虚线表示在转换时可能会有精度的损失。</p>
<h2 id="图-自动类型转换">图 自动类型转换</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494906265693111.png" alt="enter description here"></p>
<p>可以将整型常量直接赋值给byte、 short、 char等类型变量，而不需要进行强制类型转换，只要不超出其表数范围即可。</p>
<p><strong>【示例2-26】</strong> 自动类型转换特例</p>
<pre><code>short  b = 12;  //合法
short  b = 1234567;//非法，1234567超出了short的表数范围</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.7.8 运算符优先级的问题</title>
			<link>https://HarryQing.github.io/posts/2.7.8-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98/</link>
			<pubDate>Thu, 28 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.8-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
			<description>表 运算符的优先级    优先级 运算符 类 结合性     1 () 括号运算符 由左至右   2 !、+（正号）、-（负号） 一元运算符 由左至右   2 ~ 位逻辑运算符 由右至左   2 ++、&amp;ndash; 递增与递减运算符 由右至左   3 *、/、% 算术运算符 由左至右   4 +、- 算术运算符 由左至右   5 &amp;laquo;、&amp;raquo; 位左移、右移运算符 由左至右   6 &amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;= 关系运算符 由左至右   7 ==、!= 关系运算符 由左至右   8 &amp;amp; 位运算符、逻辑运算符 由左至右   9 ^ 位运算符、逻辑运算符 由左至右   10 | 位运算符、逻辑运算符 由左至右   11 &amp;amp;&amp;amp; 逻辑运算符 由左至右   12 || 逻辑运算符 由左至右   13 ?</description>
			<content type="html"><![CDATA[<h2 id="表--运算符的优先级">表  运算符的优先级</h2>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>类</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>()</td>
<td>括号运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>2</td>
<td>!、+（正号）、-（负号）</td>
<td>一元运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>2</td>
<td>~</td>
<td>位逻辑运算符</td>
<td>由右至左</td>
</tr>
<tr>
<td>2</td>
<td>++、&ndash;</td>
<td>递增与递减运算符</td>
<td>由右至左</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
<td>算术运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
<td>算术运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>5</td>
<td>&laquo;、&raquo;</td>
<td>位左移、右移运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>6</td>
<td>&gt;、&gt;=、&lt;、&lt;=</td>
<td>关系运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>7</td>
<td>==、!=</td>
<td>关系运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>位运算符、逻辑运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>位运算符、逻辑运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>位运算符、逻辑运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>逻辑运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>逻辑运算符</td>
<td>由左至右</td>
</tr>
<tr>
<td>13</td>
<td>? :</td>
<td>条件运算符</td>
<td>由右至左</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、%=</td>
<td>赋值运算符、扩展运算符</td>
<td>由右至左</td>
</tr>
</tbody>
</table>
<h2 id="老鸟建议">老鸟建议</h2>
<p>1.大家不需要去刻意的记这些优先级，表达式里面优先使用小括号来组织！！</p>
<p>2.逻辑与、逻辑或、逻辑非的优先级一定要熟悉！（逻辑非&gt;逻辑与&gt;逻辑或）。如：</p>
<p>3.a||b&amp;&amp;c的运算结果是：a||(b&amp;&amp;c)，而不是(a||b)&amp;&amp;c</p>
]]></content>
		</item>
		
		<item>
			<title>2.7.7 条件运算符</title>
			<link>https://HarryQing.github.io/posts/2.7.7-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Wed, 27 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.7-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>语法格式： x ? y : z 其中 x 为 boolean 类型表达式，先计算 x 的值，若为true，则整个运算的结果为表达式 y 的值，否则整个运算结果为表达式 z 的值。
【示例2-25】 三目条件运算符
 int score = 80; int x = -100;String type =score&amp;lt;60?&amp;quot;不及格&amp;quot;:&amp;quot;及格&amp;quot;; int flag = x &amp;gt; 0 ? 1 : (x == 0 ? 0 : -1);System.out.println(&amp;quot;type= &amp;quot; + type);System.out.println(&amp;quot;flag= &amp;quot;+ flag); </description>
			<content type="html"><![CDATA[<h2 id="语法格式">语法格式：</h2>
<pre><code>x ? y : z
</code></pre>
<p>其中 x 为 boolean 类型表达式，先计算 x 的值，若为true，则整个运算的结果为表达式 y 的值，否则整个运算结果为表达式 z 的值。</p>
<p><strong>【示例2-25】</strong> 三目条件运算符</p>
<pre><code>    int score = 80; 
    int x = -100;
    String type =score&lt;60?&quot;不及格&quot;:&quot;及格&quot;; 
    int flag = x &gt; 0 ? 1 : (x == 0 ? 0 : -1);
    System.out.println(&quot;type= &quot; + type);
    System.out.println(&quot;flag= &quot;+ flag);
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494905474866571.png" alt=""></p>
]]></content>
		</item>
		
		<item>
			<title>2.7.5 位运算符</title>
			<link>https://HarryQing.github.io/posts/2.7.5-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Tue, 26 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.5-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>位运算指的是进行二进制位的运算，常用的位运算符如表2-11所示。
表位运算符    位运算符 说明     ~ 取反   &amp;amp; 按位与   | 按位或   ^ 按位异或   &amp;laquo; 左移运算符，左移1位相当于乘2   &amp;raquo; 右移运算符，右移1位相当于除2取商    【示例2-23】 左移运算和右移运算
int a = 3*2*2;int b = 3&amp;lt;&amp;lt;2; //相当于：3*2*2;int c = 12/2/2;int d = 12&amp;gt;&amp;gt;2; //相当于12/2/2; 雷区  &amp;amp;和|既是逻辑运算符，也是位运算符。如果两侧操作数都是boolean类型，就作为逻辑运算符。如果两侧的操作数是整数类型，就是位运算符。 不要把“^”当做数学运算“乘方”，是“位的异或”操作。  </description>
			<content type="html"><![CDATA[<p>位运算指的是进行二进制位的运算，常用的位运算符如表2-11所示。</p>
<h2 id="表位运算符">表位运算符</h2>
<table>
<thead>
<tr>
<th>位运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>取反</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&laquo;</td>
<td>左移运算符，左移1位相当于乘2</td>
</tr>
<tr>
<td>&raquo;</td>
<td>右移运算符，右移1位相当于除2取商</td>
</tr>
</tbody>
</table>
<p><strong>【示例2-23】</strong> 左移运算和右移运算</p>
<pre><code>int a = 3*2*2;
int b = 3&lt;&lt;2; //相当于：3*2*2;
int c = 12/2/2;
int d = 12&gt;&gt;2; //相当于12/2/2;
</code></pre>
<h2 id="雷区">雷区</h2>
<ol>
<li>&amp;和|既是逻辑运算符，也是位运算符。如果两侧操作数都是boolean类型，就作为逻辑运算符。如果两侧的操作数是整数类型，就是位运算符。</li>
<li>不要把“^”当做数学运算“乘方”，是“位的异或”操作。</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>2.7.6 字符串连接符</title>
			<link>https://HarryQing.github.io/posts/2.7.6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%AC%A6/</link>
			<pubDate>Tue, 26 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%AC%A6/</guid>
			<description>“+”运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。
【示例2-24】 连接符“+”
 int a=12;System.out.println(&amp;quot;a=&amp;quot;+a);//输出结果: a=12 </description>
			<content type="html"><![CDATA[<p>“+”运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。</p>
<p><strong>【示例2-24】</strong> 连接符“+”</p>
<pre><code> int a=12;
 System.out.println(&quot;a=&quot;+a);//输出结果: a=12</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.7.4 逻辑运算符</title>
			<link>https://HarryQing.github.io/posts/2.7.4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Mon, 25 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>Java中的逻辑运算符如表2-10所示。逻辑运算的操作数和运算结果都是boolean值。
表逻辑运算符    运算符  说明     逻辑与 &amp;amp;( 与) 两个操作数为true，结果才是true，否则是false   逻辑或 |(或) 两个操作数有一个是true，结果就是true   短路与 &amp;amp;&amp;amp;( 与) 只要有一个为false，则直接返回false   短路或 ||(或) 只要有一个为true， 则直接返回true   逻辑非 !（非） 取反：!false为true，!true为false   逻辑异或 ^（异或） 相同为false，不同为true    短路与和短路或采用短路的方式。从左到右计算，如果只通过运算符左边的操作数就能够确定该逻辑表达式的值，则不会继续计算运算符右边的操作数，提高效率。
【示例2-22】 短路与和逻辑与
//1&amp;gt;2的结果为false，那么整个表达式的结果即为false，将不再计算2&amp;gt;(3/0)boolean c = 1&amp;gt;2 &amp;amp;&amp;amp; 2&amp;gt;(3/0);System.out.println(c);//1&amp;gt;2的结果为false，那么整个表达式的结果即为false，还要计算2&amp;gt;(3/0)，0不能做除数，//会输出异常信息boolean d = 1&amp;gt;2 &amp;amp; 2&amp;gt;(3/0);System.out.println(d); </description>
			<content type="html"><![CDATA[<p>Java中的逻辑运算符如表2-10所示。逻辑运算的操作数和运算结果都是boolean值。</p>
<h2 id="表逻辑运算符">表逻辑运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑与</td>
<td>&amp;( 与)</td>
<td>两个操作数为true，结果才是true，否则是false</td>
</tr>
<tr>
<td>逻辑或</td>
<td>|(或)</td>
<td>两个操作数有一个是true，结果就是true</td>
</tr>
<tr>
<td>短路与</td>
<td>&amp;&amp;( 与)</td>
<td>只要有一个为false，则直接返回false</td>
</tr>
<tr>
<td>短路或</td>
<td>||(或)</td>
<td>只要有一个为true， 则直接返回true</td>
</tr>
<tr>
<td>逻辑非</td>
<td>!（非）</td>
<td>取反：!false为true，!true为false</td>
</tr>
<tr>
<td>逻辑异或</td>
<td>^（异或）</td>
<td>相同为false，不同为true</td>
</tr>
</tbody>
</table>
<p>短路与和短路或采用短路的方式。从左到右计算，如果只通过运算符左边的操作数就能够确定该逻辑表达式的值，则不会继续计算运算符右边的操作数，提高效率。</p>
<p><strong>【示例2-22】</strong> 短路与和逻辑与</p>
<pre><code>//1&gt;2的结果为false，那么整个表达式的结果即为false，将不再计算2&gt;(3/0)
boolean c = 1&gt;2 &amp;&amp; 2&gt;(3/0);
System.out.println(c);
//1&gt;2的结果为false，那么整个表达式的结果即为false，还要计算2&gt;(3/0)，0不能做除数，//会输出异常信息
boolean d = 1&gt;2 &amp; 2&gt;(3/0);
System.out.println(d);</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.7.3 关系运算符</title>
			<link>https://HarryQing.github.io/posts/2.7.3-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Sun, 24 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.3-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>关系运算符用来进行比较运算，如表2-9所示。关系运算的结果是布尔值：true/false；
表关系运算符    运算符 含义 示例     == 等于 a==b   != 不等于 a!=b   &amp;gt; 大于 a&amp;gt;b   &amp;lt; 小于 a&amp;lt;b   &amp;gt;= 大于或等于 a&amp;gt;=b   &amp;lt;= 小于或等于 a&amp;lt;=b    注意事项 =是赋值运算符，而真正的判断两个操作数是否相等的运算符是==。==、!= 是所有（基本和引用）数据类型都可以使用&amp;gt; 、&amp;gt;=、 &amp;lt;、 &amp;lt;= 仅针对数值类型（byte/short/int/long, float/double。以及char） </description>
			<content type="html"><![CDATA[<p>关系运算符用来进行比较运算，如表2-9所示。关系运算的结果是布尔值：true/false；</p>
<h2 id="表关系运算符">表关系运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于</td>
<td>a==b</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>a!=b</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>a&gt;b</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>a&lt;b</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
<td>a&gt;=b</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于或等于</td>
<td>a&lt;=b</td>
</tr>
</tbody>
</table>
<h2 id="注意事项">注意事项</h2>
<pre><code>=是赋值运算符，而真正的判断两个操作数是否相等的运算符是==。

==、!= 是所有（基本和引用）数据类型都可以使用

&gt; 、&gt;=、 &lt;、 &lt;= 仅针对数值类型（byte/short/int/long,  float/double。以及char）</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.7.2 赋值及其扩展赋值运算符</title>
			<link>https://HarryQing.github.io/posts/2.7.2-%E8%B5%8B%E5%80%BC%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Sat, 23 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.2-%E8%B5%8B%E5%80%BC%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>赋值及其扩展运算符    运算符 用法举例 等效的表达式     += a += b a = a+b   -= a -= b a = a-b   *= a *= b a = a*b   /= a /= b a = a/b   %= a%= b a = a%b    【示例2-21】 扩展运算符
int a=3;int b=4;a+=b;//相当于a=a+b;System.out.println(&amp;quot;a=&amp;quot;+a+&amp;quot;\nb=&amp;quot;+b);a=3;a*=b+3;//相当于a=a*(b+3)System.out.println(&amp;quot;a=&amp;quot;+a+&amp;quot;\nb=&amp;quot;+b); </description>
			<content type="html"><![CDATA[<h2 id="赋值及其扩展运算符">赋值及其扩展运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>用法举例</th>
<th>等效的表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>+=</td>
<td>a += b</td>
<td>a = a+b</td>
</tr>
<tr>
<td>-=</td>
<td>a -= b</td>
<td>a = a-b</td>
</tr>
<tr>
<td>*=</td>
<td>a *= b</td>
<td>a = a*b</td>
</tr>
<tr>
<td>/=</td>
<td>a /= b</td>
<td>a = a/b</td>
</tr>
<tr>
<td>%=</td>
<td>a%= b</td>
<td>a = a%b</td>
</tr>
</tbody>
</table>
<p><strong>【示例2-21】</strong> 扩展运算符</p>
<pre><code>int a=3;
int b=4;
a+=b;//相当于a=a+b;
System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);
a=3;
a*=b+3;//相当于a=a*(b+3)
System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494930157621902.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>2.7 运算符(operator) </title>
			<link>https://HarryQing.github.io/posts/2.7-%E8%BF%90%E7%AE%97%E7%AC%A6operator/</link>
			<pubDate>Fri, 22 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7-%E8%BF%90%E7%AE%97%E7%AC%A6operator/</guid>
			<description>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操作变量。
运算符分类 算术运算符	二元运算符	+，-，*，/，% 算术运算符	一元运算符	++，--|赋值运算符	= 扩展运算符	+=，-=，*=，/=|关系运算符	&amp;gt;，&amp;lt;，&amp;gt;=，&amp;lt;=，==，!= instanceof逻辑运算符	&amp;amp;&amp;amp;，||，!，^ 位运算符	&amp;amp;，|，^，~ ， &amp;gt;&amp;gt;，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;&amp;gt;条件运算符	? :字符串连接符	+ </description>
			<content type="html"><![CDATA[<p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操作变量。</p>
<h2 id="运算符分类">运算符分类</h2>
<pre><code>算术运算符	 二元运算符	+，-，*，/，% 
算术运算符	一元运算符	++，--|

赋值运算符		= 
扩展运算符		+=，-=，*=，/=|
关系运算符		&gt;，&lt;，&gt;=，&lt;=，==，!=  instanceof
逻辑运算符		&amp;&amp;，||，!，^ 
位运算符			&amp;，|，^，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt;
条件运算符		? :
字符串连接符		+
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.7.1 算术运算符</title>
			<link>https://HarryQing.github.io/posts/2.7.1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Fri, 22 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.7.1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>算术运算符中+，-，*，/，%属于二元运算符，二元运算符指的是需要两个操作数才能完成运算的运算符。其中的%是取模运算符，就是我们常说的求余数操作。
二元运算符的运算规则： 整数运算：    如果两个操作数有一个为Long, 则结果也为long。
  没有long时，结果为int。即使操作数全为short，byte，结果也是int。
   浮点运算：   如果两个操作数有一个为double，则结果为double。
  只有两个操作数都是float，则结果才为float。
   取模运算： 1.其操作数可以为浮点数,一般使用整数，结果是“余数”，“余数”符号和左边操作数相同，如：7%3=1，-7%3=-1，7%-3=1。
算术运算符中++，&amp;ndash;属于一元运算符，该类运算符只需要一个操作数。
【示例2-20】 一元运算符++与&amp;ndash;
int a = 3;int b = a++; //执行完后,b=3。先给b赋值，再自增。System.out.println(&amp;quot;a=&amp;quot;+a+&amp;quot;\nb=&amp;quot;+b);a = 3;b = ++a; //执行完后,c=5。a先自增，再给c赋值System.out.println(&amp;quot;a=&amp;quot;+a+&amp;quot;\nb=&amp;quot;+b); </description>
			<content type="html"><![CDATA[<p>算术运算符中+，-，*，/，%属于二元运算符，二元运算符指的是需要两个操作数才能完成运算的运算符。其中的%是取模运算符，就是我们常说的求余数操作。</p>
<h2 id="二元运算符的运算规则">二元运算符的运算规则：</h2>
<h3 id="整数运算">整数运算：</h3>
<blockquote>
<ol>
<li>
<p>如果两个操作数有一个为Long, 则结果也为long。</p>
</li>
<li>
<p>没有long时，结果为int。即使操作数全为short，byte，结果也是int。</p>
</li>
</ol>
</blockquote>
<h3 id="浮点运算">浮点运算：</h3>
<blockquote>
<ol start="3">
<li>
<p>如果两个操作数有一个为double，则结果为double。</p>
</li>
<li>
<p>只有两个操作数都是float，则结果才为float。</p>
</li>
</ol>
</blockquote>
<h2 id="取模运算">取模运算：</h2>
<p>1.其操作数可以为浮点数,一般使用整数，结果是“余数”，“余数”符号和左边操作数相同，如：7%3=1，-7%3=-1，7%-3=1。</p>
<p>算术运算符中++，&ndash;属于一元运算符，该类运算符只需要一个操作数。</p>
<p><strong>【示例2-20】</strong> 一元运算符++与&ndash;</p>
<pre><code>int a = 3;
int b = a++;   //执行完后,b=3。先给b赋值，再自增。
System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);
a = 3;
b = ++a;   //执行完后,c=5。a先自增，再给c赋值
System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);
</code></pre>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170608/1496920717563184.png" alt="enter description here"></p>
]]></content>
		</item>
		
		<item>
			<title>2.6.4 boolean类型变量/常量</title>
			<link>https://HarryQing.github.io/posts/2.6.4-boolean%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F/</link>
			<pubDate>Thu, 21 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.6.4-boolean%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F/</guid>
			<description>boolean类型有两个常量值，true和false，在内存中占一位（不是一个字节），不可以使用 0 或非 0 的整数替代 true 和 false ，这点和C语言不同。 boolean 类型用来判断逻辑条件，一般用于程序流程控制 。
【示例2-19】 boolean类型
 boolean flag ;flag = true; //或者flag=false;if(flag) {// true分支} else {// false分支} 老鸟建议 Less is More！！请不要这样写：if ( flag == true )，只有新手才那么写。关键也很容易写错成if(flag=true)，这样就变成赋值flag 为true而不是判断！老鸟的写法是if ( flag )或者if ( !flag)</description>
			<content type="html"><![CDATA[<p>boolean类型有两个常量值，true和false，在内存中占一位（不是一个字节），不可以使用 0 或非 0 的整数替代 true 和 false ，这点和C语言不同。 boolean 类型用来判断逻辑条件，一般用于程序流程控制 。</p>
<p><strong>【示例2-19】</strong> boolean类型</p>
<pre><code>    boolean flag ;
    flag = true;   //或者flag=false;
    if(flag) {
             // true分支
    } else {
             //  false分支
    }
</code></pre>
<h2 id="老鸟建议">老鸟建议</h2>
<p>Less is More！！请不要这样写：if ( flag == true )，只有新手才那么写。关键也很容易写错成if(flag=true)，这样就变成赋值flag 为true而不是判断！老鸟的写法是if ( flag )或者if ( !flag)</p>
]]></content>
		</item>
		
		<item>
			<title>2.6.3 字符型变量/常量</title>
			<link>https://HarryQing.github.io/posts/2.6.3-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F/</link>
			<pubDate>Wed, 20 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.6.3-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F/</guid>
			<description>字符型在内存中占2个字节，在Java中使用单引号来表示字符常量。例如’A’是一个字符，它与”A”是不同的，”A”表示含有一个字符的字符串。
char 类型用来表示在Unicode编码表中的字符。Unicode编码被设计用来处理各种语言的文字，它占2个字节，可允许有65536个字符。
【示例2-16】 字符型举例
char eChar = &#39;a&#39;; char cChar =&#39;中&#39;; Unicode具有从0到65535之间的编码，他们通常用从’\u0000’到’\uFFFF’之间的十六进制值来表示（前缀为u表示Unicode）
【示例2-17】 字符型的十六进制值表示方法
char c = &#39;\u0061&#39;; Java 语言中还允许使用转义字符 ‘\’ 来将其后的字符转变为其它的含义。常用的转义字符及其含义和Unicode值如表2-6所示。
【示例2-18】 转义字符
char c2 = &#39;\n&#39;; //代表换行符    转义符 含义 Unicode值     \b 退格（backspace） \u0008   \n 换行 \u000a   \r 回车 \u000d   \t 制表符（tab） \u0009   \“ 双引号 \u0022   \‘ 单引号 \u0027   \ 反斜杠 \u005c    注意事项 以后我们学的String类，其实是字符序列(char sequence)。</description>
			<content type="html"><![CDATA[<p>字符型在内存中占2个字节，在Java中使用单引号来表示字符常量。例如’A’是一个字符，它与”A”是不同的，”A”表示含有一个字符的字符串。</p>
<p>char 类型用来表示在Unicode编码表中的字符。Unicode编码被设计用来处理各种语言的文字，它占2个字节，可允许有65536个字符。</p>
<p><strong>【示例2-16】</strong> 字符型举例</p>
<pre><code>char eChar = 'a'; 
char cChar ='中';
</code></pre>
<p>Unicode具有从0到65535之间的编码，他们通常用从’\u0000’到’\uFFFF’之间的十六进制值来表示（前缀为u表示Unicode）</p>
<p><strong>【示例2-17】</strong> 字符型的十六进制值表示方法</p>
<pre><code>char c = '\u0061';
</code></pre>
<p>Java 语言中还允许使用转义字符 ‘\’ 来将其后的字符转变为其它的含义。常用的转义字符及其含义和Unicode值如表2-6所示。</p>
<p><strong>【示例2-18】</strong> 转义字符</p>
<pre><code>char c2 = '\n';  //代表换行符
</code></pre>
<table>
<thead>
<tr>
<th>转义符</th>
<th>含义</th>
<th>Unicode值</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>退格（backspace）</td>
<td>\u0008</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\u000a</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>\u000d</td>
</tr>
<tr>
<td>\t</td>
<td>制表符（tab）</td>
<td>\u0009</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
<td>\u0022</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
<td>\u0027</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
<td>\u005c</td>
</tr>
</tbody>
</table>
<h2 id="注意事项">注意事项</h2>
<p>以后我们学的String类，其实是字符序列(char sequence)。</p>
<h2 id="课堂代码">课堂代码</h2>
<pre><code>/**
 * 测试字符类型
 * @author 高淇
 *
 */
public class TestPrimitiveDataType3 {
    public static void main(String[] args) {
        char  a = 'T';
        char  b = '雪';
        char c = '\u0061';
        System.out.println(c);

        //转义字符
        System.out.println(&quot;&quot;+'a'+'\n'+'b'); 
        System.out.println(&quot;&quot;+'a'+'\t'+'b'); 
        System.out.println(&quot;&quot;+'a'+'\''+'b');        //a'b 


        //String就是字符序列
        String  d = &quot;abc&quot;;

    }
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.6.2 浮点型变量/常量</title>
			<link>https://HarryQing.github.io/posts/2.6.2-%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/</link>
			<pubDate>Mon, 11 Jan 2021 16:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.6.2-%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/</guid>
			<description>带小数的数据在Java中称为浮点型。浮点型可分为float类型和double类型。
   类型 占用存储空间 表数范围     float 4字节 -3.403E38~3.403E38   double 8字节 -1.798E308~1.798E308    float类型又被称作单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。而double表示这种类型的数值精度约是float类型的两倍，又被称作双精度类型，绝大部分应用程序都采用double类型。浮点型常量默认类型也是double。
Java浮点类型常量有两种表示形式 十进制数形式，例如:3.14 314.0 0.314 科学记数法形式，如314e2 314E2 314E-2 【示例2-11】 使用科学记数法给浮点型变量赋值
double f = 314e2; //314*10^2--&amp;gt;31400.0double f2 = 314e-2; //314*10^(-2)--&amp;gt;3.14 float类型的数值有一个后缀F或者f ，没有后缀F/f的浮点数值默认为double类型。也可以在浮点数值后添加后缀D或者d， 以明确其为double类型。
【示例2-12】 float类型赋值时需要添加后缀F/f
float f = 3.14F;double d1 = 3.14;double d2 = 3.14D; 老鸟建议 浮点类型float，double的数据不适合在不容许舍入误差的金融计算领域。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。
【示例2-13】 浮点数的比较一
float f = 0.1f;double d = 1.</description>
			<content type="html"><![CDATA[<p>带小数的数据在Java中称为浮点型。浮点型可分为float类型和double类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>-3.403E38~3.403E38</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>-1.798E308~1.798E308</td>
</tr>
</tbody>
</table>
<p>float类型又被称作单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。而double表示这种类型的数值精度约是float类型的两倍，又被称作双精度类型，绝大部分应用程序都采用double类型。浮点型常量默认类型也是double。</p>
<h2 id="java浮点类型常量有两种表示形式">Java浮点类型常量有两种表示形式</h2>
<h3 id="十进制数形式例如314-------3140------0314">十进制数形式，例如:3.14       314.0      0.314</h3>
<h3 id="科学记数法形式如314e2------314e2------314e-2">科学记数法形式，如314e2      314E2      314E-2</h3>
<p><strong>【示例2-11】</strong> 使用科学记数法给浮点型变量赋值</p>
<pre><code>double f = 314e2;  //314*10^2--&gt;31400.0
double f2 = 314e-2; //314*10^(-2)--&gt;3.14
</code></pre>
<p>float类型的数值有一个后缀F或者f ，没有后缀F/f的浮点数值默认为double类型。也可以在浮点数值后添加后缀D或者d， 以明确其为double类型。</p>
<p><strong>【示例2-12】</strong> float类型赋值时需要添加后缀F/f</p>
<pre><code>float  f = 3.14F;
double d1  = 3.14;
double d2 = 3.14D;
</code></pre>
<h3 id="老鸟建议">老鸟建议</h3>
<p>浮点类型float，double的数据不适合在不容许舍入误差的金融计算领域。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。</p>
<p><strong>【示例2-13】</strong> 浮点数的比较一</p>
<pre><code>float f = 0.1f;
double d = 1.0/10;
System.out.println(f==d);//结果为false
</code></pre>
<p><strong>【示例2-14】</strong> 浮点数的比较二</p>
<pre><code>float d1 = 423432423f;
float d2 = d1+1;
if(d1==d2){
   System.out.println(&quot;d1==d2&quot;);//输出结果为d1==d2
}else{
    System.out.println(&quot;d1!=d2&quot;);
}
</code></pre>
<p>运行以上两个示例，发现示例2-13的结果是“false”，而示例2-14的输出结果是“d1==d2”。这是因为由于字长有限，浮点数能够精确表示的数是有限的，因而也是离散的。 浮点数一般都存在舍入误差，很多数字无法精确表示(例如0.1)，其结果只能是接近， 但不等于。二进制浮点数不能精确的表示0.1、0.01、0.001这样10的负次幂。并不是所有的小数都能可以精确的用二进制浮点数表示。</p>
<p>java.math包下面的两个有用的类：BigInteger和BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。</p>
<h3 id="菜鸟雷区">菜鸟雷区</h3>
<p>1.不要使用浮点数进行比较！很多新人甚至很多理论不扎实的有工作经验的程序员也会犯这个错误！需要比较请使用BigDecimal类</p>
<p><strong>【示例2-15】</strong> 使用BigDecimal进行浮点数的比较</p>
<pre><code>import java.math.BigDecimal;
public class Main {
    public static void main(String[] args) {
        BigDecimal bd = BigDecimal.valueOf(1.0);
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        System.out.println(bd);//0.5
        System.out.println(1.0 - 0.1 - 0.1 - 0.1 - 0.1 - 0.1);//0.5000000000000001
    }
}
</code></pre>
<h2 id="浮点数使用总结">浮点数使用总结</h2>
<p>1.默认是double类型</p>
<p>2.浮点数存在舍入误差，数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。</p>
<p>3.避免比较中使用浮点数，需要比较请使用BigDecimal类</p>
]]></content>
		</item>
		
		<item>
			<title>2.6.1 整型变量/常量</title>
			<link>https://HarryQing.github.io/posts/2.6.1-%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/</link>
			<pubDate>Mon, 11 Jan 2021 12:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.6.1-%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/</guid>
			<description>整型用于表示没有小数部分的数值，它允许是负数。整型的范围与运行Java代码的机器无关，这正是Java程序具有很强移植能力的原因之一。与此相反，C和C++程序需要针对不同的处理器选择最有效的整型。
   类型 占用存储空间 表数范围     byte 1字节 -2^7 ~ 2^7-1（-128~127）   short 2字节 -2^15 ~ 2^15-1（-32768~32767）   int 4字节 -2^31 ~ 2^31-1 (-2147483648~2147483647)约21   long 8字节 -2^63 ~ 2^63-1    Java 语言整型常量的四种表示形式 十进制整数，如：99, -500, 0 八进制整数，要求以 0 开头，如：015 十六进制数，要求 0x 或 0X 开头，如：0x15 二进制数，要求0b或0B开头，如：0b01110011 Java语言的整型常数默认为int型，声明long型常量可以后加‘ l ’或‘ L ’ 。
【示例2-10】 长整型常数的声明
long a = 55555555; //编译成功，在int表示的范围内(21亿内)。long b = 55555555555;//不加L编译错误，已经超过int表示的范围。 我们修改成long类型的常量即可：</description>
			<content type="html"><![CDATA[<p>整型用于表示没有小数部分的数值，它允许是负数。整型的范围与运行Java代码的机器无关，这正是Java程序具有很强移植能力的原因之一。与此相反，C和C++程序需要针对不同的处理器选择最有效的整型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1字节</td>
<td>-2^7 ~   2^7-1（-128~127）</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-2^15 ~   2^15-1（-32768~32767）</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2^31 ~   2^31-1 (-2147483648~2147483647)约21</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-2^63 ~   2^63-1</td>
</tr>
</tbody>
</table>
<h2 id="java-语言整型常量的四种表示形式">Java 语言整型常量的四种表示形式</h2>
<h3 id="十进制整数如99--500-0">十进制整数，如：99, -500, 0</h3>
<h3 id="八进制整数要求以-0-开头如015">八进制整数，要求以 0 开头，如：015</h3>
<h3 id="十六进制数要求-0x-或-0x-开头如0x15">十六进制数，要求 0x 或 0X 开头，如：0x15</h3>
<h3 id="二进制数要求0b或0b开头如0b01110011">二进制数，要求0b或0B开头，如：0b01110011</h3>
<p>Java语言的整型常数默认为int型，声明long型常量可以后加‘ l ’或‘ L ’ 。</p>
<p><strong>【示例2-10】</strong> 长整型常数的声明</p>
<pre><code>long a = 55555555;  //编译成功，在int表示的范围内(21亿内)。
long b = 55555555555;//不加L编译错误，已经超过int表示的范围。
</code></pre>
<p>我们修改成long类型的常量即可：</p>
<pre><code>long b = 55555555555L;</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.6 基本数据类型(primitive data type)</title>
			<link>https://HarryQing.github.io/posts/2.6-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bprimitive-data-type/</link>
			<pubDate>Mon, 11 Jan 2021 09:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.6-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bprimitive-data-type/</guid>
			<description>Java是一种强类型语言，每个变量都必须声明其数据类型。 Java的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。
Java中定义了3类8种基本数据类型 数值型－ byte、 short、int、 long、float、 double 字符型－ char 布尔型－boolean 注意事项 1.引用数据类型的大小统一为4个字节，记录的是其引用对象的地址！
2.本章只讲解基本数据类型。引用数据类型在后续数组和面向对象章节讲解。</description>
			<content type="html"><![CDATA[<p>Java是一种强类型语言，每个变量都必须声明其数据类型。 Java的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。</p>
<h2 id="java中定义了3类8种基本数据类型">Java中定义了3类8种基本数据类型</h2>
<h3 id="数值型-byte-shortint-longfloat-double">数值型－ byte、 short、int、 long、float、 double</h3>
<h3 id="字符型-char">字符型－ char</h3>
<h3 id="布尔型boolean">布尔型－boolean</h3>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170607/1496834727293971.png" alt=""></p>
<h2 id="注意事项">注意事项</h2>
<p>1.引用数据类型的大小统一为4个字节，记录的是其引用对象的地址！</p>
<p>2.本章只讲解基本数据类型。引用数据类型在后续数组和面向对象章节讲解。</p>
]]></content>
		</item>
		
		<item>
			<title>2.5 常量(Constant)</title>
			<link>https://HarryQing.github.io/posts/2.5-%E5%B8%B8%E9%87%8Fconstant/</link>
			<pubDate>Mon, 11 Jan 2021 05:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.5-%E5%B8%B8%E9%87%8Fconstant/</guid>
			<description>常量通常指的是一个固定的值，例如：1、2、3、’a’、’b’、true、false、”helloWorld”等。
在Java语言中，主要是利用关键字final来定义一个常量。 常量一旦被初始化后不能再更改其值。
声明格式为： final type varName = value; 【示例2-9】 常量的声明及使用
public class TestConstants {public static void main(String[] args) {final double PI = 3.14;// PI = 3.15; //编译错误，不能再被赋值！ double r = 4;double area = PI * r * r;double circle = 2 * PI * r;System.out.println(&amp;quot;area = &amp;quot; + area);System.out.println(&amp;quot;circle = &amp;quot; + circle);}} 为了更好的区分和表述，一般将1、2、3、’a’、’b’、true、false、”helloWorld”等称为字面常量，而使用final修饰的PI等称为符号常量。
老鸟建议 变量和常量命名规范（规范是程序员的基本准则，不规范会直接损害你的个人形象）：
1.所有变量、方法、类名：见名知意
2.类成员变量：首字母小写和驼峰原则: monthSalary</description>
			<content type="html"><![CDATA[<p>常量通常指的是一个固定的值，例如：1、2、3、’a’、’b’、true、false、”helloWorld”等。</p>
<p>在Java语言中，主要是利用关键字final来定义一个常量。 常量一旦被初始化后不能再更改其值。</p>
<h3 id="声明格式为">声明格式为：</h3>
<pre><code>final  type  varName = value;
</code></pre>
<p><strong>【示例2-9】</strong> 常量的声明及使用</p>
<pre><code>public class TestConstants {
    public static void main(String[] args) {
        final double PI = 3.14;
        // PI = 3.15; //编译错误，不能再被赋值！ 
        double r = 4;
        double area = PI * r * r;
        double circle = 2 * PI * r;
        System.out.println(&quot;area = &quot; + area);
        System.out.println(&quot;circle = &quot; + circle);
    }
}
</code></pre>
<p>为了更好的区分和表述，一般将1、2、3、’a’、’b’、true、false、”helloWorld”等称为字面常量，而使用final修饰的PI等称为符号常量。</p>
<h2 id="老鸟建议">老鸟建议</h2>
<p>变量和常量命名规范（规范是程序员的基本准则，不规范会直接损害你的个人形象）：</p>
<p>1.所有变量、方法、类名：见名知意</p>
<p>2.类成员变量：首字母小写和驼峰原则:  monthSalary</p>
<p>3.局部变量：首字母小写和驼峰原则</p>
<p>4.常量：大写字母和下划线：MAX_VALUE</p>
<p>5.类名：首字母大写和驼峰原则:  Man, GoodMan</p>
<p>6.方法名：首字母小写和驼峰原则: run(), runRun()</p>
]]></content>
		</item>
		
		<item>
			<title>2.4.2 变量的分类</title>
			<link>https://HarryQing.github.io/posts/2.4.2-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB/</link>
			<pubDate>Sat, 09 Jan 2021 19:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.4.2-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB/</guid>
			<description>从整体上可将变量划分为局部变量、成员变量(也称为实例变量)和静态变量。
   类型 声明位置 从属于 生命周期     局部变量 方法或语句块内部 方法/语句块 从声明位置开始，直到方法或语句块执行完毕，局部变量消失   成员变量(实例变量) 类内部，方法外部 对象 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失；   静态变量(类变量) 类内部，static修饰 类 类被加载，静态变量就有效；类被卸载，静态变量消失。    老鸟建议 成员变量和静态变量不是目前重点，不要过多纠结理解与否。我们学习面向对象时，再重点讲解成员变量和静态变量
· 局部变量(local variable) 方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。
【示例2-7】 局部变量
public void test() {int i;int j = i+5 ; // 编译出错，变量i还未被初始化 } public void test() {int i;i=10;int j = i+5 ; // 编译正确} · 成员变量（也叫实例变量 member variable） 方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。</description>
			<content type="html"><![CDATA[<p>从整体上可将变量划分为局部变量、成员变量(也称为实例变量)和静态变量。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>声明位置</th>
<th>从属于</th>
<th>生命周期</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量</td>
<td>方法或语句块内部</td>
<td>方法/语句块</td>
<td>从声明位置开始，直到方法或语句块执行完毕，局部变量消失</td>
</tr>
<tr>
<td>成员变量(实例变量)</td>
<td>类内部，方法外部</td>
<td>对象</td>
<td>对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失；</td>
</tr>
<tr>
<td>静态变量(类变量)</td>
<td>类内部，static修饰</td>
<td>类</td>
<td>类被加载，静态变量就有效；类被卸载，静态变量消失。</td>
</tr>
</tbody>
</table>
<h3 id="老鸟建议">老鸟建议</h3>
<p>成员变量和静态变量不是目前重点，不要过多纠结理解与否。我们学习面向对象时，再重点讲解成员变量和静态变量</p>
<h2 id="-局部变量local--variable">· 局部变量(local  variable)</h2>
<p>方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。</p>
<p><strong>【示例2-7】</strong> 局部变量</p>
<pre><code>public void test() {
   int i;
   int j = i+5 ; // 编译出错，变量i还未被初始化 
} 

public void test() {
   int i;
   i=10;
   int j = i+5 ; // 编译正确
}
</code></pre>
<h2 id="-成员变量也叫实例变量--member-variable">· 成员变量（也叫实例变量  member variable）</h2>
<p>方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。</p>
<table>
<thead>
<tr>
<th>实例变量的默认初始值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>实始值</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>【示例2-8】</strong> 实例变量的声明</p>
<pre><code>public class Test {
    int i;
}
</code></pre>
<h2 id="--静态变量类变量-static-variable">·  静态变量（类变量 static variable）</h2>
<p>使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。 (注：讲完内存分析后我们再深入！先放一放这个概念！)如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值，如表 2-3所示。</p>
<h3 id="课堂练习1变量的声明并赋值">课堂练习1：变量的声明并赋值</h3>
<pre><code>public class LocalVariableTest {
  public static void main(String[ ] args) {
      boolean flag = true;  // 声明boolean型变量并赋值
       char c1, c2;   // 声明char型变量
       c1 = '\u0041';   // 为char型变量赋值
      c2 = 'B';   // 为char型变量赋值
      int x;   // 声明int型变量
      x = 9;  //为int型变量赋值  
       int y = x;  // 声明并初始化int型变量
       float f = 3.15f;   // 声明float型变量并赋值
      double d = 3.1415926;  //声明double型变量并赋值
         }
}
</code></pre>
<h3 id="课堂代码">课堂代码：</h3>
<pre><code>/**
 * 测试变量
 * 
 * @author 王雪庆
 *
 */
public class TestVariable {

    int a;            //成员变量, 从属于对象； 成员变量会自动被初始化
    static  int  size;   //静态变量，从属于类

    public static void main(String[] args) {

        {
            int age;        //局部变量，从属于语句块；
            age = 18;
        }

        int salary = 3000;    //局部变量，从属于方法

        int gao = 13;
        System.out.println(gao);

        int i;
    //    int j = i + 5; // 编译出错，变量i还未被初始化

    }
}
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.4.1 变量的本质</title>
			<link>https://HarryQing.github.io/posts/2.4.1-%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/</link>
			<pubDate>Sat, 09 Jan 2021 15:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.4.1-%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid>
			<description>变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的值。
Java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。 比如，int a=3; 表示a变量的空间大小为4个字节。
变量作为程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储空间。
·变量的声明 格式为：
 type varName [=value][,varName[=value]&amp;hellip;];
//[]中的内容为可选项，即可有可无
数据类型 变量名 [=初始值] [,变量名 [=初始值]…];
 【示例2-4】 声明变量：
double salary;long earthPopulation;int age; 不同数据类型的常量会在内存中分配不同的空间，如图所示。
注意事项 1.每个变量都有类型，类型可以是基本类型，也可以是引用类型。
2.变量名必须是合法的标识符
3.变量声明是一条完整的语句，因此每一个声明都必须以分号结束
【示例2-5】 在一行中声明多个变量
int i ,j; // 两个变量的数据类型都是int 老鸟建议 不提倡这种&amp;quot;一行声明多个变量&amp;quot;风格，逐一声明每一个变量可以提高程序可读性。
【示例2-6】 可以将变量的声明和初始化放在同一行中
int age = 18; double e = 2.718281828; </description>
			<content type="html"><![CDATA[<p>变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的值。</p>
<p>Java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。 比如，int a=3; 表示a变量的空间大小为4个字节。</p>
<p>变量作为程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储空间。</p>
<h2 id="变量的声明">·变量的声明</h2>
<p>格式为：</p>
<blockquote>
<p>type  varName [=value][,varName[=value]&hellip;];</p>
<p>//[]中的内容为可选项，即可有可无</p>
<p>数据类型  变量名  [=初始值] [,变量名  [=初始值]…];</p>
</blockquote>
<p><strong>【示例2-4】</strong> 声明变量：</p>
<pre><code>double  salary;
long  earthPopulation;
int  age;
</code></pre>
<p>不同数据类型的常量会在内存中分配不同的空间，如图所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494899385622782.png" alt=""></p>
<h3 id="注意事项">注意事项</h3>
<p>1.每个变量都有类型，类型可以是基本类型，也可以是引用类型。</p>
<p>2.变量名必须是合法的标识符</p>
<p>3.变量声明是一条完整的语句，因此每一个声明都必须以分号结束</p>
<p><strong>【示例2-5】</strong> 在一行中声明多个变量</p>
<pre><code>int  i ,j; // 两个变量的数据类型都是int
</code></pre>
<h3 id="老鸟建议">老鸟建议</h3>
<p>不提倡这种&quot;一行声明多个变量&quot;风格，逐一声明每一个变量可以提高程序可读性。</p>
<p><strong>【示例2-6】</strong> 可以将变量的声明和初始化放在同一行中</p>
<pre><code>int  age = 18;    
double  e = 2.718281828;</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.3 Java中的关键字/保留字</title>
			<link>https://HarryQing.github.io/posts/2.3-java%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97~%E4%BF%9D%E7%95%99%E5%AD%97/</link>
			<pubDate>Sat, 09 Jan 2021 12:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.3-java%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97~%E4%BF%9D%E7%95%99%E5%AD%97/</guid>
			<description>Java关键字是Java语言保留供内部使用的，如class用于定义类。 关键字也可以称为保留字，它们的意思是一样的，我们不能使用关键字作为变量名或方法名。
abstract assert boolean break byte case
catch char class const continue default
do double else extends final finally
float for goto if implements import
instanceof int interface long native new
菜鸟雷区 出于应试教育的惯性思维，很多新手很可能去背上面的单词，从实战思维出发，我们不需要刻意去记！随着学习的深入，自然就非常熟悉了。</description>
			<content type="html"><![CDATA[<p>Java关键字是Java语言保留供内部使用的，如class用于定义类。 关键字也可以称为保留字，它们的意思是一样的，我们不能使用关键字作为变量名或方法名。</p>
<p>abstract assert boolean break byte case</p>
<p>catch char class const continue default</p>
<p>do double else extends final finally</p>
<p>float for goto if implements import</p>
<p>instanceof int interface long native new</p>
<h3 id="菜鸟雷区">菜鸟雷区</h3>
<p>出于应试教育的惯性思维，很多新手很可能去背上面的单词，从实战思维出发，我们不需要刻意去记！随着学习的深入，自然就非常熟悉了。</p>
]]></content>
		</item>
		
		<item>
			<title>2.2 标识符</title>
			<link>https://HarryQing.github.io/posts/2.2-%E6%A0%87%E8%AF%86%E7%AC%A6/</link>
			<pubDate>Sat, 09 Jan 2021 09:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.2-%E6%A0%87%E8%AF%86%E7%AC%A6/</guid>
			<description>标识符是用来给变量、类、方法以及包进行命名的，如Welcome、main、System、age、name、gender等。标识符需要遵守一定的规则：
1.标识符必须以字母、下划线_、美元符号$开头。 2.标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。 3.Java 标识符大小写敏感，且长度无限制。 4.标识符不可以是Java的关键字。 标识符的使用规范 1.表示类名的标识符：每个单词的首字母大写，如Man, GoodMan
2.表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字母大写，我们称之为“驼峰原则”，如eat(), eatFood()
【注意】：Java不采用通常语言使用的ASCII字符集，而是采用Unicode这样标准的国际字符集。因此，这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议大家使用汉字来定义标识符！
【示例2-2】合法的标识符
int a = 3;int _123 = 3;int $12aa = 3;int 变量1 = 55; //合法，但是不建议使用中文命名的标识符 【示例2-3】不合法的标识符
int 1a = 3; //不能用数字开头int a# = 3; //不能包含#这样的特殊字符int int = 3; //不能使用关键字 测试代码：
/*** 测试标识符的用法* @author 王雪庆**/public class TestIdentifer {//能力是练出来的，不是看书看出来的。对于初学者来说，再简单的代码也一定要敲一下！public static void main(String[] args) {int a123 = 1;//int 123abc = 2; //数字不能开头int $a = 3;int _abc = 4;//int #abc = 5;int 年龄 = 18; //可以使用汉字，但是一般不建议//int class = 2; //关键字不能作为标识符}} </description>
			<content type="html"><![CDATA[<p>标识符是用来给变量、类、方法以及包进行命名的，如Welcome、main、System、age、name、gender等。标识符需要遵守一定的规则：</p>
<h3 id="1标识符必须以字母下划线_美元符号开头">1.标识符必须以字母、下划线_、美元符号$开头。</h3>
<h3 id="2标识符其它部分可以是字母下划线_美元符和数字的任意组合">2.标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。</h3>
<h3 id="3java-标识符大小写敏感且长度无限制">3.Java 标识符大小写敏感，且长度无限制。</h3>
<h3 id="4标识符不可以是java的关键字">4.标识符不可以是Java的关键字。</h3>
<h2 id="标识符的使用规范">标识符的使用规范</h2>
<p>1.表示类名的标识符：每个单词的首字母大写，如Man, GoodMan</p>
<p>2.表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字母大写，我们称之为“驼峰原则”，如eat(), eatFood()</p>
<p><strong>【注意】</strong>：Java不采用通常语言使用的ASCII字符集，而是采用Unicode这样标准的国际字符集。因此，这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议大家使用汉字来定义标识符！</p>
<p>【示例2-2】合法的标识符</p>
<pre><code>int  a = 3;
int  _123 = 3;
int  $12aa = 3;
int  变量1 = 55;  //合法，但是不建议使用中文命名的标识符
</code></pre>
<p>【示例2-3】不合法的标识符</p>
<pre><code>int  1a = 3;   //不能用数字开头
int  a# = 3;   //不能包含#这样的特殊字符
int  int = 3;  //不能使用关键字
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code>/**
 * 测试标识符的用法
 * @author 王雪庆
 *
 */
public class TestIdentifer {

    //能力是练出来的，不是看书看出来的。对于初学者来说，再简单的代码也一定要敲一下！
    public static void main(String[] args) {
        int  a123 = 1;
        //int  123abc = 2;        //数字不能开头
        int  $a = 3;
        int  _abc = 4;
        //int  #abc = 5;

        int  年龄 = 18;        //可以使用汉字，但是一般不建议

        //int class = 2;        //关键字不能作为标识符

    }
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>2.1 注释</title>
			<link>https://HarryQing.github.io/posts/2.1-%E6%B3%A8%E9%87%8A/</link>
			<pubDate>Sat, 09 Jan 2021 05:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/2.1-%E6%B3%A8%E9%87%8A/</guid>
			<description>为了方便程序的阅读，Java语言允许程序员在程序中写上一些说明性的文字，用来提高程序的可读性，这些文字性的说明就称为注释。 注释不会出现在字节码文件中，即Java编译器编译时会跳过注释语句。 在Java中根据注释的功能不同，主要分为单行注释、多行注释和文档注释。
单行注释： 使用“//”开头，“//”后面的单行内容均为注释。 多行注释： 以“/* ”开头以“* /”结尾，在“/* ”和“* /”之间的内容为注释，我们也可以使用多行注释作为行内注释。但是在使用时要注意，多行注释不能嵌套使用。 文档注释： 以“/** ”开头以“* /”结尾，注释中包含一些说明性的文字及一些JavaDoc标签(后期写项目时，可以生成项目的API) 【示例2-1】认识Java的三种注释类型
/*** Welcome类（我是文档注释）* @author 王雪庆* @version 1.0*/public class Welcome {//我是单行注释public static void main(String[] args/*我是行内注释 */) {System.out.println(&amp;quot;Hello World!&amp;quot;);}/*我是多行注释！我是多行注释！*/} </description>
			<content type="html"><![CDATA[<p>为了方便程序的阅读，Java语言允许程序员在程序中写上一些说明性的文字，用来提高程序的可读性，这些文字性的说明就称为注释。 注释不会出现在字节码文件中，即Java编译器编译时会跳过注释语句。 在Java中根据注释的功能不同，主要分为单行注释、多行注释和文档注释。</p>
<h4 id="单行注释--使用开头后面的单行内容均为注释">单行注释：  使用“//”开头，“//”后面的单行内容均为注释。</h4>
<h4 id="多行注释---以-开头以-结尾在-和-之间的内容为注释我们也可以使用多行注释作为行内注释但是在使用时要注意多行注释不能嵌套使用">多行注释：   以“/* ”开头以“* /”结尾，在“/* ”和“* /”之间的内容为注释，我们也可以使用多行注释作为行内注释。但是在使用时要注意，多行注释不能嵌套使用。</h4>
<h4 id="文档注释---以-开头以-结尾注释中包含一些说明性的文字及一些javadoc标签后期写项目时可以生成项目的api">文档注释：   以“/** ”开头以“* /”结尾，注释中包含一些说明性的文字及一些JavaDoc标签(后期写项目时，可以生成项目的API)</h4>
<p>【示例2-1】认识Java的三种注释类型</p>
<pre><code>/**
 * Welcome类（我是文档注释）
 * @author 王雪庆
 * @version 1.0
 */
public class Welcome {
    //我是单行注释
    public static void main(String[] args/*我是行内注释 */) {
        System.out.println(&quot;Hello World!&quot;);
    }
    /*
       我是多行注释！
       我是多行注释！
     */
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>第二章 数据类型和运算符</title>
			<link>https://HarryQing.github.io/posts/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
			<pubDate>Tue, 05 Jan 2021 14:14:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
			<description>目录 2.1 注释 2.2 标识符 2.3 Java中的关键字/保留字 2.4.1 变量的本质 2.4.2 变量的分类 2.5 常量(Constant) 2.6 基本数据类型(primitive data type) 2.6.1 整型变量/常量 2.6.2 浮点型变量/常量 2.6.3 字符型变量/常量 2.6.4 boolean类型变量/常量 2.7 运算符(operator) 2.7.1 算术运算符 2.7.2 赋值及其扩展赋值运算符 2.7.3 关系运算符 2.7.4 逻辑运算符 2.7.5 位运算符 2.7.6 字符串连接符 2.7.7 条件运算符 2.7.8 运算符优先级的问题 2.8.1 自动类型转换 2.8.2 强制类型转换 2.8.3 基本类型转化时常见错误和问题 2.9 简单的键盘输入和输出 </description>
			<content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="21-注释">2.1 注释</h2>
<h2 id="22-标识符">2.2 标识符</h2>
<h2 id="23-java中的关键字保留字">2.3 Java中的关键字/保留字</h2>
<h2 id="241-变量的本质">2.4.1 变量的本质</h2>
<h2 id="242-变量的分类">2.4.2 变量的分类</h2>
<h2 id="25-常量constant">2.5 常量(Constant)</h2>
<h2 id="26-基本数据类型primitive-data-type">2.6 基本数据类型(primitive data type)</h2>
<h2 id="261-整型变量常量">2.6.1 整型变量/常量</h2>
<h2 id="262-浮点型变量常量">2.6.2 浮点型变量/常量</h2>
<h2 id="263-字符型变量常量">2.6.3 字符型变量/常量</h2>
<h2 id="264-boolean类型变量常量">2.6.4 boolean类型变量/常量</h2>
<h2 id="27-运算符operator">2.7 运算符(operator)</h2>
<h2 id="271-算术运算符">2.7.1 算术运算符</h2>
<h2 id="272-赋值及其扩展赋值运算符">2.7.2 赋值及其扩展赋值运算符</h2>
<h2 id="273-关系运算符">2.7.3 关系运算符</h2>
<h2 id="274-逻辑运算符">2.7.4 逻辑运算符</h2>
<h2 id="275-位运算符">2.7.5 位运算符</h2>
<h2 id="276-字符串连接符">2.7.6 字符串连接符</h2>
<h2 id="277-条件运算符">2.7.7 条件运算符</h2>
<h2 id="278-运算符优先级的问题">2.7.8 运算符优先级的问题</h2>
<h2 id="281-自动类型转换">2.8.1 自动类型转换</h2>
<h2 id="282-强制类型转换">2.8.2 强制类型转换</h2>
<h2 id="283-基本类型转化时常见错误和问题">2.8.3 基本类型转化时常见错误和问题</h2>
<h2 id="29-简单的键盘输入和输出">2.9 简单的键盘输入和输出</h2>
]]></content>
		</item>
		
		<item>
			<title>1.8 30分钟完成桌球小游戏项目</title>
			<link>https://HarryQing.github.io/posts/1.8-30%E5%88%86%E9%92%9F%E5%AE%8C%E6%88%90%E6%A1%8C%E7%90%83%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE/</link>
			<pubDate>Tue, 05 Jan 2021 09:14:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.8-30%E5%88%86%E9%92%9F%E5%AE%8C%E6%88%90%E6%A1%8C%E7%90%83%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE/</guid>
			<description>如下的小项目，对于第一次接触编程的朋友从理解上会有难度。但是，我们这个项目不在于让大家理解代码本身，而是让大家“重在体验敲代码的感觉”。
【项目】桌球游戏小项目 练习目标： 1.找到敲代码的感觉
2.收获敲代码的兴趣
3.作出效果，找到自信
4.从一开始就学会调试错误
5.掌握Java代码基本结构
项目需求： 桌球在球桌中按照一定线路和角度移动，遇到边框会自动弹回。
要求： 即使看不太懂，也要照着敲如下游戏代码，至少5遍。要求所有字符和源文件一致。如果报异常，请细心看所在行和老师代码有何区别。现阶段不需要理解代码的语法功能，只要按照代码结构输入代码，能够经过调试实现代码的正常运行即可。
项目中用到的两个小图片，如下：
开发步骤： 版本1： 目标：创建项目、创建窗口。
创建项目并拷贝图片：
在项目名MyPro01上单击右键，在菜单中依次选择new&amp;mdash;Folder，创建一个名称是images的文件夹，并复制两 张图片到该目录下。并在src下创建类BallGame.java。eclipse下项目的最终结构如图所示。
代码：
import java.awt.*;import javax.swing.*;public class BallGame extends JFrame {//窗口加载void launchFrame(){setSize(300,300);setLocation(400,400);setVisible(true);}//main方法是程序执行的入口public static void main(String[] args){System.out.println(&amp;quot; 我是尚学堂高淇，这个游戏项目让大家体验编程的快感，寓教于乐！&amp;quot;);BallGame game = new BallGame();game.launchFrame();}} 运行效果：
版本2： 目标：加载两个图片
代码：
import java.awt.*;import javax.swing.*;public class BallGame extends JFrame {Image ball = Toolkit.</description>
			<content type="html"><![CDATA[<p>如下的小项目，对于第一次接触编程的朋友从理解上会有难度。但是，我们这个项目不在于让大家理解代码本身，而是让大家“重在体验敲代码的感觉”。</p>
<h2 id="项目桌球游戏小项目">【项目】桌球游戏小项目</h2>
<h3 id="练习目标">练习目标：</h3>
<p>1.找到敲代码的感觉</p>
<p>2.收获敲代码的兴趣</p>
<p>3.作出效果，找到自信</p>
<p>4.从一开始就学会调试错误</p>
<p>5.掌握Java代码基本结构</p>
<h3 id="项目需求">项目需求：</h3>
<p>桌球在球桌中按照一定线路和角度移动，遇到边框会自动弹回。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170607/1496802487319356.png" alt=""></p>
<h3 id="要求">要求：</h3>
<p>即使看不太懂，也要照着敲如下游戏代码，至少5遍。要求所有字符和源文件一致。如果报异常，请细心看所在行和老师代码有何区别。现阶段不需要理解代码的语法功能，只要按照代码结构输入代码，能够经过调试实现代码的正常运行即可。</p>
<p><strong>项目中用到的两个小图片，如下</strong>：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170607/1496797408773563.png" alt=""></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170607/1496802557924525.jpg" alt=""></p>
<h2 id="开发步骤">开发步骤：</h2>
<h3 id="版本1">版本1：</h3>
<p>目标：创建项目、创建窗口。</p>
<p>创建项目并拷贝图片：</p>
<p>在项目名MyPro01上单击右键，在菜单中依次选择new&mdash;Folder，创建一个名称是images的文件夹，并复制两  张图片到该目录下。并在src下创建类BallGame.java。eclipse下项目的最终结构如图所示。</p>
<p><img src="http://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494925441201939.png" alt=""></p>
<p><strong>代码</strong>：</p>
<pre><code>import  java.awt.*;
import javax.swing.*;

public class BallGame extends JFrame {


     //窗口加载
     void launchFrame(){
         setSize(300,300);
         setLocation(400,400);
         setVisible(true);

     }

     //main方法是程序执行的入口
     public static void main(String[] args){
         System.out.println(&quot; 我是尚学堂高淇，这个游戏项目让大家体验编程的快感，寓教于乐！&quot;);
         BallGame game = new BallGame();
         game.launchFrame();
     }

}
</code></pre>
<p><strong>运行效果</strong>：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170607/1496805215766450.png" alt=""></p>
<h3 id="版本2">版本2：</h3>
<p>目标：加载两个图片</p>
<p>代码：</p>
<pre><code>import  java.awt.*;
import javax.swing.*;

public class BallGame extends JFrame {

    Image ball = Toolkit.getDefaultToolkit().getImage(&quot;images/ball.png&quot;);
    Image desk = Toolkit.getDefaultToolkit().getImage(&quot;images/desk.jpg&quot;);

    double  x=100;    //小球的横坐标
    double  y=100; //小球的纵坐标
    //画窗口的方法
    public void paint(Graphics  g){
        System.out.println(&quot;窗口被画了一次！&quot;);
        g.drawImage(desk, 0, 0, null);
        g.drawImage(ball, (int)x, (int)y, null);
    }

    //窗口加载
    void launchFrame(){
        setSize(856,500);
        setLocation(50,50);
        setVisible(true);
    }

    //main方法是程序执行的入口
    public static void main(String[] args){
        System.out.println(&quot; 我是尚学堂高淇，这个游戏项目让大家体验编程的快感，寓教于乐！&quot;);
        BallGame game = new BallGame();
        game.launchFrame();
    }

}
</code></pre>
<p><strong>运行效果</strong>：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170607/1496805504230973.png" alt=""></p>
<h3 id="版本3">版本3：</h3>
<p>目标：实现动画，小球沿着水平方向移动并做边界检测</p>
<p><strong>代码</strong>：</p>
<pre><code>import  java.awt.*;
import javax.swing.*;

public class BallGame extends JFrame {

    Image ball = Toolkit.getDefaultToolkit().getImage(&quot;images/ball.png&quot;);
    Image desk = Toolkit.getDefaultToolkit().getImage(&quot;images/desk.jpg&quot;);

    double  x=100;    //小球的横坐标
    double  y=100; //小球的纵坐标
    boolean  right = true;   //方向
    //画窗口的方法
    public void paint(Graphics  g){
        System.out.println(&quot;窗口被画了一次！&quot;);
        g.drawImage(desk, 0, 0, null);
        g.drawImage(ball, (int)x, (int)y, null);


        if(right){
            x = x +10;            
        }else{
            x = x - 10;
        }

        if(x&gt;856-40-30){    //856是窗口宽度，40是桌子边框的宽度，30是小球的直径
            right = false;
        }

        if(x&lt;40){        //40是桌子边框的宽度
            right = true;
        }


    }

    //窗口加载
    void launchFrame(){
        setSize(856,500);
        setLocation(50,50);
        setVisible(true);

        //重画窗口,每秒画25次
        while(true){
            repaint(); 
            try{
                Thread.sleep(40);   //40ms,   1秒=1000毫秒.  大约一秒画25次窗口
            }catch(Exception e){
                e.printStackTrace();
            }

        }

    }

    //main方法是程序执行的入口
    public static void main(String[] args){
        System.out.println(&quot; 我是尚学堂高淇，这个游戏项目让大家体验编程的快感，寓教于乐！&quot;);
        BallGame game = new BallGame();
        game.launchFrame();
    }

}
</code></pre>
<h3 id="版本4">版本4：</h3>
<p>目标：实现小球沿着任意角度飞行（会用到初中学习的三角函数，如果忘记了就想想你们的体育老师吧）</p>
<p><strong>代码</strong>：（为了保存版本3的代码，我们新创建了一个类BallGame2）</p>
<pre><code>import  java.awt.*;
import javax.swing.*;

public class BallGame2 extends JFrame {

    Image ball = Toolkit.getDefaultToolkit().getImage(&quot;images/ball.png&quot;);
    Image desk = Toolkit.getDefaultToolkit().getImage(&quot;images/desk.jpg&quot;);

    double  x=100;    //小球的横坐标
    double  y=100; //小球的纵坐标

    double degree = 3.14/3;    //弧度。此处就是：60度

    //画窗口的方法
    public void paint(Graphics  g){
        System.out.println(&quot;窗口被画了一次！&quot;);
        g.drawImage(desk, 0, 0, null);
        g.drawImage(ball,(int)x, (int)y, null);


        x  = x+ 10*Math.cos(degree);
        y  = y +10*Math.sin(degree); 

        //碰到上下边界
        if(y&gt;500-40-30||y&lt;40+40){//500是窗口高度；40是桌子边框，30是球直径；最后一个40是标题栏的高度
            degree = -degree;
        }

        //碰到左右边界
        if(x&lt;40||x&gt;856-40-30){
            degree = 3.14 - degree;
        }

    }

    //窗口加载
    void launchFrame(){
        setSize(856,500);
        setLocation(50,50);
        setVisible(true);

        //重画窗口,每秒画25次
        while(true){
            repaint(); 
            try{
                Thread.sleep(40);   //40ms,   1秒=1000毫秒.  大约一秒画25次窗口
            }catch(Exception e){
                e.printStackTrace();
            }

        }

    }

    //main方法是程序执行的入口
    public static void main(String[] args){
        System.out.println(&quot; 我是尚学堂高淇，这个游戏项目让大家体验编程的快感，寓教于乐！&quot;);
        BallGame2 game = new BallGame2();
        game.launchFrame();
    }

}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>1.7.3 使用eclipse开发和运行Java程序</title>
			<link>https://HarryQing.github.io/posts/1.7.3-%E4%BD%BF%E7%94%A8eclipse%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F/</link>
			<pubDate>Tue, 05 Jan 2021 05:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.7.3-%E4%BD%BF%E7%94%A8eclipse%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F/</guid>
			<description>·使用eclipse开发第一个程序 我们在上一节建好的Java项目中，开始开发Java程序。首先，新建一个Java类。在src目录上右键单击，建立一个Java类。如图1-32所示。
出现新建类的开始界面，如图所示。我们只需输入类名即可，其他不需做任何设置：
点击Finish后，新建Java类成功，出现如图所示
在src下面出现了Welcome.java文件。点击该文件后，出现该文件的代码编辑，我们开发Eclipse下的第一个Java程序。
【示例1-2】使用eclipse开发Java程序
public class Welcome {public static void main(String[] args) {System.out.println(&amp;quot;我是尚学堂的高淇！&amp;quot;);}} 运行该程序： 在代码上单击右键后，点击Run as Java application。如图所示。也可以使用快捷键“ctrl+F11”，直接实现运行。或者直接点击工具栏的中运行按钮。
界面下方的控制台（console）出现运行结果，如图所示。
至此，我们成功在eclipse中开发了我们的第一个Java程序！
·eclipse自动编译 eclipse会自动执行javac进行编译，并且会将编译错误直接给出提示，一目了然，非常便于我们调试。
·Java项目的src目录和bin目录 src用于存放源代码，bin用于存放生成的class文件。
在eclipse视图里我们只看到了src目录，eclipse隐藏了bin目录。进入我的电脑，打开Java项目目录，我们可以看到src和bin目录：</description>
			<content type="html"><![CDATA[<h2 id="使用eclipse开发第一个程序">·使用eclipse开发第一个程序</h2>
<p>我们在上一节建好的Java项目中，开始开发Java程序。首先，新建一个Java类。在src目录上右键单击，建立一个Java类。如图1-32所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842405992839.png" alt=""></p>
<p>出现新建类的开始界面，如图所示。我们只需输入类名即可，其他不需做任何设置：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842417827128.png" alt=""></p>
<p>点击Finish后，新建Java类成功，出现如图所示</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842430268879.png" alt=""></p>
<p>在src下面出现了Welcome.java文件。点击该文件后，出现该文件的代码编辑，我们开发Eclipse下的第一个Java程序。</p>
<p>【示例1-2】使用eclipse开发Java程序</p>
<pre><code>public class Welcome {
    public static void main(String[] args) {
        System.out.println(&quot;我是尚学堂的高淇！&quot;);
    }
}
</code></pre>
<p>运行该程序： 在代码上单击右键后，点击Run as  Java  application。如图所示。也可以使用快捷键“ctrl+F11”，直接实现运行。或者直接点击工具栏的中运行按钮。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842478482362.png" alt=""></p>
<p>界面下方的控制台（console）出现运行结果，如图所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842500265687.png" alt=""></p>
<p>至此，我们成功在eclipse中开发了我们的第一个Java程序！</p>
<h2 id="eclipse自动编译">·eclipse自动编译</h2>
<p>eclipse会自动执行javac进行编译，并且会将编译错误直接给出提示，一目了然，非常便于我们调试。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842517619975.png" alt=""></p>
<h2 id="java项目的src目录和bin目录">·Java项目的src目录和bin目录</h2>
<p>src用于存放源代码，bin用于存放生成的class文件。</p>
<p>在eclipse视图里我们只看到了src目录，eclipse隐藏了bin目录。进入我的电脑，打开Java项目目录，我们可以看到src和bin目录：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842523614536.png" alt=""></p>
]]></content>
		</item>
		
		<item>
			<title>1.7.2 在eclipse中创建Java项目</title>
			<link>https://HarryQing.github.io/posts/1.7.2-%E5%9C%A8eclipse%E4%B8%AD%E5%88%9B%E5%BB%BAjava%E9%A1%B9%E7%9B%AE/</link>
			<pubDate>Mon, 04 Jan 2021 22:14:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.7.2-%E5%9C%A8eclipse%E4%B8%AD%E5%88%9B%E5%BB%BAjava%E9%A1%B9%E7%9B%AE/</guid>
			<description>在界面左侧的“Package Explorer”视图中右键单击，在快捷菜单中依次选择new——&amp;gt; Java Project，开始新建Java项目。如图所示。 输入项目名称MyPro01，点击Finish 完成即可。如图所示。
新建项目完成，项目结构如图所示。其中的src文件夹用于存放源代码。显示JDK版本是JavaSE-1.8。</description>
			<content type="html"><![CDATA[<p>在界面左侧的“Package Explorer”视图中右键单击，在快捷菜单中依次选择new——&gt; Java  Project，开始新建Java项目。如图所示。
<img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842173615423.png" alt=""></p>
<p>输入项目名称MyPro01，点击Finish 完成即可。如图所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842184700790.png" alt=""></p>
<p>新建项目完成，项目结构如图所示。其中的src文件夹用于存放源代码。显示JDK版本是JavaSE-1.8。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494842206589668.png" alt=""></p>
]]></content>
		</item>
		
		<item>
			<title>1.7.1 下载和安装eclipse</title>
			<link>https://HarryQing.github.io/posts/1.7.1-%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85eclipse/</link>
			<pubDate>Mon, 04 Jan 2021 18:14:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.7.1-%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85eclipse/</guid>
			<description>下载地址：https://www.eclipse.org/downloads/packages/
出现图所示下载界面。选择Eclipse IDE for Java Developers，根据自己安装的JDK, 决定是下载32位还是64位。下载完成后，直接解压。进入目录，双击eclipse.exe即可使用。
启动时会先出现设置工作空间界面，如图所示。工作空间指Java项目存储的目录，一般采用默认工作空间目录即可。
点击OK后，会进入欢迎界面，如图所示。
关闭欢迎界面，即可进入开发主界面，如图所示。</description>
			<content type="html"><![CDATA[<p><strong>下载地址</strong>：<a href="https://www.eclipse.org/downloads/packages/"><strong>https://www.eclipse.org/downloads/packages/</strong></a></p>
<p>出现图所示下载界面。选择Eclipse IDE for Java Developers，根据自己安装的JDK, 决定是下载32位还是64位。下载完成后，直接解压。进入目录，双击eclipse.exe即可使用。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494841780284229.png" alt=""></p>
<p>启动时会先出现设置工作空间界面，如图所示。工作空间指Java项目存储的目录，一般采用默认工作空间目录即可。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494841793427012.png" alt=""></p>
<p>点击OK后，会进入欢迎界面，如图所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494841803281437.png" alt=""></p>
<p>关闭欢迎界面，即可进入开发主界面，如图所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494841810434059.png" alt=""></p>
]]></content>
		</item>
		
		<item>
			<title>1.7 eclipse使用10分钟入门</title>
			<link>https://HarryQing.github.io/posts/1.7-eclipse%E4%BD%BF%E7%94%A810%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/</link>
			<pubDate>Mon, 04 Jan 2021 13:14:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.7-eclipse%E4%BD%BF%E7%94%A810%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/</guid>
			<description>在开发工具匮乏的年代，第一代Java程序员都是从文本编辑器开始训练自己的代码，从而一步步成为高手，这是一种无奈，而不是一种必须。
我们认为，现在横在入门初学者最大的障碍在于“是否能激发兴趣，解决问题，体验到编程的快乐”，而不是讨论是该用记事本还是eclipse集成开发环境。
是否使用或坚持记事本编程不是成为高手的必要条件，而“激发兴趣，保持兴趣”确是成为高手的必要条件。也基于我们的理念“快速入门，快速实战”，我们一开始就引入eclipse，让初学者更容易的激发兴趣，体验学习的快乐。</description>
			<content type="html"><![CDATA[<p>在开发工具匮乏的年代，第一代Java程序员都是从文本编辑器开始训练自己的代码，从而一步步成为高手，这是一种无奈，而不是一种必须。</p>
<p>我们认为，现在横在入门初学者最大的障碍在于“是否能激发兴趣，解决问题，体验到编程的快乐”，而不是讨论是该用记事本还是eclipse集成开发环境。</p>
<p>是否使用或坚持记事本编程不是成为高手的必要条件，而“激发兴趣，保持兴趣”确是成为高手的必要条件。也基于我们的理念“快速入门，快速实战”，我们一开始就引入eclipse，让初学者更容易的激发兴趣，体验学习的快乐。</p>
]]></content>
		</item>
		
		<item>
			<title>1.6 常用Java开发工具</title>
			<link>https://HarryQing.github.io/posts/1.6-%E5%B8%B8%E7%94%A8java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</link>
			<pubDate>Mon, 04 Jan 2021 09:14:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.6-%E5%B8%B8%E7%94%A8java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</guid>
			<description>入门学习时，进行简单的Java程序编写，我们可以使用文本编辑器，比如：记事本。但是，记事本功能不够强大，我们可以考虑使用“更加强大的记事本”，常见的有如下三种软件：
1.Notepad++
2.UltraEdit
3.EditPlus
在我们真正学习开发中，包括以后在企业中从事软件开发时，一般使用集成开发环境（IDE）， 如下三种软件是最常见的，尤其是eclipse。 我们只选一个作为入门使用，其他两种大家自行举一反三，使用很简单。
eclipse官方网址：http://www.eclipse.org
IntelliJ IDE官方网址:http://www.jetbrains.com/idea/
NetBeans 官方网址：https://netbeans.org/</description>
			<content type="html"><![CDATA[<p>入门学习时，进行简单的Java程序编写，我们可以使用文本编辑器，比如：记事本。但是，记事本功能不够强大，我们可以考虑使用“更加强大的记事本”，常见的有如下三种软件：</p>
<p>1.Notepad++</p>
<p>2.UltraEdit</p>
<p>3.EditPlus</p>
<p>在我们真正学习开发中，包括以后在企业中从事软件开发时，一般使用集成开发环境（IDE）， 如下三种软件是最常见的，尤其是eclipse。 我们只选一个作为入门使用，其他两种大家自行举一反三，使用很简单。</p>
<p>eclipse官方网址：<a href="http://www.eclipse.org"><strong>http://www.eclipse.org</strong></a></p>
<p>IntelliJ IDE官方网址:<a href="http://www.jetbrains.com/idea/"><strong>http://www.jetbrains.com/idea/</strong></a></p>
<p>NetBeans 官方网址：<a href="https://netbeans.org/"><strong>https://netbeans.org/</strong></a></p>
]]></content>
		</item>
		
		<item>
			<title>1.5.4 最常用DOS命令</title>
			<link>https://HarryQing.github.io/posts/1.5.4-%E6%9C%80%E5%B8%B8%E7%94%A8dos%E5%91%BD%E4%BB%A4/</link>
			<pubDate>Mon, 04 Jan 2021 05:20:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.5.4-%E6%9C%80%E5%B8%B8%E7%94%A8dos%E5%91%BD%E4%BB%A4/</guid>
			<description>DOS命令已经基本退出普通使用者的历史舞台了，但是仍然有必要掌握几个常用的命令，便于在某些情况下更顺畅的操作程序。
1.cd 目录路径	进入一个目录
2.cd ..	进入父目录
3.dir	查看本目录下的文件和子目录列表
4.cls 清楚屏幕命令
5.上下键	查找敲过的命令
6.Tab键	自动补齐命令</description>
			<content type="html"><![CDATA[<p>DOS命令已经基本退出普通使用者的历史舞台了，但是仍然有必要掌握几个常用的命令，便于在某些情况下更顺畅的操作程序。</p>
<p>1.cd  目录路径	进入一个目录</p>
<p>2.cd ..	进入父目录</p>
<p>3.dir	查看本目录下的文件和子目录列表</p>
<p>4.cls  	清楚屏幕命令</p>
<p>5.上下键	查找敲过的命令</p>
<p>6.Tab键	自动补齐命令</p>
]]></content>
		</item>
		
		<item>
			<title>1.5.3 第一个Java程序的总结和提升</title>
			<link>https://HarryQing.github.io/posts/1.5.3-%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%8F%90%E5%8D%87/</link>
			<pubDate>Sun, 03 Jan 2021 21:00:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.5.3-%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%8F%90%E5%8D%87/</guid>
			<description>1.Java对大小写敏感，如果出现了大小写拼写错误，程序无法运行。
2.关键字public被称作访问修饰符(access modifier)，用于控制程序的其它部分对这段代码的访问级别。
3.关键字class 的意思是类。Java是面向对象的语言，所有代码必须位于类里面。
4.一个源文件中至多只能声明一个public的类，其它类的个数不限，如果源文件中包含一个public 类，源文件名必须和其中定义的public的类名相同，且以“.java”为扩展名。
5.一个源文件可以包含多个类class。
6.正确编译后的源文件，会得到相应的字节码文件，编译器为每个类生成独立的字节码文件，且将字节码文件自动命名为类的名字且以“.class”为扩展名。
7.main方法是Java应用程序的入口方法，它有固定的书写格式：
8.public static void main(String[] args) {…}
9.在Java中，用花括号划分程序的各个部分，任何方法的代码都必须以“{”开始，以“}”结束， 由于编译器忽略空格，所以花括号风格不受限制。
10.Java中每个语句必须以分号结束，回车不是语句的结束标志，所以一个语句可以跨多行。
老鸟建议： ·编程时，一定要注意缩进规范；
·在写括号、引号时，一定是成对编写，然后再往里插入内容。</description>
			<content type="html"><![CDATA[<p>1.Java对大小写敏感，如果出现了大小写拼写错误，程序无法运行。</p>
<p>2.关键字public被称作访问修饰符(access modifier)，用于控制程序的其它部分对这段代码的访问级别。</p>
<p>3.关键字class 的意思是类。Java是面向对象的语言，所有代码必须位于类里面。</p>
<p>4.一个源文件中至多只能声明一个public的类，其它类的个数不限，如果源文件中包含一个public 类，源文件名必须和其中定义的public的类名相同，且以“.java”为扩展名。</p>
<p>5.一个源文件可以包含多个类class。</p>
<p>6.正确编译后的源文件，会得到相应的字节码文件，编译器为每个类生成独立的字节码文件，且将字节码文件自动命名为类的名字且以“.class”为扩展名。</p>
<p>7.main方法是Java应用程序的入口方法，它有固定的书写格式：</p>
<p>8.public static void main(String[]  args) {…}</p>
<p>9.在Java中，用花括号划分程序的各个部分，任何方法的代码都必须以“{”开始，以“}”结束， 由于编译器忽略空格，所以花括号风格不受限制。</p>
<p>10.Java中每个语句必须以分号结束，回车不是语句的结束标志，所以一个语句可以跨多行。</p>
<h3 id="老鸟建议">老鸟建议：</h3>
<p>·编程时，一定要注意缩进规范；</p>
<p>·在写括号、引号时，一定是成对编写，然后再往里插入内容。</p>
]]></content>
		</item>
		
		<item>
			<title>1.5.2 第一个程序常见错误</title>
			<link>https://HarryQing.github.io/posts/1.5.2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</link>
			<pubDate>Sun, 03 Jan 2021 18:00:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.5.2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</guid>
			<description>·常见问题-1：提示“javac不是内部或外部命令……” 出错原因：Path变量配置错误导致没有找到javac命令
解决方案：参考1.4.2 &amp;lt;环境变量Path的配置&amp;gt;，细心重新设置Path，配置完成后需要重新输入cmd打开命令行窗口。
·常见问题-2：文件夹中可以看到Welcome.java文件，在编译时出现’javac 找不到文件……’ 出错原因：可能是操作系统显示设置的问题，隐藏了文件的扩展名。
解决方案：打开我的电脑窗口,选择【组织】【文件夹和搜索选项】【查看】，如图1-24所示，去掉“隐藏已知文件夹类型的扩展名”复选框中的对勾，看到文件的实际名称为Welcome.java.txt，将后缀后.txt去掉。
·常见问题-3：NoSuchMethodError：main 出错原因：找不到main方法，应该是main方法书写有误。
解决方案：检查public static void main(String [] args){}是否有误。</description>
			<content type="html"><![CDATA[<h2 id="常见问题-1提示javac不是内部或外部命令">·常见问题-1：提示“javac不是内部或外部命令……”</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494840217176085.png" alt=""></p>
<p><strong>出错原因</strong>：Path变量配置错误导致没有找到javac命令</p>
<p><strong>解决方案</strong>：参考1.4.2 &lt;环境变量Path的配置&gt;，细心重新设置Path，配置完成后需要重新输入cmd打开命令行窗口。</p>
<h2 id="常见问题-2文件夹中可以看到welcomejava文件在编译时出现javac-找不到文件">·常见问题-2：文件夹中可以看到Welcome.java文件，在编译时出现’javac 找不到文件……’</h2>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494840205551048.png" alt=""></p>
<p><strong>出错原因</strong>：可能是操作系统显示设置的问题，隐藏了文件的扩展名。</p>
<p><strong>解决方案</strong>：打开我的电脑窗口,选择【组织】【文件夹和搜索选项】【查看】，如图1-24所示，去掉“隐藏已知文件夹类型的扩展名”复选框中的对勾，看到文件的实际名称为Welcome.java.txt，将后缀后.txt去掉。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494840197751869.png" alt=""></p>
<h2 id="常见问题-3nosuchmethoderrormain">·常见问题-3：NoSuchMethodError：main</h2>
<p><strong>出错原因</strong>：找不到main方法，应该是main方法书写有误。</p>
<p><strong>解决方案</strong>：检查public static void main(String [] args){}是否有误。</p>
]]></content>
		</item>
		
		<item>
			<title>1.5.1 开发第一个Java程序</title>
			<link>https://HarryQing.github.io/posts/1.5.1-%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F/</link>
			<pubDate>Sun, 03 Jan 2021 13:14:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.5.1-%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F/</guid>
			<description>·使用记事本，编写代码 【示例1-1】使用记事本开发第一个Java程序
public class Welcome{public static void main(String[] args){System.out.println(&amp;quot;Hello Java!我是雪儿的哥哥，王雪庆!&amp;quot;); } } 可在d盘下建立文件夹mycode，用于保存学习的代码。保存路径建议为：”d:/mycode”。保存为：Welcome.java （文件名必须为Welcome，大小写也必须一致）。如图所示。
菜鸟雷区 1.代码中的引号、分号必须为英文引号和分号，不能是中文全角的引号和分号
2.注意大小写
·编译（编译器创建class字节码文件） 打开命令行窗口，进入Java文件所在目录；执行命令：javac Welcome.java，生成class文件。
·解释并运行阶段 执行：”java Welcome”（就是运行编译生成的Welcome.class文件），输出执行结果。
菜鸟雷区 修改完java源文件，一定要重新编译才能生效；</description>
			<content type="html"><![CDATA[<h2 id="使用记事本编写代码">·使用记事本，编写代码</h2>
<p>【示例1-1】使用记事本开发第一个Java程序</p>
<pre><code>public  class  Welcome{
    public static void main(String[] args){
        System.out.println(&quot;Hello Java!我是雪儿的哥哥，王雪庆!&quot;); 
    }       
}
</code></pre>
<p>可在d盘下建立文件夹mycode，用于保存学习的代码。保存路径建议为：”d:/mycode”。保存为：Welcome.java  （文件名必须为Welcome，大小写也必须一致）。如图所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494839751861170.png" alt=""></p>
<h3 id="菜鸟雷区">菜鸟雷区</h3>
<p>1.代码中的引号、分号必须为英文引号和分号，不能是中文全角的引号和分号</p>
<p>2.注意大小写</p>
<h2 id="编译编译器创建class字节码文件">·编译（编译器创建class字节码文件）</h2>
<p>打开命令行窗口，进入Java文件所在目录；执行命令：javac  Welcome.java，生成class文件。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494839822258615.png" alt=""></p>
<h2 id="解释并运行阶段">·解释并运行阶段</h2>
<p>执行：”java  Welcome”（就是运行编译生成的Welcome.class文件），输出执行结果。</p>
<h3 id="菜鸟雷区-1">菜鸟雷区</h3>
<p>修改完java源文件，一定要重新编译才能生效；</p>
]]></content>
		</item>
		
		<item>
			<title>1.4.3 测试JDK安装成功</title>
			<link>https://HarryQing.github.io/posts/1.4.3-%E6%B5%8B%E8%AF%95jdk%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F/</link>
			<pubDate>Sun, 03 Jan 2021 09:14:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.4.3-%E6%B5%8B%E8%AF%95jdk%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F/</guid>
			<description>进入命令行窗口，开始菜单搜索框输入“cmd”即可，如图所示。在窗口中输入命令“java -version ”，回车。出现如下结果，则说明JDK安装成功。
设置环境变量——验证JDK安装和配置是否成功 </description>
			<content type="html"><![CDATA[<p>进入命令行窗口，开始菜单搜索框输入“cmd”即可，如图所示。在窗口中输入命令“java  -version ”，回车。出现如下结果，则说明JDK安装成功。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494839221232267.png" alt=""></p>
<h3 id="设置环境变量验证jdk安装和配置是否成功">设置环境变量——验证JDK安装和配置是否成功</h3>
]]></content>
		</item>
		
		<item>
			<title>1.4.2 环境变量Path的配置</title>
			<link>https://HarryQing.github.io/posts/1.4.2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fpath%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
			<pubDate>Sun, 03 Jan 2021 05:20:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.4.2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fpath%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
			<description>环境变量是在操作系统中一个具有特定名字的对象， 它包含了一个或者多个应用程序所将使用到的信息。
Path是一个常见的环境变量，它告诉操作系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还应到哪些目录下寻找。
·设置Path环境变量的步骤如下 1.在电脑桌面 右键点击 “此电脑”的“属性”选项。
2.选择“高级系统设置”选项
3.点击下面的“环境变量”选项
4. 新建JAVA_HOME 变量 点击 New（新建）&amp;hellip; 按钮
输入:
 变量名：JAVA_HOME
变量值：电脑上JDK安装的绝对路径
 JDK 路径下必须能够看到如下的文件。
输入完毕后点击 OK。
5.新建/修改 CLASSPATH 变量 如果存在 CLASSPATH 变量，选中点击 Edit(编辑)。
如果没有，点击 New（新建）&amp;hellip; 新建。
输入/在已有的变量值后面添加：
 变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
 点击 OK 保存。
6.修改Path 变量 由于 win10 的不同，当选中 Path 变量的时候，系统会很方便的把所有不同路径都分开了，不会像 win7 或者 win8 那样连在一起。
新建两条路径：
 %JAVA_HOME%\bin
%JAVA_HOME%\jre\bin
 菜鸟雷区 1.此处一定是英文分号而不是中文分号！ 大家以后设置相关配置时也要注意中英文符号的区别。
注：classpath配置问题：如果使用JDK1.5以上就不需要配置这个环境变量！JRE会自动搜索当前路径下的类文件及相关jar文件
写在最后 第一次更改于2021年1月25日 由于雪儿的使用不便，霍霍霍！！！ </description>
			<content type="html"><![CDATA[<p>环境变量是在操作系统中一个具有特定名字的对象， 它包含了一个或者多个应用程序所将使用到的信息。</p>
<p>Path是一个常见的环境变量，它告诉操作系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还应到哪些目录下寻找。</p>
<h3 id="设置path环境变量的步骤如下">·设置Path环境变量的步骤如下</h3>
<p>1.在电脑桌面 右键点击 “此电脑”的“属性”选项。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534410870-6587-3932295-dd57a38934b0c1af.png" alt=""></p>
<p>2.选择“高级系统设置”选项</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534410904-3787-3932295-4ab4c5e4655e83ff.png" alt=""></p>
<p>3.点击下面的“环境变量”选项</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534410952-9821-3932295-53c3abde864d63a7.png" alt=""></p>
<h3 id="4-新建java_home-变量">4. 新建JAVA_HOME 变量</h3>
<p>点击 New（新建）&hellip; 按钮</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534411060-2131-3932295-ef08fb7d0ef0760f.png" alt=""></p>
<p>输入:</p>
<blockquote>
<p>变量名：JAVA_HOME</p>
<p>变量值：电脑上JDK安装的绝对路径</p>
</blockquote>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534411114-3840-3932295-73be617cffdac223.png" alt=""></p>
<p>JDK 路径下必须能够看到如下的文件。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534411157-4157-3932295-b821f0e17887bcdf.png" alt=""></p>
<p>输入完毕后点击 OK。</p>
<h3 id="5新建修改-classpath-变量">5.新建/修改 CLASSPATH 变量</h3>
<p>如果存在 CLASSPATH 变量，选中点击 Edit(编辑)。</p>
<p>如果没有，点击 New（新建）&hellip; 新建。</p>
<p>输入/在已有的变量值后面添加：</p>
<blockquote>
<p>变量名：CLASSPATH</p>
<p>变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</p>
</blockquote>
<p>点击 OK 保存。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534411198-2259-3932295-afe57d1caf93277c.png" alt=""></p>
<h3 id="6修改path-变量">6.修改Path 变量</h3>
<p>由于 win10 的不同，当选中 Path 变量的时候，系统会很方便的把所有不同路径都分开了，不会像 win7 或者 win8 那样连在一起。</p>
<p>新建两条路径：</p>
<blockquote>
<p>%JAVA_HOME%\bin</p>
<p>%JAVA_HOME%\jre\bin</p>
</blockquote>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534411240-7448-3932295-515fd020c1e2fc4a.png" alt=""></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1534411281-6565-3932295-08d84d125c71d0a8.png" alt=""></p>
<h3 id="菜鸟雷区">菜鸟雷区</h3>
<p>1.此处一定是英文分号而不是中文分号！ 大家以后设置相关配置时也要注意中英文符号的区别。</p>
<p><strong>注</strong>：classpath配置问题：如果使用JDK1.5以上就不需要配置这个环境变量！JRE会自动搜索当前路径下的类文件及相关jar文件</p>
<h2 id="写在最后">写在最后</h2>
<h3 id="第一次更改于2021年1月25日-由于雪儿的使用不便霍霍霍">第一次更改于2021年1月25日 由于雪儿的使用不便，霍霍霍！！！</h3>
]]></content>
		</item>
		
		<item>
			<title>1.4.1 JDK下载和安装 </title>
			<link>https://HarryQing.github.io/posts/1.4.1-jdk%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85-/</link>
			<pubDate>Sat, 02 Jan 2021 22:00:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.4.1-jdk%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85-/</guid>
			<description>·下载JDK 1.下载地址，点击进入：https://www.oracle.com/java/technologies/javase-downloads.html
2.点击下载JDK，会出现图所示的下载列表界面。首先，点击”Accept License Agreement”，然后选择对应的版本，下载即可。
注: 如果您无法确定您的windows版本，可以右键点击“计算机属性”，即可查看系统信息：
菜鸟雷区： 1.32位操作系统只能安装32位JDK； 2.64位操作系统可安装32位JDK，也可以安装64位JDK。
·安装JDK 安装过程和普通软件安装没什么区别，过程中会让你选择JDK和JRE安装目录，采用默认即可。也就是说，通通点击“下一步”就能完成安装。
出现如上画面代表，JDK安装成功。
我们再进入JDK的安装目录C:\Program Files\Java\jdk1.8.0_131，可以看到如下的结构：
其中：
~bin目录是存储一些可执行的二进制文件；
~lib存储相关jar包；
~src.zip是JDK相关JAVA类的源代码。</description>
			<content type="html"><![CDATA[<h2 id="下载jdk">·下载JDK</h2>
<p>1.下载地址，点击进入：<a href="https://www.oracle.com/java/technologies/javase-downloads.html"><strong>https://www.oracle.com/java/technologies/javase-downloads.html</strong></a></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838187142946.png" alt=""></p>
<p>2.点击下载JDK，会出现图所示的下载列表界面。首先，点击”Accept License Agreement”，然后选择对应的版本，下载即可。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838226231899.png" alt=""></p>
<p><strong>注:</strong> 如果您无法确定您的windows版本，可以右键点击“计算机属性”，即可查看系统信息：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838246860282.png" alt=""></p>
<h3 id="菜鸟雷区">菜鸟雷区：</h3>
<p>1.32位操作系统只能安装32位JDK； 
2.64位操作系统可安装32位JDK，也可以安装64位JDK。</p>
<h2 id="安装jdk">·安装JDK</h2>
<p>安装过程和普通软件安装没什么区别，过程中会让你选择JDK和JRE安装目录，采用默认即可。也就是说，通通点击“下一步”就能完成安装。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838268176148.png" alt=""></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838288350322.png" alt=""></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838308687920.png" alt=""></p>
<p>出现如上画面代表，JDK安装成功。</p>
<p>我们再进入JDK的安装目录C:\Program Files\Java\jdk1.8.0_131，可以看到如下的结构：</p>
<p>其中：</p>
<p>~bin目录是存储一些可执行的二进制文件；</p>
<p>~lib存储相关jar包；</p>
<p>~src.zip是JDK相关JAVA类的源代码。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170606/1496738387902099.png" alt=""></p>
]]></content>
		</item>
		
		<item>
			<title>1.3.6 JVM、JRE和JDK</title>
			<link>https://HarryQing.github.io/posts/1.3.6-jvmjre%E5%92%8Cjdk/</link>
			<pubDate>Sat, 02 Jan 2021 18:00:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.3.6-jvmjre%E5%92%8Cjdk/</guid>
			<description>JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。
不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。 Java虚拟机是实现跨平台的核心机制。如图1-6所示。
Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。
Java Development Kit (JDK)包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件。
JDK、JRE和JVM的关系如图所示。
老鸟建议： ·如果只是要运行Java程序，只需要JRE就可以。JRE通常非常小，其中包含了JVM。
·如果要开发Java程序，就需要安装JDK。</description>
			<content type="html"><![CDATA[<p>JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。</p>
<p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。 Java虚拟机是实现跨平台的核心机制。如图1-6所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" alt=""></p>
<p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。</p>
<p>Java  Development Kit (JDK)包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件。</p>
<p>JDK、JRE和JVM的关系如图所示。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" alt=""></p>
<h3 id="老鸟建议">老鸟建议：</h3>
<p>·如果只是要运行Java程序，只需要JRE就可以。JRE通常非常小，其中包含了JVM。</p>
<p>·如果要开发Java程序，就需要安装JDK。</p>
]]></content>
		</item>
		
		<item>
			<title>1.3.5 Java应用程序的运行机制</title>
			<link>https://HarryQing.github.io/posts/1.3.5-java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 02 Jan 2021 13:14:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.3.5-java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid>
			<description>计算机高级语言的类型主要有编译型和解释型两种，而Java 语言是两种类型的结合。
Java首先利用文本编辑器编写 Java源程序，源文件的后缀名为.java；再利用编译器（javac）将源程序编译成字节码文件，字节码文件的后缀名为.class； 最后利用虚拟机（解释器，java）解释执行。</description>
			<content type="html"><![CDATA[<p>计算机高级语言的类型主要有编译型和解释型两种，而Java 语言是两种类型的结合。</p>
<p>Java首先利用文本编辑器编写 Java源程序，源文件的后缀名为.java；再利用编译器（javac）将源程序编译成字节码文件，字节码文件的后缀名为.class； 最后利用虚拟机（解释器，java）解释执行。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" alt=""></p>
]]></content>
		</item>
		
		<item>
			<title>1.3.4 Java的特性和优势</title>
			<link>https://HarryQing.github.io/posts/1.3.4-java%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BC%98%E5%8A%BF/</link>
			<pubDate>Sat, 02 Jan 2021 09:14:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.3.4-java%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BC%98%E5%8A%BF/</guid>
			<description>·跨平台/可移植性 这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。
·安全性 Java适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。
·面向对象 面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！Java则是完全的面向对象语言。
·简单性 Java就是C++语法的简化版，我们也可以将Java称之为“C++-”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，由于语法基于C语言，因此学习起来完全不费力。
·高性能 Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，某些代码甚至接待C++的效率。
因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。
·分布式 Java是为Internet的分布式环境设计的，因为它能够处理TCP/IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，使程序能够通过网络调用方法。
·多线程 多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。
·健壮性 Java是一种健壮的语言，吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。</description>
			<content type="html"><![CDATA[<h2 id="跨平台可移植性">·跨平台/可移植性</h2>
<p>这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。</p>
<h2 id="安全性">·安全性</h2>
<p>Java适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。</p>
<h2 id="面向对象">·面向对象</h2>
<p>面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！Java则是完全的面向对象语言。</p>
<h2 id="简单性">·简单性</h2>
<p>Java就是C++语法的简化版，我们也可以将Java称之为“C++-”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，由于语法基于C语言，因此学习起来完全不费力。</p>
<h2 id="高性能">·高性能</h2>
<p>Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，某些代码甚至接待C++的效率。</p>
<p>因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。</p>
<h2 id="分布式">·分布式</h2>
<p>Java是为Internet的分布式环境设计的，因为它能够处理TCP/IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，使程序能够通过网络调用方法。</p>
<h2 id="多线程">·多线程</h2>
<p>多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。</p>
<h2 id="健壮性">·健壮性</h2>
<p>Java是一种健壮的语言，吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。</p>
]]></content>
		</item>
		
		<item>
			<title>1.3.3 Java各版本的含义</title>
			<link>https://HarryQing.github.io/posts/1.3.3-java%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E5%90%AB%E4%B9%89/</link>
			<pubDate>Sat, 02 Jan 2021 05:20:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.3.3-java%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E5%90%AB%E4%B9%89/</guid>
			<description>JavaSE(Java Standard Edition)：标准版，定位在个人计算机上的应用。这个版本是Java平台的核心，它提供了非常丰富的API来开发一般个人计算机上的应用程序，包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。在上世纪90年代末互联网上大放异彩的Applet也属于这个版本。Applet后来为Flash取代，Flash即将被HTML5取代。
JavaEE(Java Enterprise Edition)：企业版，定位在服务器端的应用。
JavaEE是JavaSE的扩展，增加了用于服务器开发的类库。如：JDBC是让程序员能直接在Java内使用的SQL的语法来访问数据库内的数据;Servlet能够延伸服务器的功能，通过请求-响应的模式来处理客户端的请求;JSP是一种可以将Java程序代码内嵌在网页内的技术;
JavaME(Java Micro Edition)：微型版，定位在消费性电子产品的应用上
JavaME是JavaSE的内伸，包含J2SE的一部分核心类，也有自己的扩展类,增加了适合微小装置的类库：javax.microedition.io.* 等。该版本针对资源有限的电子消费产品的需求精简核心类库，并提供了模块化的架构让不同类型产品能够随时增加支持的能力。
雷区： 很多人开始会误解为安卓开发就是JavaME，这两个是完全不同的内容。</description>
			<content type="html"><![CDATA[<p>JavaSE(Java Standard Edition)：标准版，定位在个人计算机上的应用。这个版本是Java平台的核心，它提供了非常丰富的API来开发一般个人计算机上的应用程序，包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。在上世纪90年代末互联网上大放异彩的Applet也属于这个版本。Applet后来为Flash取代，Flash即将被HTML5取代。</p>
<p>JavaEE(Java Enterprise Edition)：企业版，定位在服务器端的应用。</p>
<p>JavaEE是JavaSE的扩展，增加了用于服务器开发的类库。如：JDBC是让程序员能直接在Java内使用的SQL的语法来访问数据库内的数据;Servlet能够延伸服务器的功能，通过请求-响应的模式来处理客户端的请求;JSP是一种可以将Java程序代码内嵌在网页内的技术;</p>
<p>JavaME(Java Micro Edition)：微型版，定位在消费性电子产品的应用上</p>
<p>JavaME是JavaSE的内伸，包含J2SE的一部分核心类，也有自己的扩展类,增加了适合微小装置的类库：javax.microedition.io.* 等。该版本针对资源有限的电子消费产品的需求精简核心类库，并提供了模块化的架构让不同类型产品能够随时增加支持的能力。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170606/1496714683708833.jpg" alt=""></p>
<h3 id="雷区">雷区：</h3>
<p>很多人开始会误解为安卓开发就是JavaME，这两个是完全不同的内容。</p>
]]></content>
		</item>
		
		<item>
			<title>1.3.2 Java的核心优势</title>
			<link>https://HarryQing.github.io/posts/1.3.2-java%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF/</link>
			<pubDate>Fri, 01 Jan 2021 21:00:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.3.2-java%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF/</guid>
			<description>Java为消费类智能电子产品而设计，但智能家电产品并没有像最初想象的那样拥有大的发展。然而90年代，Internet却进入了爆发式发展阶段，一夜之间，大家都在忙着将自己的计算机连接到网络上。这个时侯，遇到了一个大的问题。人们发现连接到Internet的计算机各式各样，有IBM PC、苹果机、各种服务器等等，不仅硬件CPU不同，操作系统也不同，整个的网络环境非常复杂。这个时候，程序员们希望他们编写的程序能够运行在不同的机器，不同的环境中，这需要一种体系中立的语言(即跨平台)。Java的研发小组忽然发现他们用于小范围的语言也可以适应Internet这个大环境。
跨平台是Java语言的核心优势，赶上最初互联网的发展，并随着互联网的发展而发展，建立了强大的生态体系，目前已经覆盖IT各行业的“第一大语言”，是计算机界的“英语”。
虽然，目前也有很多跨平台的语言，但是已经失去先机，无法和Java强大的生态体系抗衡。Java仍将在未来几十年成为编程语言的主流语言。
JAVA虚拟机是JAVA实现跨平台的核心。事实上，基于JAVA虚拟机(JVM)的编程语言还有很多种：
基于JAVA生态建立的产品将会越来越多；基于JAVA虚拟机的编程语言也将会越来越多；生态系统的强大，是JAVA能长盛不衰的根本。 </description>
			<content type="html"><![CDATA[<p>Java为消费类智能电子产品而设计，但智能家电产品并没有像最初想象的那样拥有大的发展。然而90年代，Internet却进入了爆发式发展阶段，一夜之间，大家都在忙着将自己的计算机连接到网络上。这个时侯，遇到了一个大的问题。人们发现连接到Internet的计算机各式各样，有IBM PC、苹果机、各种服务器等等，不仅硬件CPU不同，操作系统也不同，整个的网络环境非常复杂。这个时候，程序员们希望他们编写的程序能够运行在不同的机器，不同的环境中，这需要一种体系中立的语言(即跨平台)。Java的研发小组忽然发现他们用于小范围的语言也可以适应Internet这个大环境。</p>
<p>跨平台是Java语言的核心优势，赶上最初互联网的发展，并随着互联网的发展而发展，建立了强大的生态体系，目前已经覆盖IT各行业的“第一大语言”，是计算机界的“英语”。</p>
<p>虽然，目前也有很多跨平台的语言，但是已经失去先机，无法和Java强大的生态体系抗衡。Java仍将在未来几十年成为编程语言的主流语言。</p>
<p>JAVA虚拟机是JAVA实现跨平台的核心。事实上，基于JAVA虚拟机(JVM)的编程语言还有很多种：</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170606/1496713931611178.jpg" alt=""></p>
<h3 id="基于java生态建立的产品将会越来越多基于java虚拟机的编程语言也将会越来越多生态系统的强大是java能长盛不衰的根本">基于JAVA生态建立的产品将会越来越多；基于JAVA虚拟机的编程语言也将会越来越多；生态系统的强大，是JAVA能长盛不衰的根本。</h3>
]]></content>
		</item>
		
		<item>
			<title>1.3.1 Java发展简史</title>
			<link>https://HarryQing.github.io/posts/1.3.1-java%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/</link>
			<pubDate>Fri, 01 Jan 2021 18:00:00 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.3.1-java%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/</guid>
			<description>1991年，James Gosling在SUN公司的工程师小组想要设计这样一种小型计算机语言。该语言主要用于像电视盒这样的消费类电子产品。另外，由于不同的厂商选择不同的CPU和操作系统，因此，要求该语言不能和特定的体系结构绑在一起，要求语言本身是中立的，也就是跨平台的。所以，将这个语言命名为“Green”，类似于绿色软件的意思。后来，改名为Oak，橡树的意思。改名后发现已经有一种语言叫这个名字了，再改名叫Java。Java语言发展到今天经历了一系列的过程：
1991年，SUN公司的Green项目，Oak
1995年，推出Java测试版
1996年，JDK1.0
1997年，JDK1.1
1998年，JDK1.2，大大改进了早期版本缺陷，是一个革命性的版本，更名为Java2。
2004年，J2SE 5.0 (1.5.0) Tiger老虎
2006年，J2SE 6.0 (1.6.0) Mustang野马
2011年，JavaSE7.0 Dolphin海豚
2014年，JavaSE8.0</description>
			<content type="html"><![CDATA[<p>1991年，James Gosling在SUN公司的工程师小组想要设计这样一种小型计算机语言。该语言主要用于像电视盒这样的消费类电子产品。另外，由于不同的厂商选择不同的CPU和操作系统，因此，要求该语言不能和特定的体系结构绑在一起，要求语言本身是中立的，也就是跨平台的。所以，将这个语言命名为“Green”，类似于绿色软件的意思。后来，改名为Oak，橡树的意思。改名后发现已经有一种语言叫这个名字了，再改名叫Java。Java语言发展到今天经历了一系列的过程：</p>
<p>1991年，SUN公司的Green项目，Oak</p>
<p>1995年，推出Java测试版</p>
<p>1996年，JDK1.0</p>
<p>1997年，JDK1.1</p>
<p>1998年，JDK1.2，大大改进了早期版本缺陷，是一个革命性的版本，更名为Java2。</p>
<p>2004年，J2SE 5.0 (1.5.0) Tiger老虎</p>
<p>2006年，J2SE 6.0 (1.6.0) Mustang野马</p>
<p>2011年，JavaSE7.0 Dolphin海豚</p>
<p>2014年，JavaSE8.0</p>
]]></content>
		</item>
		
		<item>
			<title>1.2 常见编程语言介绍</title>
			<link>https://HarryQing.github.io/posts/1.2-%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/</link>
			<pubDate>Fri, 01 Jan 2021 13:14:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.2-%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/</guid>
			<description>C语言 C语言诞生于1972年，可以称之为现代高级语言的鼻祖，由著名的贝尔实验室发明。C语言是人们追求结构化、模块化、高效率的“语言之花”。在底层编程，比如嵌入式、病毒开发等应用，可以替代汇编语言来开发系统程序。在高层应用，也可以开发从操作系统(Unix/Linux/Windows都基于C语言开发)到各种应用软件。
老鸟建议： 大学生朋友如果大学开这门课请一定认真学习，而不要觉得老套，那是经典；C语言在现代社会流行程度仍然排名前三。
C++语言 作为C语言的扩展，C++是贝尔实验室于80年代推出的。C++是一种混合语言，既可以实现面向对象编程，也可以开发C语言面向过程风格的程序。
C语言让程序员第一次可以通过结构化的理念编写出易于理解的复杂程序； 尽管C语言是一个伟大的语言，但是程序的代码量达到30000行以上时，程序员就不能很好的从总体上把握和控制这个程序。 因此，在80年代初期，很多软件项目都面临无法解决的问题而不能顺利进行。 1979年，贝尔实验室发明了C++。 C++最初的名字叫做“带类的C”，后来才改名叫C++。国内通用叫法：“C加加”,国际通用读法“C plus plus”。
C++语言在科学计算、操作系统、网络通讯、系统开发、引擎开发中仍然被大量使用。
Java语言 由美国SUN公司发明于1995年，是目前业界应用最广泛、使用人数最多的语言，连续多年排名世界第一，可以称之为“计算机语言界的英语”。
Java广泛应用于企业级软件开发、安卓移动开发、大数据云计算等领域，几乎涉及IT所有行业。关于Java的发展历史和特性，将在后面专门介绍。
PHP语言 PHP原始为Personal Home Page的缩写，已经正式更名为 &amp;ldquo;PHP: Hypertext Preprocessor&amp;rdquo;。PHP语言，一般用于WEB开发领域；大量的中小型网站以及某些大型网站使用PHP开发。
Object-C和Swift语言 Object-C通常写作Objective-C或者Obj-C或OC，是根据C语言所衍生出来的语言，继承了C语言的特性，是扩充C的面向对象编程语言。OC主要用于苹果软件的开发。
Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与OC共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。
JavaScript语言 JavaScript是一种脚本语言,已经被广泛用于Web应用开发；应用范围越来越大，重要性越来越高。目前，流行的H5开发的核心其实就是JavaScript语言。
Python语言 Python发明于1989年，语法结构简单，易学易懂；Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。Python广泛应用于：图形处理、科学计算、web编程、多媒体应用、引擎开发；尤其是在未来大热方向机器学习和人工智能上有非常大的潜力。
C#语言 C#是微软公司发布的一种面向对象的、运行于.NET Framework之上的高级程序设计语言。C#在基于windows操作系统的应用开发这一领域在取代C++，占据主导地位。“成也萧何败也萧何”，C#的微软身份，也成为了发展的阻力，在其他IT领域应用较少。
Fortran语言 世界上第一种高级语言， IBM公司在1954年提出的，主要用在需要复杂数学计算的科学和工程领域。现在仍然被广泛使用，尤其是工程领域。Fortran虽然适合编写科学计算方面的程序，但是不适于编写系统程序。
Basic语言 虽然易学，但功能不够强大，应用到大程序的有效性令人怀疑。已经逐步退出历史舞台。
COBOL语言 于1959年提出。主要用于大量精确处理数据的商业领域中，比如金融、银行。今天，仍然有超过一半的商业软件使用COBOL编写。有将近100万人使用COBOL编程。
Pascal语言 Pascal的名称是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal而来的，它由瑞士Niklaus Wirth教授于六十年代末设计并创立的。Pascal语言语法严谨，层次分明，程序易写，可读性强，是第一个结构化编程语言。由于没有大厂商和政府的支持，只是限于大学教育这一块。</description>
			<content type="html"><![CDATA[<h2 id="c语言">C语言</h2>
<p>C语言诞生于1972年，可以称之为现代高级语言的鼻祖，由著名的贝尔实验室发明。C语言是人们追求结构化、模块化、高效率的“语言之花”。在底层编程，比如嵌入式、病毒开发等应用，可以替代汇编语言来开发系统程序。在高层应用，也可以开发从操作系统(Unix/Linux/Windows都基于C语言开发)到各种应用软件。</p>
<h3 id="老鸟建议">老鸟建议：</h3>
<p>大学生朋友如果大学开这门课请一定认真学习，而不要觉得老套，那是经典；C语言在现代社会流行程度仍然排名前三。</p>
<h2 id="c语言-1">C++语言</h2>
<p>作为C语言的扩展，C++是贝尔实验室于80年代推出的。C++是一种混合语言，既可以实现面向对象编程，也可以开发C语言面向过程风格的程序。</p>
<p>C语言让程序员第一次可以通过结构化的理念编写出易于理解的复杂程序； 尽管C语言是一个伟大的语言，但是程序的代码量达到30000行以上时，程序员就不能很好的从总体上把握和控制这个程序。 因此，在80年代初期，很多软件项目都面临无法解决的问题而不能顺利进行。 1979年，贝尔实验室发明了C++。 C++最初的名字叫做“带类的C”，后来才改名叫C++。国内通用叫法：“C加加”,国际通用读法“C plus plus”。</p>
<p>C++语言在科学计算、操作系统、网络通讯、系统开发、引擎开发中仍然被大量使用。</p>
<h2 id="java语言">Java语言</h2>
<p>由美国SUN公司发明于1995年，是目前业界应用最广泛、使用人数最多的语言，连续多年排名世界第一，可以称之为“计算机语言界的英语”。</p>
<p>Java广泛应用于企业级软件开发、安卓移动开发、大数据云计算等领域，几乎涉及IT所有行业。关于Java的发展历史和特性，将在后面专门介绍。</p>
<h2 id="php语言">PHP语言</h2>
<p>PHP原始为Personal Home Page的缩写，已经正式更名为 &ldquo;PHP: Hypertext Preprocessor&rdquo;。PHP语言，一般用于WEB开发领域；大量的中小型网站以及某些大型网站使用PHP开发。</p>
<h2 id="object-c和swift语言">Object-C和Swift语言</h2>
<p>Object-C通常写作Objective-C或者Obj-C或OC，是根据C语言所衍生出来的语言，继承了C语言的特性，是扩充C的面向对象编程语言。OC主要用于苹果软件的开发。</p>
<p>Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与OC共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。</p>
<h2 id="javascript语言">JavaScript语言</h2>
<p>JavaScript是一种脚本语言,已经被广泛用于Web应用开发；应用范围越来越大，重要性越来越高。目前，流行的H5开发的核心其实就是JavaScript语言。</p>
<h2 id="python语言">Python语言</h2>
<p>Python发明于1989年，语法结构简单，易学易懂；Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。Python广泛应用于：图形处理、科学计算、web编程、多媒体应用、引擎开发；尤其是在未来大热方向机器学习和人工智能上有非常大的潜力。</p>
<h2 id="c语言-2">C#语言</h2>
<p>C#是微软公司发布的一种面向对象的、运行于.NET Framework之上的高级程序设计语言。C#在基于windows操作系统的应用开发这一领域在取代C++，占据主导地位。“成也萧何败也萧何”，C#的微软身份，也成为了发展的阻力，在其他IT领域应用较少。</p>
<h2 id="fortran语言">Fortran语言</h2>
<p>世界上第一种高级语言， IBM公司在1954年提出的，主要用在需要复杂数学计算的科学和工程领域。现在仍然被广泛使用，尤其是工程领域。Fortran虽然适合编写科学计算方面的程序，但是不适于编写系统程序。</p>
<h2 id="basic语言">Basic语言</h2>
<p>虽然易学，但功能不够强大，应用到大程序的有效性令人怀疑。已经逐步退出历史舞台。</p>
<h2 id="cobol语言">COBOL语言</h2>
<p>于1959年提出。主要用于大量精确处理数据的商业领域中，比如金融、银行。今天，仍然有超过一半的商业软件使用COBOL编写。有将近100万人使用COBOL编程。</p>
<h2 id="pascal语言">Pascal语言</h2>
<p>Pascal的名称是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal而来的，它由瑞士Niklaus Wirth教授于六十年代末设计并创立的。Pascal语言语法严谨，层次分明，程序易写，可读性强，是第一个结构化编程语言。由于没有大厂商和政府的支持，只是限于大学教育这一块。</p>
]]></content>
		</item>
		
		<item>
			<title>1.1 计算机语言发展史以及未来方向</title>
			<link>https://HarryQing.github.io/posts/1.1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8F%B2%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/</link>
			<pubDate>Fri, 01 Jan 2021 09:14:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/1.1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8F%B2%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91/</guid>
			<description>·计算机已经成为人大脑的延伸 计算机已经成为我们这个时代的核心设备，每时每刻都需要它。计算机也不再是大家以前印象中的台式机、服务器，已经演变成了我们身边随处可见的物体。比如：手机、平板电脑、笔记本，以及很多人没意识到，但实际上设备内部包含“计算机”的设备。比如：电视机、微波炉、汽车，甚至小孩玩的智能小机器人等。
可以这么说，计算机已经成为了人类身体的延伸、大脑的延伸，成为不可或缺的一部分。未来，计算机将真的进入人体、进入大脑，真正成为人体的一部分。比如，在科幻电影《黑客帝国》中，主角被超级针头插在颈部后方，便能使他快速学习，改变大脑神经网络，几秒就成为功夫高手。
·算法是计算机的灵魂，编程语言是塑造计算机灵魂的工具 计算机是如何工作的？对于普通人来说，这很神秘。让计算机具备“灵魂”，可以按照人的意志运行，甚至某天按照计算机自己的意志运行（如果这一天实现，科幻电影《终结者》中的场景也会成为人类社会的可能选项），其核心就是“算法”。 “算法就是计算机的灵魂”算法的实现又依赖于“计算机编程语言”。
计算机编程语言的发展，是随着计算机本身硬件发展而发展的。硬件速度越快、体积越小、成本越低，应用到人类社会的场景就会越多，那么所需要的算法就会越复杂，也就要求计算机编程语言越高级。
最初重达几十吨但一秒只能运算5000次的ENIAC(世界上第一台计算机)，只能做非常小的应用，比如：某些情况的弹道计算。现在任何一个人的手机运算能力都可以秒杀那个年代地球上所有计算机运算能力的总和。
计算机编程语言的发展历经了从低级到高级发展。发展的核心思想就是“让人更容易编程”。越容易使用的语言，就有越多人使用；越多人使用，就有越多协作；越多协作，就可以创造越复杂的物体；现代社会，一个软件动辄几十人协作、几百人协作、甚至几千人协作也成为可能，这自然就为开发复杂软件提供了“人力基础”。这是一个人类普遍的社会现象，越容易使用的工具，通过使用数量，通过大量人的协作，彻底改变某个行业甚至人类社会。
计算机语言经历了三代：第一代是机器语言，第二代是汇编语言，第三代是高级语言。 ·第一代语言：机器语言(相当于人类的原始阶段) 机器语言由数字组成所有指令。当让你使用数字编程，写几百个数字、甚至几千个数字，每天面对的是纯数字，我大胆预测：“程序员群体100%会有精神问题”。
机器语言通常由数字串组成（最终被简化成01），对于人类来说，机器语言过于繁琐。使用机器语言，人类无法编出复杂的程序。如下为一段典型的机器码：
 1. 0000,0000,000000010000 代表 LOAD A, 162. 0000,0001,000000000001 代表 LOAD B, 13. 0001,0001,000000010000 代表 STORE B, 16 ·第二代语言：汇编语言（相当于人类的手工业阶段） 为了编程的方便，以及解决更加复杂的问题。程序员开始改进机器语言，使用英文缩写的助记符来表示基本的计算机操作。这些助记符构成了汇编语言的基础。如下是一些常见的汇编语言助记符(单词)比如：LOAD、MOVE之类，这样人更容易使用了。识别几百、几千个单词，感觉要比几百几千个数字，美妙多了。汇编语言相当于人类的手工业社会，需要技术极其娴熟的工匠，但是开发效率也非常低。
汇编语言虽然能编写高效率的程序，但是学习和使用都不是易事，并且很难调试。另一个复杂的问题，汇编语言以及早期的计算机语言（Basic、Fortran等）没有考虑结构化设计原则，而是使用goto语句来作为程序流程控制的主要方法。这样做的后果是：一大堆混乱的调转语句使得程序几乎不可能被读懂。对于那个时代的程序员，能读懂上个月自己写的代码都成为一种挑战。
汇编语言仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。
·第三代：高级语言（相当于人类的工业阶段） 对于简单的任务，汇编语言可以胜任。但是随着计算机的发展，渗透到了工作生活的更多的方面，一些复杂的任务出现了，汇编语言就显得力不从心（应该说是程序员使用汇编语言解决复杂问题出现了瓶颈）。于是，出现了高级语言。像我们熟知的C、C++、Java等等都是高级语言。
高级语言允许程序员使用接近日常英语的指令来编写程序。例如，实现一个简单的任务：A+B=C , 使用机器语言、汇编语言和高级语言的的实现如下图。
从上面这个简单的加法计算，可以看出越到高级语言，越接近人的思维，人使用起来就越方便。
高级语言的出现，尤其是面向对象语言的出现，相当于人类的工业社会，高级语言极其易用，编程门槛和难度大大降低，大量的人员进入软件开发行业，为软件爆发性的增长提供了充足的人力资源。目前以及可预见的将来，计算机语言仍然处于“第三代高级语言”阶段。
·为什么担心软件开发人才饱和是多余的？ 很多未进入或刚进入软件行业的朋友，特别担心一个问题“这么多人学，会不会饱和？”。这其实是杞人忧天，越多人编程，才能为软件行业提供巨量的人力资源，才能实现我们以前都不敢想的应用开发。要以发展的眼光看问题，而不是静态的眼光。
越多人编程，越多应用需要做，越多应用需要做，更需要越多人编程。这就像一个农夫刚刚进入工业社会，担心服装工厂工人招满了怎么办? 他没有想到工业发展后，钢铁厂也需要工人、汽车厂也需要工人。年轻朋友请记住“软件行业发展永无止境，将会整合人类现有所有行业，也会创造很多新的行业”。
·未来30年必将是软件人才的世界 未来30年的世界必将是软件人才的世界；除了普通软件的应用，大批的人工智能应用也将出现；未来自动驾驶、自动翻译、机器人保姆甚至机器人女友都会进入我们的生活，甚至计算机编程和基因工程结合，长生不老都能实现；有兴趣的童鞋，推荐大家看《未来简史》这本书，把握一下未来的脉搏。
请发挥我们年轻人的想象力，尽情的在IT的世界中挥洒吧！ </description>
			<content type="html"><![CDATA[<h2 id="计算机已经成为人大脑的延伸">·计算机已经成为人大脑的延伸</h2>
<p>计算机已经成为我们这个时代的核心设备，每时每刻都需要它。计算机也不再是大家以前印象中的台式机、服务器，已经演变成了我们身边随处可见的物体。比如：手机、平板电脑、笔记本，以及很多人没意识到，但实际上设备内部包含“计算机”的设备。比如：电视机、微波炉、汽车，甚至小孩玩的智能小机器人等。</p>
<p>可以这么说，计算机已经成为了人类身体的延伸、大脑的延伸，成为不可或缺的一部分。未来，计算机将真的进入人体、进入大脑，真正成为人体的一部分。比如，在科幻电影《黑客帝国》中，主角被超级针头插在颈部后方，便能使他快速学习，改变大脑神经网络，几秒就成为功夫高手。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494834467868650.png" alt=""></p>
<h2 id="算法是计算机的灵魂编程语言是塑造计算机灵魂的工具">·算法是计算机的灵魂，编程语言是塑造计算机灵魂的工具</h2>
<p>计算机是如何工作的？对于普通人来说，这很神秘。让计算机具备“灵魂”，可以按照人的意志运行，甚至某天按照计算机自己的意志运行（如果这一天实现，科幻电影《终结者》中的场景也会成为人类社会的可能选项），其核心就是“算法”。 “算法就是计算机的灵魂”算法的实现又依赖于“计算机编程语言”。</p>
<p>计算机编程语言的发展，是随着计算机本身硬件发展而发展的。硬件速度越快、体积越小、成本越低，应用到人类社会的场景就会越多，那么所需要的算法就会越复杂，也就要求计算机编程语言越高级。</p>
<p>最初重达几十吨但一秒只能运算5000次的ENIAC(世界上第一台计算机)，只能做非常小的应用，比如：某些情况的弹道计算。现在任何一个人的手机运算能力都可以秒杀那个年代地球上所有计算机运算能力的总和。</p>
<p>计算机编程语言的发展历经了从低级到高级发展。发展的核心思想就是“让人更容易编程”。越容易使用的语言，就有越多人使用；越多人使用，就有越多协作；越多协作，就可以创造越复杂的物体；现代社会，一个软件动辄几十人协作、几百人协作、甚至几千人协作也成为可能，这自然就为开发复杂软件提供了“人力基础”。这是一个人类普遍的社会现象，越容易使用的工具，通过使用数量，通过大量人的协作，彻底改变某个行业甚至人类社会。</p>
<h3 id="计算机语言经历了三代第一代是机器语言第二代是汇编语言第三代是高级语言">计算机语言经历了三代：第一代是机器语言，第二代是汇编语言，第三代是高级语言。</h3>
<h3 id="第一代语言机器语言相当于人类的原始阶段">·第一代语言：机器语言(相当于人类的原始阶段)</h3>
<p>机器语言由数字组成所有指令。当让你使用数字编程，写几百个数字、甚至几千个数字，每天面对的是纯数字，我大胆预测：“程序员群体100%会有精神问题”。</p>
<p>机器语言通常由数字串组成（最终被简化成01），对于人类来说，机器语言过于繁琐。使用机器语言，人类无法编出复杂的程序。如下为一段典型的机器码：</p>
<pre><code>  1. 0000,0000,000000010000 代表 LOAD A, 16
  2. 0000,0001,000000000001 代表 LOAD B, 1
  3. 0001,0001,000000010000 代表 STORE B, 16
</code></pre>
<h3 id="第二代语言汇编语言相当于人类的手工业阶段">·第二代语言：汇编语言（相当于人类的手工业阶段）</h3>
<p>为了编程的方便，以及解决更加复杂的问题。程序员开始改进机器语言，使用英文缩写的助记符来表示基本的计算机操作。这些助记符构成了汇编语言的基础。如下是一些常见的汇编语言助记符(单词)比如：LOAD、MOVE之类，这样人更容易使用了。识别几百、几千个单词，感觉要比几百几千个数字，美妙多了。汇编语言相当于人类的手工业社会，需要技术极其娴熟的工匠，但是开发效率也非常低。</p>
<p>汇编语言虽然能编写高效率的程序，但是学习和使用都不是易事，并且很难调试。另一个复杂的问题，汇编语言以及早期的计算机语言（Basic、Fortran等）没有考虑结构化设计原则，而是使用goto语句来作为程序流程控制的主要方法。这样做的后果是：一大堆混乱的调转语句使得程序几乎不可能被读懂。对于那个时代的程序员，能读懂上个月自己写的代码都成为一种挑战。</p>
<p>汇编语言仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。</p>
<h3 id="第三代高级语言相当于人类的工业阶段">·第三代：高级语言（相当于人类的工业阶段）</h3>
<p>对于简单的任务，汇编语言可以胜任。但是随着计算机的发展，渗透到了工作生活的更多的方面，一些复杂的任务出现了，汇编语言就显得力不从心（应该说是程序员使用汇编语言解决复杂问题出现了瓶颈）。于是，出现了高级语言。像我们熟知的C、C++、Java等等都是高级语言。</p>
<p>高级语言允许程序员使用接近日常英语的指令来编写程序。例如，实现一个简单的任务：A+B=C  , 使用机器语言、汇编语言和高级语言的的实现如下图。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494834483891550.png" alt=""></p>
<p>从上面这个简单的加法计算，可以看出越到高级语言，越接近人的思维，人使用起来就越方便。</p>
<p>高级语言的出现，尤其是面向对象语言的出现，相当于人类的工业社会，高级语言极其易用，编程门槛和难度大大降低，大量的人员进入软件开发行业，为软件爆发性的增长提供了充足的人力资源。目前以及可预见的将来，计算机语言仍然处于“第三代高级语言”阶段。</p>
<h2 id="为什么担心软件开发人才饱和是多余的">·为什么担心软件开发人才饱和是多余的？</h2>
<p>很多未进入或刚进入软件行业的朋友，特别担心一个问题“这么多人学，会不会饱和？”。这其实是杞人忧天，越多人编程，才能为软件行业提供巨量的人力资源，才能实现我们以前都不敢想的应用开发。要以发展的眼光看问题，而不是静态的眼光。</p>
<p>越多人编程，越多应用需要做，越多应用需要做，更需要越多人编程。这就像一个农夫刚刚进入工业社会，担心服装工厂工人招满了怎么办? 他没有想到工业发展后，钢铁厂也需要工人、汽车厂也需要工人。年轻朋友请记住“软件行业发展永无止境，将会整合人类现有所有行业，也会创造很多新的行业”。</p>
<h2 id="未来30年必将是软件人才的世界">·未来30年必将是软件人才的世界</h2>
<p>未来30年的世界必将是软件人才的世界；除了普通软件的应用，大批的人工智能应用也将出现；未来自动驾驶、自动翻译、机器人保姆甚至机器人女友都会进入我们的生活，甚至计算机编程和基因工程结合，长生不老都能实现；有兴趣的童鞋，推荐大家看《未来简史》这本书，把握一下未来的脉搏。</p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494834494868544.png" alt=""></p>
<h3 id="请发挥我们年轻人的想象力尽情的在it的世界中挥洒吧">请发挥我们年轻人的想象力，尽情的在IT的世界中挥洒吧！</h3>
]]></content>
		</item>
		
		<item>
			<title>第一章 走进Java</title>
			<link>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%B5%B0%E8%BF%9Bjava/</link>
			<pubDate>Fri, 01 Jan 2021 05:20:06 +0800</pubDate>
			
			<guid>https://HarryQing.github.io/posts/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%B5%B0%E8%BF%9Bjava/</guid>
			<description>目录 1.1 计算机语言发展史以及未来方向 1.2 常见编程语言介绍 1.3.1 Java发展简史 1.3.2 Java的核心优势 1.3.3 Java各版本的含义 1.3.4 Java的特性和优势 1.3.5 Java应用程序的运行机制 1.3.6 JVM、JRE和JDK 1.4.1 JDK下载和安装 1.4.2 环境变量Path的配置 1.4.3 测试JDK安装成功 1.5.1 开发第一个Java程序 1.5.2 第一个程序常见错误 1.5.3 第一个Java程序的总结和提升 1.5.4 最常用DOS命令 1.6 常用Java开发工具 1.7 eclipse使用10分钟入门 1.7.1 下载和安装eclipse 1.7.2 在eclipse中创建Java项目 1.7.3 使用eclipse开发和运行Java程序 1.8 30分钟完成桌球小游戏项目 </description>
			<content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="11-计算机语言发展史以及未来方向">1.1 计算机语言发展史以及未来方向</h2>
<h2 id="12-常见编程语言介绍">1.2 常见编程语言介绍</h2>
<h2 id="131-java发展简史">1.3.1 Java发展简史</h2>
<h2 id="132-java的核心优势">1.3.2 Java的核心优势</h2>
<h2 id="133-java各版本的含义">1.3.3 Java各版本的含义</h2>
<h2 id="134-java的特性和优势">1.3.4 Java的特性和优势</h2>
<h2 id="135-java应用程序的运行机制">1.3.5 Java应用程序的运行机制</h2>
<h2 id="136-jvmjre和jdk">1.3.6 JVM、JRE和JDK</h2>
<h2 id="141-jdk下载和安装">1.4.1 JDK下载和安装</h2>
<h2 id="142-环境变量path的配置">1.4.2 环境变量Path的配置</h2>
<h2 id="143-测试jdk安装成功">1.4.3 测试JDK安装成功</h2>
<h2 id="151-开发第一个java程序">1.5.1 开发第一个Java程序</h2>
<h2 id="152-第一个程序常见错误">1.5.2 第一个程序常见错误</h2>
<h2 id="153-第一个java程序的总结和提升">1.5.3 第一个Java程序的总结和提升</h2>
<h2 id="154-最常用dos命令">1.5.4 最常用DOS命令</h2>
<h2 id="16-常用java开发工具">1.6 常用Java开发工具</h2>
<h2 id="17-eclipse使用10分钟入门">1.7 eclipse使用10分钟入门</h2>
<h2 id="171-下载和安装eclipse">1.7.1 下载和安装eclipse</h2>
<h2 id="172-在eclipse中创建java项目">1.7.2 在eclipse中创建Java项目</h2>
<h2 id="173-使用eclipse开发和运行java程序">1.7.3 使用eclipse开发和运行Java程序</h2>
<h2 id="18-30分钟完成桌球小游戏项目">1.8 30分钟完成桌球小游戏项目</h2>
]]></content>
		</item>
		
	</channel>
</rss>
