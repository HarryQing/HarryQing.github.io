<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mr.哈利-南山不寒</title>
    <link>https://HarryQing.github.io/</link>
    <description>Recent content on Mr.哈利-南山不寒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 14 Mar 2021 00:20:00 +0800</lastBuildDate><atom:link href="https://HarryQing.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>hugo博客在GitHub上进行部署（二）</title>
      <link>https://HarryQing.github.io/blog/hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E4%BA%8C/</link>
      <pubDate>Sun, 14 Mar 2021 00:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/blog/hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E4%BA%8C/</guid>
      <description>创建新文章 hugo new 你的文档名/你的文章名.md
创建库 1.名称一定是：你的用户名.github.io 2.选择本地存储复制
部署到云端 1.在config.toml中改参数 2.生成public: 打开文件根目录的cmd或git bash here输入
hugo 3.进入public 4.在该页面下打开git bash here 5.相继输入以下代码
git init git add -Agit commit -am&amp;quot;init&amp;quot;git branch -M maingit remote add origin https://github.com/你的用户名/你的用户名.github.io.git（假如是我：git remote add origin https://github.com/HarryQing/HarryQing.github.io.git）git push -f origin master（无响应则再次运行同一代码，最多两次）你的博客:https://你的用户名.github.io/假如是我的博客：https://harryqing.github.io/ 笔者 git initgit add -Agit commit -am&amp;quot;init&amp;quot;git branch -M maingit remote add origin https://github.com/HarryQing/HarryQing.github.io.gitgit push -f origin main </description>
    </item>
    
    <item>
      <title>如何将本地图片转成链接？</title>
      <link>https://HarryQing.github.io/blog/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E6%88%90%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 13 Mar 2021 23:10:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/blog/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E6%88%90%E9%93%BE%E6%8E%A5/</guid>
      <description>第一步 打开浏览器，在地址栏中输入链接：https://sm.ms/
第二步 选择如下图中的 Select Image(s) 进行上传图片；
第三步 上传完后，会显示图片，然后点击Upload选项即可；
第四步 生成好的链接，会在Preview选项中有HTML、Markdown等各种；
第五步 这里我们选择Image URL即可看到生成好的 URL 链接。</description>
    </item>
    
    <item>
      <title>第六章 异常机制</title>
      <link>https://HarryQing.github.io/posts/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 07 Mar 2021 23:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</guid>
      <description>预告：后面很精彩，记得持续关注喔！ </description>
    </item>
    
    <item>
      <title>5.12.3 组合模式</title>
      <link>https://HarryQing.github.io/posts/5.12.3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 07 Mar 2021 16:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.12.3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>组合模式是将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
【示例5-34】 对象的组合
class Cpu {public void run() {System.out.println(&amp;quot;quickly.........&amp;quot;);}}class MainBoard {public void connect() {System.out.println(&amp;quot;connect...........&amp;quot;);}}class Memory {public void store() {System.out.println(&amp;quot;store........&amp;quot;);}}public class Computer {Cpu cpu;Memory memory;MainBoard mainBoard;public void work() {cpu.run();memory.store();mainBoard.connect();}public static void main(String[] args) {Computer computer = new Computer();computer.cpu = new Cpu();computer.mainBoard = new MainBoard();computer.</description>
    </item>
    
    <item>
      <title>5.12.2 模板方法模式和回调机制</title>
      <link>https://HarryQing.github.io/posts/5.12.2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 06 Mar 2021 12:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.12.2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</guid>
      <description>模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。 详见抽象类部分示例。
　其实在Java开发中，还有另外一个方法可以实现同样的功能，那就是Java回调技术。回调是一种双向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口，简单点说明就是：A类中调用B类中的C方法，然后B类中的C方法中反过来调用A类中的D方法，那么D这个方法就叫回调方法。
回调的具体过程如下：  1. Class A实现接口CallBack —— 背景12. class A中包含class B的引用 ——背景23. class B有一个参数为CallBack的方法C ——背景34. 前三条是我们的准备条件，接下来A的对象调用B的方法C5. 然后class B就可以在C方法中调用A的方法D 　这样说大家可能还是不太理解，下面我们根据示例5-33来说明回调机制。该示例的生活背景为：有一天小刘遇到一个很难的问题“学习Java选哪家机构呢?”，于是就打电话问小高，小高一时也不太了解行情，就跟小刘说，我现在还有事，等忙完了给你咨询咨询，小刘也不会傻傻的拿着电话去等小高的答案，于是小刘对小高说，先挂电话吧，你知道答案后再打我电话告诉我吧，于是挂了电话。小高先去办自己的事情去了，过了几个小时，小高打电话给小刘，告诉他答案是“学Java当然去北京尚学堂”。
【示例5-33】 回调机制示例
/** * 回调接口 */interface CallBack { /** * 小高知道答案后告诉小刘时需要调用的方法，即回调方法* @param result 是问题的答案 */ public void answer(String result); }/** * 小刘类：实现了回调接口CallBack（背景一） */ class Liu implements CallBack { /** * 包含小高对象的引用 （背景二） */ private Gao gao; public Liu(Gao gao){ this.</description>
    </item>
    
    <item>
      <title>5.12.1 开闭原则</title>
      <link>https://HarryQing.github.io/posts/5.12.1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sat, 06 Mar 2021 10:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.12.1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>开闭原则(Open-Closed Principle)就是让设计的系统对扩展开放，对修改封闭。
· 对扩展开放： 　就是指，应对需求变化要灵活。 要增加新功能时，不需要修改已有的代码，增加新代码即可。
· 对修改关闭： 　就是指，核心部分经过精心设计后，不再因为需求变化而改变。
　在实际开发中，我们无法完全做到，但应尽量遵守开闭原则。</description>
    </item>
    
    <item>
      <title>5.11.5 字符串相等的判断</title>
      <link>https://HarryQing.github.io/posts/5.11.5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD/</link>
      <pubDate>Sat, 06 Mar 2021 08:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.11.5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD/</guid>
      <description>1. equals方法用来检测两个字符串内容是否相等。如果字符串s和t内容相等，则s.equals(t)返回true，否则返回false。
　2. 要测试两个字符串除了大小写区别外是否是相等的，需要使用equalsIgnoreCase方法。
　3. 判断字符串是否相等不要使用&amp;quot;==&amp;quot;。
【示例5-31】 忽略大小写的字符串比较
&amp;quot;Hello&amp;quot;.equalsIgnoreCase(&amp;quot;hellO&amp;quot;);//true 【示例5-32】 字符串的比较&amp;quot;==&amp;ldquo;与equals()方法
public class TestStringEquals {public static void main(String[] args) {String g1 = &amp;quot;大爱雪儿&amp;quot;;String g2 = &amp;quot;大爱雪儿&amp;quot;;String g3 = new String(&amp;quot;大爱雪儿&amp;quot;);System.out.println(g1 == g2); // true 指向同样的字符串常量对象System.out.println(g1 == g3); // false g3是新创建的对象System.out.println(g1.equals(g3)); // true g1和g3里面的字符串内容是一样的}} 执行结果如图5-33所示：
图5-33 示例5-32运行效果图</description>
    </item>
    
    <item>
      <title>5.11.4 String类常用的方法</title>
      <link>https://HarryQing.github.io/posts/5.11.4-string%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 05 Mar 2021 21:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.11.4-string%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>String类是我们最常使用的类。字符串类的方法我们必须非常熟悉!我们列出常用的方法，请大家熟悉。
【示例5-29】 String类常用方法一
public class StringTest1 {public static void main(String[] args) {String s1 = &amp;quot;core Java&amp;quot;;String s2 = &amp;quot;Core Java&amp;quot;;System.out.println(s1.charAt(3));//提取下标为3的字符System.out.println(s2.length());//字符串的长度System.out.println(s1.equals(s2));//比较两个字符串是否相等System.out.println(s1.equalsIgnoreCase(s2));//比较两个字符串（忽略大小写）System.out.println(s1.indexOf(&amp;quot;Java&amp;quot;));//字符串s1中是否包含JavaSystem.out.println(s1.indexOf(&amp;quot;apple&amp;quot;));//字符串s1中是否包含appleString s = s1.replace(&#39; &#39;, &#39;&amp;amp;&#39;);//将s1中的空格替换成&amp;amp;System.out.println(&amp;quot;result is :&amp;quot; + s);}} 执行结果如图5-31所示：
【示例5-30】 String类常用方法二
public class StringTest2 {public static void main(String[] args) {String s = &amp;quot;&amp;quot;;String s1 = &amp;quot;How are you?&amp;quot;;System.out.println(s1.startsWith(&amp;quot;How&amp;quot;));//是否以How开头System.out.println(s1.endsWith(&amp;quot;you&amp;quot;));//是否以you结尾s = s1.</description>
    </item>
    
    <item>
      <title>5.11.3阅读API文档</title>
      <link>https://HarryQing.github.io/posts/5.11.3%E9%98%85%E8%AF%BBapi%E6%96%87%E6%A1%A3/</link>
      <pubDate>Fri, 05 Mar 2021 20:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.11.3%E9%98%85%E8%AF%BBapi%E6%96%87%E6%A1%A3/</guid>
      <description>· 如何下载API文档 　1. 下载地址，点击进入： http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html
图5-27 API下载界面图
　2. 下载成功后，解压下载的压缩文件，点击进入docs/api下的index.html文件即可。
图5-28 打开index.html文件
·API文档如何阅读 图5-29 API文档
· eclipse中将鼠标放到类或方法上，即可看到相关的注释说明;再按下F2即可将注释窗口固定。 图5-30 eclipse中的注释说明图</description>
    </item>
    
    <item>
      <title>5.11.2 String类和常量池</title>
      <link>https://HarryQing.github.io/posts/5.11.2-string%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
      <pubDate>Fri, 05 Mar 2021 19:20:00 +0800</pubDate>
      
      <guid>https://HarryQing.github.io/posts/5.11.2-string%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
      <description>在Java的内存分析中，我们会经常听到关于“常量池”的描述，实际上常量池也分了以下三种：
1. 全局字符串常量池(String Pool) 　全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值(在堆中生成字符串对象实例)。
2. class文件常量池(Class Constant Pool) 　class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量(文本字符串、final常量等)和符号引用。
3. 运行时常量池(Runtime Constant Pool) 　运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。
【示例5-28】 常量池
String str1 = &amp;quot;abc&amp;quot;;String str2 = new String(&amp;quot;def&amp;quot;);String str3 = &amp;quot;abc&amp;quot;;String str4 = str2.intern();String str5 = &amp;quot;def&amp;quot;;System.out.println(str1 == str3);// trueSystem.out.println(str2 == str4);// falseSystem.out.println(str4 == str5);// true 　示例5-28的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象(也就是上例中str1所指向的“abc”实例对象)，然后将这个对象的引用存到全局String Pool中，也就是String Pool中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询String Pool，保证String Pool里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。
　回到示例5-28的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个“abc”实例，全局String Pool中存放着“abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是“def”的实例对象，并且String Pool中存储一个“def”的引用值，还有一个是new出来的一个“def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找String Pool，里面有“abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回String Pool中“def”的引用值，如果没有就将str2的引用值添加进去，在这里，String Pool中已经有了“def”的引用值了，所以返回上面在new str2的时候添加到String Pool中的 “def”引用值，最后str5在解析的时候就也是指向存在于String Pool中的“def”的引用值，那么这样一分析之后，结果就容易理解了。</description>
    </item>
    
  </channel>
</rss>
